(include "./colors.sibilant")

(def sibilant.pretty-print (node color)
     (when (undefined? color) (assign color true))

     (real-newlines (if (node? node) (do
                       (var pretty-printer (or (get sibilant.pretty-print node.type)
                                               sibilant.pretty-print.default))
                       (pretty-printer node color))
         (list? node)
           (concat (if color (black "[") "")
                   (join (if color (black ",") "") (map node prettify))
                   (if color (black "]") ""))

           color (red (util.inspect node))
           (real-newlines (util.inspect node)))))


(def sibilant.pretty-print.default (node color)
     (real-newlines (sibilant.pretty-print.colorize node color
      (concat
       (if (and node.modifiers node.modifiers.length)
           (join "" (map node.modifiers (#(n) (sibilant.pretty-print n color)))) "")
       node.token
       (if (and node.contents node.contents.length)
           (join " " (map node.contents (#(n) (sibilant.pretty-print n color)))) "")
       (or (and node.closed (get acceptable-pairs node.token)) "")))))

(def sibilant.pretty-print.root (node color)
     (join "\n" (map node.contents (#(n) (sibilant.pretty-print n color)))))

(def sibilant.pretty-print.output (node color)
     (concat (if color (black "{") "")
             (if (list? node.contents)
                 (join (if color (black ",") "")
                       (map node.contents (#(c) (sibilant.pretty-print.colorize node color (prettify c)))))
                 (sibilant.pretty-print.colorize node color node.contents))
             (if color (black "}") "")))

(def real-newlines (node)
     (chain node (split "\\n") (join "\n")))


(def sibilant.pretty-print.colorize (node color string)
     (if (not color) string
         (= node.hint 'macro) (yellow string)
         (= node.type 'output) (purple string)
         (green string)))

(var prettify sibilant.pretty-print)