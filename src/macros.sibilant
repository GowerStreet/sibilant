(var macros {})
(set sibilant 'macros macros)

(def escape-regex (string)
     (string.replace (regex "[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\^\\$\\|]" 'g) "\\$&"))

(def ^return (token)
     (var default-return (as-statement ["return " (transpile token)]))
     (if (and token token.contents token.contents.length
              (empty? (get (first token.contents) 'modifiers)))
         (switch (get (first token.contents) 'token)
                 (('return 'throw 'do) (transpile token))
                 ('delete
                  (var delete-macro (get macros 'delete))
                  (if (< token.length 3) default-return
                      [ (as-statement (apply delete-macro (token.contents.slice 1 -1)))
                              "\nreturn "
                              (as-statement (call delete-macro (last token.contents)))]))
                 ('assign
                  (if (< token.contents.length 4) default-return
                      [ (apply ^assign
                                     (token.contents.slice 1 (- token.contents.length 2)))
                              "\nreturn "
                              (apply ^assign (token.contents.slice -2))]))
                 ('var
                  [ (transpile token) "\nreturn " (transpile (if (even? token.contents.length)
                                                                       (last token.contents)
                                                                       (first (token.contents.slice -2))))])
                 ('set
                  (if (< token.length 5) default-return
                      (do
                       (var obj (second token.contents)
                            non-return-part (token.contents.slice 2 (- token.contents.length 2))
                            return-part (token.contents.slice -2))
                       (non-return-part.unshift obj)
                       (return-part.unshift obj)
                       [ (^set ...non-return-part)
                               "\nreturn "
                               (^set ...return-part)])))
                 (default default-return))
         default-return))


(def ^list (...args) ["[ " (interleave ", " (map args transpile)) " ]"])

(def statement? (transpiled)
     (if (list? transpiled) (statement? (last (compact transpiled)))
         (string? transpiled) (= ";" (last transpiled))
         false))

(def as-statement (node)
     (var transpiled (transpile node))
     (if (empty? (compact (flatten transpiled))) transpiled
         (and transpiled transpiled.length (statement? transpiled)) transpiled
         [ transpiled ";" ]))

(def ^statement (...args)
     [ (^call ...args) ";\n" ])

(def ^do (...body)
     (if (= 1 body.length) (^return (first body))
         body.length [ (interleave "\n" (map (slice body 0 -1) (#(node) (as-statement (transpile node)))))
                       "\n"
                       (^return (last body)) ]
         ""))

(def ^empty-list () 'null)

(def ^call (fn-name ...args)
     [ (transpile fn-name)
             "(" (interleave ", " (map args transpile)) ")"])

(def ^def (fn-name args ...body)
     (var fn-name-tr (transpile fn-name))

     (as-statement [ (if (match? (regex "\\.") fn-name-tr) "" "var ")
             fn-name-tr " = "
             (^lambda { name fn-name args args } ...body)
       ] ))

(def ^macro (name args ...body)
     (var name-tr (transpile name)
          options { name name args args }
          js (join "" (flatten (^lambda options ...body))))

          (try (set macros name-tr (eval js))
          (error ("error in parsing macro "
                  (sibilant.pretty-print name) ":\n" js)))

     undefined)

(def ^concat (...args)
     ["(" (interleave " + " (map args transpile)) ")"])

(def ^reverse (arr)
     (var reversed [])
     (each (item) arr (reversed.unshift item))
     reversed)

(var reverse ^reverse)

(def ^lambda (args-or-options ...body)
     (var args (or (get args-or-options 'args) args-or-options)
          body (or (get args-or-options 'body) body)
          args (or args.contents args)
          name (when args-or-options.name
                     (chain (transpile args-or-options.name)
                            (replace (regex "\\W+" 'g) "$")
                            (concat "$")))
          rest (detect args
                       (#(arg)
                         (when arg.modifiers
                               (var mod (first arg.modifiers))
                               (and mod (= "..." mod.token))))))
     
     (var this-node this
          node (detect
                (map [ this-node args-or-options.name args (first body) ]
                     (#(n) (if n n.parent n)))
                (#(n) (and n (get n 'file)))))
     ["(function" (if name (" " name) "") "("
                  (interleave ", " (map args transpile)) ") {"
                  (if (or args-or-options.name node)
                      (indent ["/*"
                               (if args-or-options.name (" " (sibilant.pretty-print args-or-options.name)) "")
                               (if node (" " node.file ":" node.line ":" node.col) "")
                               " */"]) "")
       (when (exists? rest)
                       (indent ["var " (transpile rest)
                                      " = Array.prototype.slice.call(arguments, "
                                      (- args.length 1) ");"]))

                  (indent (apply ^do body))
                  "})"])

(set macros "#" ^lambda)

(def ^hash (...pairs)
     (when (odd? pairs.length)
           (error ("odd number of key-value pairs in hash: "
                   (call inspect pairs))))

     (var quote-keys ^hash.quote-keys
          pair-strings (bulk-map pairs (#(key value)
                                         [ (if quote-keys
                                                     ["\"" (transpile key) "\""]
                                                     (transpile key))
                                                 ": "
                                                 (transpile value)])))
     (if (>= 1 pair-strings.length)
         ["{ " (interleave ", " pair-strings) " }"]
         ["{" (indent (interleave ",\n" pair-strings)) "}"]))


