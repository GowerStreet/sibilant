(var core-namespace {}
     macro-namespaces { core core-namespace })
(set sibilant
     'state {}
     'macros
     { 'namespaces macro-namespaces
       'default-search-path ['core]
       'search-path ['core]
       'namespace core-namespace })

(var namespace sibilant.macros.namespace macros sibilant.macros.namespace)

(def has-key? (object key)
       (send object has-own-property key))

(def sibilant.resolve-macro (macro-name)
     (if (and (includes? macro-name "/") (not (includes? macro-name "\n")))
         (do (var path-components (macro-name.split "/")
                  macro (and (has-key? sibilant.macros.namespaces (first path-components))
                             (get sibilant.macros.namespaces (first path-components)
                                  (join "/" (rest path-components)))))
             (if macro macro
                 (error ("called namespaced macro " macro-name
                         " but could not find namespace " (first path-components)
                         ". you might need to include the file that defines it first." ))))
         (do
          (var namespace (detect sibilant.macros.search-path
                            (#(namespace)
                              (has-key? (get sibilant.macros.namespaces namespace)
                                        macro-name))))
          (when namespace (get sibilant.macros.namespaces namespace macro-name)))))

(def sibilant.with-default-search-path (fn)
     (var search-path-before sibilant.macros.search-path)
     (set sibilant.macros 'search-path sibilant.macros.default-search-path)
     (var return-value (fn))
     (set sibilant.macros 'search-path search-path-before)
     return-value)
     
          