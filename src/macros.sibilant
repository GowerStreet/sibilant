(var macros {})
(set sibilant 'macros macros 'debug false)


(def recurse-indent (...args)
     (map args
          (#(arg)
            (if (node? arg) (do (set arg 'contents (apply recurse-indent (compact (flatten arg.contents)))) arg)
                (list? arg) (apply recurse-indent arg)
                (number? arg) (arg.to-string)
                (string? arg)
                (chain arg
                       (replace (regex "\\n" 'g) "\n  ")
                       (replace (regex "\\n\\s+\\n" 'g) "\n\n"))

                 arg))))

(def indent (...args)
     ["\n  " (recurse-indent args) "\n"])


(def escape-regex (string)
     (string.replace (regex "[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\^\\$\\|]" 'g) "\\$&"))

(def ^return (token)
     (when sibilant.debug (console.log "returning " (prettify token)))
     (var default-return (as-statement ["return " (transpile token)]))
     (if (and token token.contents token.contents.length)
         (switch (get (first token.contents) 'token)
                 (('return 'throw 'do) (transpile token))
                 ('delete
                  (var delete-macro (get macros 'delete))
                  (if (< token.contents.length 3) default-return
                      [ (as-statement (apply delete-macro (token.contents.slice 1 -1)))
                        "\nreturn "
                        (as-statement (call delete-macro (last token.contents)))]))
                 ('assign
                  (if (< token.contents.length 4) default-return
                      [ (apply ^assign
                               (token.contents.slice 1 (- token.contents.length 2)))
                        "\nreturn "
                        (apply ^assign (token.contents.slice -2))]))
                 ('var
                  [ (transpile token) "\nreturn " (transpile (if (even? token.contents.length)
                                                                 (last token.contents)
                                                                 (first (token.contents.slice -2))))])
                 ('set
                  (if (< token.contents.length 5) default-return
                      (do
                       (var obj (second token.contents)
                            non-return-part (token.contents.slice 2 (- token.contents.length 2))
                            return-part (token.contents.slice -2))
                       (non-return-part.unshift obj)
                       (return-part.unshift obj)
                       [ (^set ...non-return-part)
                         "\nreturn "
                         (^set ...return-part)])))
                 (default default-return))
         default-return))


(def statement? (transpiled)
     (if (node? transpiled) (statement? transpiled.contents)
         (list? transpiled) (statement? (last transpiled))
         (string? transpiled) (= ";" (last transpiled))
         false))

(def as-statement (node)
     (var transpiled (transpile node))

     (if (empty-node? transpiled) undefined
         (statement? transpiled) transpiled
         [ transpiled ";" ]))

(def ^do (...body)
     (if (= 1 body.length) (^return (first body))
         body.length [ (interleave "\n" (map (body.slice 0 -1) (#> (as-statement #0))))
                       "\n"
                       (^return (last body)) ]
         ""))

(def ^empty-list () 'null)

(def ^def (fn-name args ...body)
     (if (undefined? fn-name) (error "invalid function definition. missing name.")
         (undefined? args) (error "invalid function definition. missing arguments or return value."))

     (var fn-name-tr (transpile fn-name) this-node this)

     (as-statement [ (if (match? (regex "\\.") (output-formatter fn-name-tr)) "" "var ")
                     fn-name-tr " = "
                     (^lambda { name fn-name args args node this-node } ...body )
                     ] ))

(def ^macro (name args ...body)
     (var name-tr (output-formatter (transpile name))
          options { name name args args node this}
          js (output-formatter (^lambda options ...body)))

     (when sibilant.debug (console.log js))
     
     (try (set macros name-tr (eval js))
          (error ("error in parsing macro "
                  (sibilant.pretty-print name) ":\n" js)))

     undefined)

(def ^meta (...body)
     (var js (output-formatter (^scoped ...body)))
     (when sibilant.debug (console.log js))
     (output-formatter (eval js)))


(def ^concat (...args)
     ["(" (interleave " + " (map args transpile)) ")"])

(def ^reverse (arr)
     (var reversed [])
     (each (item) arr (reversed.unshift item))
     reversed)

(var reverse ^reverse)

(def ^lambda (args-or-options ...body)
     (when sibilant.debug
           (console.log args-or-options))
     (var args (or (get args-or-options 'args) args-or-options)
          body (or (get args-or-options 'body) body)
          args (if (node? args 'expression) args.contents
                   (and (node? args) (empty? body)) (do (assign body [ args ]) [])
                   args)
          name (when args-or-options.name
                     (chain (output-formatter (transpile args-or-options.name))
                            (replace (regex "\\W+" 'g) "$")
                            (concat "$")))
          rest (detect args
                       (#> (node? #0 'dots))))

     (var this-node this
          node (detect
                [ args-or-options.node this-node args-or-options.name args (first body) ]
                (#(n) (and (node? n) (get n 'file)))))
     ["(function" (if name (" " name) "") "("
       (interleave ", " (map args transpile)) ") {"
       (if (or args-or-options.name node)
           (indent ["/*"
                     (if args-or-options.name (" " (sibilant.pretty-print args-or-options.name false)) "")
                     (if node (" " node.file ":" node.line ":" node.col) "")
                     " */"]) "")
       (when (exists? rest)
             (indent (as-statement ["var " (transpile rest)
                       " = Array.prototype.slice.call(arguments, "
                       (- args.length 1) ")"])))

       (indent (apply ^do body))
       "})"])

(set macros "#" ^lambda)

(def ^quoted-hash (...pairs)
     (var cached-quote-value ^hash.quote-keys)
     (set ^hash 'quote-keys true)
     (var value (^hash ...pairs))
     (set ^hash 'quote-keys cached-quote-value)
     value)

(def ^hash (...pairs)
     (when (odd? pairs.length)
           (error ("odd number of key-value pairs in hash: "
                   (call inspect pairs))))

     (var quote-keys ^hash.quote-keys
          pair-strings (bulk-map pairs (#(key value)
                                         [ (if (and quote-keys (not (node? key 'string)))
                                               ["\"" (transpile key) "\""]
                                               (transpile key))
                                           ": "
                                           (transpile value)])))
     (if (>= 1 pair-strings.length)
         ["{ " (interleave ", " pair-strings) " }"]
         ["{" (indent (interleave ",\n" pair-strings)) "}"]))


(def qescape (content)
     (if (not (exists? content)) ""
         (string? content) (chain content
                                  (replace (regex "\"" 'g) "\\\"")
                                  (replace (regex "\\n" 'g) "\\n\" +\n\""))
         content))

(def log-pretty (label arg)
     (console.log (concat label ": " (prettify arg)))
     arg)

(var pretty-log log-pretty)

(def ^quote (content)
     (if (string? content) ("\"" (qescape content) "\"")
         (number? content) (^quote (content.to-string))
         (node? content 'literal) ["\"" (transpile content) "\""]
         (node? content 'expression)
         (if (length (keys (find-unquotes content)))
             (^call 'macros.expand-quote.call 'this (^quote content.node-id)
                    (apply ^quoted-hash (alternating-keys-and-values (find-unquotes content))))
             ["\"" (map-node (transpile content) qescape) "\""])

         (node? content 'bracket)
         (if (length (keys (find-unquotes content)))
             (^call 'macros.expand-quote.call 'this (^quote content.node-id)
                    (apply ^quoted-hash (alternating-keys-and-values (find-unquotes content))))
             (^list ...(map content.contents ^quote)))

         (node? content 'brace)
         (if (length (keys (find-unquotes content)))
             (^call 'macros.expand-quote.call 'this (^quote content.node-id)
                    (apply ^quoted-hash (alternating-keys-and-values (find-unquotes content))))
             (^hash ...(map content.contents ^quote)))

         (do
          (console.log ("unknown content" (prettify content)))
          content)))

(def ^debug (val)
     (set sibilant 'debug (eval (output-formatter (transpile val)))) null)

(def map-node (node fn)
     (if (node? node)
         (do
          (var mapped-node (fn node))
          (when (node? mapped-node)
                (set mapped-node 'contents (map-node mapped-node.contents fn)))

          mapped-node)

         (list? node) (map node (#> (map-node #0 fn)))
         (fn node)))

(def each-node (node fn)
     (if (node? node) (when (fn node) (each-node node.contents fn))
         (list? node) (each (c) node (each-node c fn))
         (fn node)))


(def map-node-for-quote-expansion (node expansions)
     (if (node? node)
         (do
          (var mapped-node (if (expansions.has-own-property node.node-id) (get expansions node.node-id) (clone node)))
          (when (node? mapped-node)
                (set mapped-node 'contents (map-node-for-quote-expansion mapped-node.contents expansions)))

          (assign mapped-node (splice-dots mapped-node))
          mapped-node)

         (list? node)
           (map node (#> (map-node-for-quote-expansion #0 expansions)))

         node))


(def ^expand-quote (node-id expansions)
     (var expanded-nodes
          (map-node-for-quote-expansion (get sibilant.node-cache node-id) expansions))

     (transpile expanded-nodes))

(def unquote? (node) (node? node 'at))

(def find-unquotes (node)
     (var unquotes {})
     (each-node node (#(n)
                       (when (unquote? n)
                             (set unquotes n.node-id (transpile n)))
                       (not (node? n 'tick))))
     unquotes)

(def splice-dots (node)
     (when (and node (list? node.contents))
           (var contents [])
           (each (content) node.contents
                 (if (and (node? content 'dots)
                          (list? content.contents)
                          (= content.contents.length 1)
                          (list? (first content.contents)))
                      (contents.push.apply contents (first content.contents))
                      (contents.push content)))

           (set node 'contents contents))
     node)


(def alternating-keys-and-values (hash)
     (flatten (map (keys hash)
                   (#(key) [key, (get hash key)]))))


(def ^list (...args)
       (var arg-segments [])
       (if (empty? args) "[]"
           (do
            (def simple-list (args)
                 ["[ " (interleave ", " (map args (#(arg) arg.transpiled))) " ]"])

            (args.for-each (#(arg)
                  (if (node? arg 'dots) (arg-segments.push {transpiled (transpile arg)})
                   (list? (last arg-segments)) (send (last arg-segments) push {transpiled (transpile arg)})
                   (arg-segments.push [{transpiled (transpile arg)}]))))

            (assign arg-segments (map arg-segments
                                      (#(segment)
                                        (if (list? segment)
                                            (simple-list segment)
                                            segment.transpiled))))

            (if (= 1 (length arg-segments))
                (first arg-segments)
                [(first arg-segments) ".concat(" (interleave ", " (rest arg-segments))")"]))))


(def ^call (fn-name ...args)
     (if (any? args (#> (node? #0 'dots)))
           (macros.apply fn-name (macros.list ...args))
           [ (transpile fn-name)
                   "(" (interleave ", " (map args transpile)) ")" ]))

(def ^dots (...contents)
     (transpile contents))

