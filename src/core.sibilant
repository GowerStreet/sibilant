(def ^return (token)
     (when sibilant.debug (console.log "returning " (prettify token)))
     (var default-return (as-statement ["return " (transpile token)]))
     (if (and token token.contents token.contents.length)
         (switch (get (first token.contents) 'token)
                 (('return 'throw 'do) (transpile token))

                 ('delete
                  (var delete-macro (get macros 'delete))
                  (if (< token.contents.length 3) default-return
                      [ (as-statement (apply delete-macro (token.contents.slice 1 -1)))
                        "\nreturn "
                        (as-statement (call delete-macro (last token.contents)))]))

                 ('def
                  [ (transpile token) "\n" (^return (second token.contents)) ])

                 ('assign
                  (if (< token.contents.length 4) default-return
                      (do
                       (var result (clone (transpile token)))
                       (set result 'contents [ ...(result.contents.slice 0 -4)
                                               "return "
                                               ...(result.contents.slice -4) ])
                       result)))

                 ('var
                  [ (transpile token) "\n" (^return (if (even? token.contents.length)
                                                                 (last token.contents)
                                                                 (first (token.contents.slice -2))))])

                 ('set
                  (if (< token.contents.length 5) default-return
                      (do
                       (var obj (second token.contents)
                            non-return-part (token.contents.slice 2 (- token.contents.length 2))
                            return-part (token.contents.slice -2))
                       (non-return-part.unshift obj)
                       (return-part.unshift obj)
                       [ (^set ...non-return-part)
                         "\nreturn "
                         (^set ...return-part)])))

                 (default default-return))
         default-return))


(def ^do (...body)
     (if (= 1 body.length) (^return (first body))

         body.length [ (interleave "\n" (map (body.slice 0 -1) (#> (as-statement #0))))
                       "\n"
                       (^return (last body)) ]
         ""))

(def ^empty-list () 'null)

(def ^def (fn-name args ...body)
     (if (undefined? fn-name) (error "invalid function definition. missing name.")
         (undefined? args) (error "invalid function definition. missing arguments or return value."))

     (var fn-name-tr (transpile fn-name) this-node this)
     (sibilant.docs.record 'function (first sibilant.macros.search-path) fn-name this)

     (as-statement [ (if (match? (regex "\\.") (output-formatter fn-name-tr)) "" "var ")
                     fn-name-tr " = "
                     (^lambda { name fn-name args args node this-node } ...body )
                     ] ))

(def ^macro (name args ...body)
     (var name-tr (output-formatter (transpile name))
          options { name name args args node this}
          js (output-formatter (^lambda options ...body)))

     (when sibilant.debug (console.log js))

     (sibilant.docs.record 'macro (first sibilant.macros.search-path) name this)
     
     (try (set sibilant.macros.namespace name-tr (eval js))
          (error ("error in parsing macro "
                  (sibilant.pretty-print name) ":\n" js)))

     undefined)

(def ^meta (...body)
     (var js (output-formatter (^scoped ...body)))
     (when sibilant.debug (console.log js))
     (output-formatter (eval js)))


(def ^concat (...args)
     ["(" (interleave " + " (map args transpile)) ")"])

(def ^reverse (arr)
     (var reversed [])
     (each (item) arr (reversed.unshift item))
     reversed)

(var reverse ^reverse)

(def ^lambda (args-or-options ...body)
     (when sibilant.debug
           (console.log args-or-options))
     (var args (or (get args-or-options 'args) args-or-options)
          body (or (get args-or-options 'body) body)
          args (if (node? args 'expression) args.contents
                   (and (node? args) (empty? body)) (do (assign body [ args ]) [])
                   args)
          name (when args-or-options.name
                     (chain (output-formatter (transpile args-or-options.name))
                            (replace (regex "\\W+" 'g) "$")
                            (concat "$")))
          rest (detect args
                       (#> (node? #0 'dots))))

     (var this-node this
          node (detect
                [ args-or-options.node this-node args-or-options.name args (first body) ]
                (#(n) (and (node? n) (get n 'file)))))
     ["(function" (if name (" " name) "") "("
       (interleave ", " (map args transpile)) ") {"
       (if (or args-or-options.name node)
           (indent ["/*"
                     (if args-or-options.name (" " (sibilant.pretty-print args-or-options.name false)) "")
                     (if node (" " node.file ":" node.line ":" node.col) "")
                     " */"]) "")
       (when (exists? rest)
             (indent (as-statement ["var " (transpile rest)
                       " = Array.prototype.slice.call(arguments, "
                       (- args.length 1) ")"])))

       (indent (apply ^do body))
       "})"])

(set sibilant.macros.namespaces.core "#" ^lambda)

(def ^quoted-hash (...pairs)
     (var cached-quote-value sibilant.quote-hash-keys)
     (set sibilant 'quote-hash-keys true)
     (var value (^hash ...pairs))
     (set sibilant 'quote-hash-keys cached-quote-value)
     value)

(def ^hash (...pairs)
     (when (odd? pairs.length)
           (error ("odd number of key-value pairs in hash: "
                   (call inspect pairs))))

     (var quote-keys sibilant.quote-hash-keys
          pair-strings (bulk-map pairs (#(key value)
                                         [ (if (and quote-keys (not (node? key 'string)))
                                               ["\"" (transpile key) "\""]
                                               (transpile key))
                                           ": "
                                           (transpile value)])))
     (if (>= 1 pair-strings.length)
         ["{ " (interleave ", " pair-strings) " }"]
         ["{" (indent (interleave ",\n" pair-strings)) "}"]))


(def ^quote (content)
     (if (string? content) ("\"" (qescape content) "\"")
         (number? content) (^quote (content.to-string))
         (node? content 'literal) ["\"" (transpile content) "\""]
         
         (node? content 'expression)
         (if (length (keys (find-unquotes content)))
             (^call 'macros.expand-quote.call 'this (^quote content.node-id)
                    (apply ^quoted-hash (alternating-keys-and-values (find-unquotes content))))
             ["\"" (map-node (transpile content) qescape) "\""])

         (node? content 'bracket)
         (if (length (keys (find-unquotes content)))
             (^call 'macros.expand-quote.call 'this (^quote content.node-id)
                    (apply ^quoted-hash (alternating-keys-and-values (find-unquotes content))))
             (^list ...(map content.contents ^quote)))

         (node? content 'brace)
         (if (length (keys (find-unquotes content)))
             (^call 'macros.expand-quote.call 'this (^quote content.node-id)
                    (apply ^quoted-hash (alternating-keys-and-values (find-unquotes content))))
             (^hash ...(map content.contents ^quote)))

         (do
          (console.log ("unknown content" (prettify content)))
          content)))

(def ^debug (val)
     (set sibilant 'debug (eval (output-formatter (transpile val)))) null)

(def ^expand-quote (node-id expansions)
     (var expanded-nodes
          (map-node-for-quote-expansion (get sibilant.node-cache node-id) expansions))

     (transpile expanded-nodes))


(def ^list (...args)
       (var arg-segments [])
       (if (empty? args) "[]"
           (do
            (def simple-list (args)
                 ["[ " (interleave ", " (map args (#(arg) arg.transpiled))) " ]"])

            (args.for-each (#(arg)
                  (if (node? arg 'dots) (arg-segments.push {transpiled (transpile arg)})
                   (list? (last arg-segments)) (.push (last arg-segments) { transpiled (transpile arg)})
                   (arg-segments.push [{transpiled (transpile arg)}]))))

            (assign arg-segments (map arg-segments
                                      (#(segment)
                                        (if (list? segment)
                                            (simple-list segment)
                                            segment.transpiled))))

            (if (= 1 (length arg-segments))
                (first arg-segments)
                [(first arg-segments) ".concat(" (interleave ", " (rest arg-segments))")"]))))


(def ^call (fn-name ...args)
     (if (any? args (#> (node? #0 'dots)))
           (macros.apply fn-name (macros.list ...args))
           [ (transpile fn-name)
                   "(" (interleave ", " (map args transpile)) ")" ]))

(def ^dots (...contents)
     (transpile contents))

(def ^include (...files)
     (pipe files
           (.map (#(file)
                   (sibilant.with-default-search-path
                    (#> (pipe file
                              transpile
                              output-formatter
                              eval
                              sibilant.include)))))
           (interleave "\n")))

(def ^docs (...options)
     (var options-string undefined
          options-hash {})

     (when (odd? options.length)
           (if (or (node? (first options) 'string) (string? (first options)))
               (assign options-string (options.shift))

               (or (node? (last options) 'string) (string? (last options)))
               (assign options-string  (options.pop))))

     (bulk-map options (#(key value)
                         (set options-hash (pipe key transpile output-formatter) value)))

     (each (list-attribute) `[ examples references ]
           (when (and (has-key? options-hash list-attribute)
                      (node? (get options-hash list-attribute) 'bracket))
                 (set options-hash list-attribute
                      (get options-hash list-attribute 'contents))))
     
     (when (has-key? options-hash 'example)
           (when (has-key? options-hash 'examples) (error "please provide example OR examples, not both"))
           (set options-hash 'examples [options-hash.example])
           (delete options-hash.example))

     (when (has-key? options-hash 'tags)
           (set options-hash 'tags
                (|> options-hash.tags (^quote) transpile output-formatter eval)))

     (if (node? options-string 'string)
           (set options-hash 'doc-string (pipe options-string
                                               transpile
                                               output-formatter
                                               eval))
           (string? options-string) (set options-hash 'doc-string options-string))

     (set sibilant.docs 'last-doc options-hash)
     null)
