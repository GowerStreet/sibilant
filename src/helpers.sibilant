

(def tap (item fn)
     (fn item)
     item)

(def recurse-indent (...args)
     (map args
          (#(arg)
            (if (node? arg)
                (merge-into arg { contents (recurse-indent ...(compact (flatten arg.contents))) })

                (list? arg) (recurse-indent ...arg)

                (number? arg) (arg.to-string)

                (string? arg)
                (|> arg
                    (replace-all "\\n" "\n  ")
                    (replace-all "\\n\\s+\\n" "\n\n"))

                arg))))

(def indent (...args)
     ["\n  " (recurse-indent (map args transpile)) "\n"])

(def escape-regex (string)
     (string.replace (regex "[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\^\\$\\|]" 'g) "\\$&"))

(def qescape (content)
     (if (not (exists? content)) ""
         (string? content) (pipe content
                                 (.split (first "\\\\ "))
                                 (.join (.slice "\\\\ " 0 -1))
                                 (replace-all "\"" "\\\"")
                                 (replace-all "\\n" "\\n\" +\n\""))
         content))

(def map-node (node fn)
     (if (node? node)
         (do
          (var mapped-node (fn node))
          (when (node? mapped-node)
                (set mapped-node 'contents (map-node mapped-node.contents fn)))

          mapped-node)

         (list? node) (map node (#> (map-node #0 fn)))
         (fn node)))

(def each-node (node fn)
     (if (node? node) (when (fn node) (each-node node.contents fn))
         (list? node) (each (c) node (each-node c fn))
         (fn node)))

(def statement? (transpiled)
     (if (node? transpiled) (statement? transpiled.contents)
         (list? transpiled) (statement? (last transpiled))
         (string? transpiled) (= ";" (last transpiled))
         false))

(def as-statement (node)
     (var transpiled (transpile node))

     (if (empty-node? transpiled) undefined
         (statement? transpiled) transpiled
         [ transpiled ";" ]))

(def unquote? (node) (node? node 'at))

(def find-unquotes (node)
     (var unquotes {})
     (each-node node (#(n)
                       (when (unquote? n)
                             (set unquotes n.node-id (transpile n)))
                       (not (node? n 'tick))))
     unquotes)

(def splice-dots (node)
     (when (and node (list? node.contents))
           (var contents [])
           (each (content) node.contents
                 (if (and (node? content 'dots)
                          (list? content.contents)
                          (= content.contents.length 1)
                          (list? (first content.contents)))
                     (contents.push.apply contents (first content.contents))
                     (contents.push content)))

           (set node 'contents contents))
     node)


(def alternating-keys-and-values (hash)
     (flatten (map (keys hash)
                   (#(key) [key, (get hash key)]))))


(def map-node-for-quote-expansion (node expansions)
     (if (node? node)
         (do
          (var mapped-node (if (expansions.has-own-property node.node-id) (get expansions node.node-id) (clone node)))
          (when (node? mapped-node)
                (set mapped-node 'contents (map-node-for-quote-expansion mapped-node.contents expansions)))

          (assign mapped-node (splice-dots mapped-node))
          mapped-node)

         (list? node)
         (map node (#> (map-node-for-quote-expansion #0 expansions)))

         node))

(def replace! (content)
     (if
      (and (node? content 'dots)
           (= 3 content.token.length)
           (node? (first content.contents) 'at))
      (merge-into (clone content)
                  { contents (|> content.contents first transpile list) })

      
      (node? content 'at)
      (transpile (first content.contents))

      (node? content 'tick)
      (JSON.stringify content)

      (object? content)
      (^hash ...(|> content keys
                    (.reduce
                     (#-> (.concat [ #1 (replace! (get content #1)) ]))
                     [])))
      
      (array? content)
      (^list ...(map content replace!))

      (undefined? content)
      'undefined

      (number? content)
      (content.to-string)

      (JSON.stringify content)))



(def node? (thing ...types)
     (and
      (exists? thing)
      (= 'object (typeof thing))
      (string? thing.type)
      (or (empty? types) (includes? types thing.type))
      (has-key? thing 'contents)))

(def empty-node? (item)
     (if (node? item) (empty-node? item.contents)
         (list? item) (all? item empty-node?)
         (string? item) (item.match (regex "^\\s*$"))
         (or (= null item)
             (undefined? item)
             (= false item))))

(def compact-node (item)
     (if (node? item) (do
                       (set item 'contents (compact-node item.contents))
                       (if (and item.contents item.contents.length) item null))
         (list? item) (do
                       (var compacted (compact (map item compact-node)))
                       (if (and compacted compacted.length) compacted null))
         (if (or (= item "") (= item false)) null item)))


(def generate-symbol (clue)
     (var {state} sibilant)
     (default clue 'temp
              state.symbol-counts {})
     (var count (|> state.symbol-counts
         (get clue)
         (or 0)
         (+ 1)))
     (set state.symbol-counts clue count)
     [(""clue"$"count)])

(def make-symbol-clue (node)
     
     (|> (if (and (node? node 'expression) (|> node.contents first (get 'token) (= 'require)))
             (|> node.contents second)
             (node? node 'expression) (first node.contents)
             node)
         transpile
         output-formatter
         (replace-all "[^a-zA-Z]+" "_")
         (replace-all "^_|_$" "")))

(def destructure (pairs)
     (var destructured [])
     (bulk-map pairs (#(lhs rhs)
                       (var transpiled-rhs (transpile rhs))
                       (switch lhs.type
                               ('bracket
                                (var literal-rhs? (|> transpiled-rhs (output-formatter) (match-regex? "^[\._a-zA-Z0-9]+$"))
                                     source (if literal-rhs?
                                                transpiled-rhs
                                                (do                             
                                                 (var symbol (generate-symbol (make-symbol-clue rhs)))
                                                 (destructured.push [symbol transpiled-rhs])
                                                 symbol)))
                                (each (item index) lhs.contents
                                      (destructured.push [(transpile item) '(get @source @index)]))
                                (unless literal-rhs?
                                        (destructured.push [source 'undefined])))
                               ('brace
                                (var literal-rhs? (|> transpiled-rhs (output-formatter) (match-regex? "^[\._a-zA-Z0-9]+$"))
                                     source (if literal-rhs?
                                                transpiled-rhs

                                                (= 1 (length lhs.contents)) ["(" rhs ")"]
                                                
                                                (do                             
                                                 (var symbol (generate-symbol (make-symbol-clue rhs)))
                                                 (destructured.push [symbol transpiled-rhs])
                                                 symbol)))
                                (each (item index) lhs.contents
                                      (var tr-item (transpile item))
                                      (destructured.push [tr-item '(get @source @["\"" tr-item "\""])]))
                                (unless (or literal-rhs? (= 1 (length lhs.contents)))
                                        (destructured.push [source 'undefined])))

                               (default
                                (destructured.push [ (transpile lhs)
                                                     (if rhs transpiled-rhs 'undefined)])))))
     destructured)
