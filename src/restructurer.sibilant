(var restructurers {}
     acceptable-pairs { "(" ")" "[" "]" "{" "}" }
     bracket-types { "(" 'expression
                     "[" 'bracket
                     "{" 'brace })

(def restructure (input)
     (var output { type 'root
                   contents []
                   file sibilant.file
                   col 0
                   line 1 }
          context { parse-stack [output]
                    output output
                    input input
                    ignored-tokens []
                    specials 0 })

     (inject context input
             (#(context token index)
               (var restructurer (or (get restructurers token.type) restructurers.default))
               (restructurer token context index)))

     (unless (= 1 (length context.parse-stack))
             (var unclosed-node (|> context.parse-stack first))
             (throw (new Error ("unclosed node at " unclosed-node.file":"unclosed-node.line":"unclosed-node.col"\n  "
                                (|> unclosed-node
                                    (prettify false)
                                    (.slice 0 100))))))

     output)

(set sibilant 'restructure restructure)

(def restructurers.open-expression (token context)
     (var first (first context.parse-stack))
     (set token
          'contents []
          'type (get bracket-types token.token))
     (accept-ignored-tokens token context)
     (accept-specials token context)
     (.push first.contents token)
     (context.parse-stack.unshift token)
     context)


(def restructurers.close-expression (node context index)
     (var first (first context.parse-stack))

     (when (node? first 'root)
           (throw (new Error ("unexpected " node.token " on "node.file":"node.line":"node.col))))
     (when (!= (get acceptable-pairs first.token) node.token)
           (throw (new Error ("trying to close " (yellow (sibilant.pretty-print first))
                                      "\n   on "first.file":"first.line":"first.col
                                      "\n   with "(sibilant.pretty-print node)
                                      "\n   on "node.file":"node.line":"node.col
                                      "\n"))))

     (set first
          'end node.end
          'closed true
          'closing-ignored context.ignored-tokens)
     (set context 'ignored-tokens [])

     (context.parse-stack.shift)
     (close-specials first context)
     (when (zero? context.parse-stack.length)
           (throw (new Error ("unbalanced parens:\n"
                   (call inspect parse-stack)))))
     context)

(def open-special (node context)
     (incr context.specials)

     (accept-ignored-tokens node context)

     (var first (first context.parse-stack))
     (set node
          'contents [])

     (first.contents.push node)
     (context.parse-stack.unshift node)
     context)

(def accept-specials (node context)
     (set node 'specials (get context 'specials))
     (set context 'specials 0)
     context)

(def accept-ignored-tokens (node context)
     (set node 'preceding-ignored context.ignored-tokens)
     (set context 'ignored-tokens [])
     context)

(def close-specials (node context)
     (when (> node.specials 0)
           (decr node.specials)
           (context.parse-stack.shift)
           (close-specials node context))
     context)


(def accumulate-ignored-token (token context index)
     (context.ignored-tokens.push token)
     context)

(each special `[ hat dots tick at ]
      (set restructurers special open-special))

(each ignored `[ whitespace newline ignored comment ]
      (set restructurers ignored accumulate-ignored-token))

(def restructurers.default (token context index)
     (accept-specials token context)
     (accept-ignored-tokens token context)
     (pipe context
           (get 'parse-stack)
           (first)
           (get 'contents)
           (.push token))
     (close-specials token context))
