(var sibilant exports
     util     (require 'util)
     path     (require 'path)
     fs       (require 'fs)
     error    (#(str) (throw str))
     inspect  util.inspect)


(include "../include/functional")
(include "./parser")
(include "./restructurer")

(def recurse-indent (...args)
     (map (compact args)
          (#(arg)
            (if (list? arg) (apply recurse-indent arg)
                (number? arg) (arg.to-string)
                (string? arg)
                (chain arg
                       (replace (regex "\\n" 'g) "\n  ")
                       (replace (regex "\\n\\s+\\n" 'g) "\n\n"))

                 arg))))

(def indent (...args)
     ["\n  " (apply recurse-indent args) "\n"])

(def ast (input parent) (restructure (parse input) parent))
(include "./macros")
(include "./transpiler")
(include "./pretty-printer")
(include "./output-formatter")

(def sibilant.initialize ()
     (unless sibilant.macros.*loaded?
             (set sibilant.macros '*loaded? true)
             (sibilant.include (path.normalize (concat **dirname "/../include/macros")))))

(def sibilize (input)
     (sibilant.initialize)
     (output-formatter (transpile (restructure (parse input)))))

(set sibilant 'sibilize sibilize)

(def sibilant.version ()
     (get (sibilant.package-info) 'version))

(def sibilant.package-info ()
     (var fs (require 'fs))
     (JSON.parse (fs.read-file-sync
                  (concat **dirname "/../package.json"))))

(def sibilant.version-string ()
     (var package (sibilant.package-info)
          path (require 'path))
     (concat package.name " version " package.version
             "\n(at " (path.join **dirname "..") ")"))

(def sibilant.strip-shebang (data)
     (data.replace (regex "^#!.*\\n") "\n"))

(set sibilant
     'file 'eval.sibilant
     'dir  (process.cwd))

(set require.extensions ".sibilant"
     (#(module filename)
       (var content (sibilant.sibilize-file filename))
       (module.*compile content filename)))

(set require.extensions ".son"
     (#(module filename)
       (var content (sibilant.sibilize-json filename))
       (set module 'exports (JSON.parse content))))


(def sibilant.include (file)
     (when (not (file.match (regex "\\.sibilant$")))
           (assign file (concat file ".sibilant")))

     (when (file.match (regex "^\\.\\.?/"))
           (assign file (concat sibilant.dir "/" file)))

     (var resolved-file
          (try (require.resolve file)
               (error ("Failed to resolve file for inclusion: " file))))

     (sibilant.sibilize-file resolved-file))

(def with-dir-and-file (dir file fn)
     (var before { dir sibilant.dir
                   file sibilant.file })
     (set sibilant
          'dir  dir
          'file file)

     (var retval (fn))

     (set sibilant
          'dir  before.dir
          'file before.file)

     retval)

(def sibilant.sibilize-file (file-name)
     (with-dir-and-file (path.dirname file-name) file-name
                        (#> (sibilize
                             (sibilant.strip-shebang
                              (fs.read-file-sync file-name "utf8"))))))


(def sibilant.sibilize-json (file-name)
     (sibilant.initialize)
     (var before sibilant.macros.hash.quote-keys)
     (set sibilant.macros.hash 'quote-keys true)
     (var content (sibilant.sibilize-file file-name))
     (set sibilant.macros.hash 'quote-keys before)
     content)

(def sibilant.macros.include (file)
     (sibilant.include (eval (transpile file))))

