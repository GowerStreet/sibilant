(var sibilant exports
     util     (require 'util)
     path     (require 'path)
     fs       (require 'fs)
     error    (#(str) (throw str))
     inspect  util.inspect)

(include "./pretty-printer")
(include "./output-formatter")
(include "./sourcemap")

(include "../include/functional")
(include "./parser")
(include "./restructurer")

(def ast (input parent) (restructure (parse input) parent))
(include "./macros")
(include "./transpiler")

(def sibilant.initialize ()
     (unless sibilant.macros.*loaded?
             (set sibilant.macros '*loaded? true)
             (sibilant.include (path.normalize (concat **dirname "/../include/macros")))))

(def sibilize (input)
     (sibilant.initialize)
     (output-formatter (transpile (restructure (parse input)))))

(def sourcemap (input)
     (sibilant.initialize)
     (sourcemapper (transpile (restructure (parse input)))))

     

(set sibilant 'sibilize sibilize)

(def sibilant.version ()
     (get (sibilant.package-info) 'version))

(def sibilant.package-info ()
     (var fs (require 'fs))
     (JSON.parse (fs.read-file-sync
                  (concat **dirname "/../package.json"))))

(def sibilant.version-string ()
     (var package (sibilant.package-info)
          path (require 'path))
     (concat package.name " version " package.version
             "\n(at " (path.join **dirname "..") ")"))

(def sibilant.strip-shebang (data)
     (data.replace (regex "^#!.*\\n") "\n"))

(set sibilant
     'file 'eval.sibilant
     'dir  (process.cwd))

(set require.extensions ".sibilant"
     (#(module filename)
       (var content (sibilant.sibilize-file filename))
       (module.*compile content filename)))

(set require.extensions ".son"
     (#(module filename)
       (var content (sibilant.sibilize-json filename))
       (set module 'exports (JSON.parse content))))


(def sibilant.include (file)
     (when (not (file.match (regex "\\.sibilant$")))
           (assign file (concat file ".sibilant")))

     (when (file.match (regex "^\\.\\.?/"))
           (assign file (concat sibilant.dir "/" file)))

     (var resolved-file
          (try (require.resolve file)
               (error ("Failed to resolve file for inclusion: " file))))

     (sibilant.transpile-file resolved-file))

(def with-dir-and-file (dir file fn)
     (var before { dir sibilant.dir
                   file sibilant.file })
     (set sibilant
          'dir  dir
          'file file)

     (var retval (fn))

     (set sibilant
          'dir  before.dir
          'file before.file)

     retval)

(set sibilant 'source-cache {})

(def sibilant.sibilize-file (file-name)
     (output-formatter (sibilant.transpile-file file-name)))

(def sibilant.transpile-file (file-name)
     (with-dir-and-file (path.dirname file-name) file-name
                        (#>
                         (var source (sibilant.strip-shebang
                                      (fs.read-file-sync file-name "utf8")))

                         (set sibilant.source-cache file-name source)
                         (sibilant.initialize)
                         (transpile (restructure (parse source))))))


(def sibilant.sourcemap-file (file-name)
     (with-dir-and-file (path.dirname file-name) file-name
                        (#> (sourcemap
                             (sibilant.strip-shebang
                              (fs.read-file-sync file-name "utf8"))))))


(def sibilant.sibilize-json (file-name)
     (sibilant.initialize)
     (var before sibilant.macros.hash.quote-keys)
     (set sibilant.macros.hash 'quote-keys true)
     (var content (sibilant.sibilize-file file-name))
     (set sibilant.macros.hash 'quote-keys before)
     content)

(def sibilant.macros.include (file)
     (sibilant.include (eval (output-formatter (transpile file)))))

