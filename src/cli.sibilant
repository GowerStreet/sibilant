(send (require "source-map-support") install)
(meta "//# sourceMappingURL=./cli.map\n")

(var sibilant (require "../lib/sibilant.js")
     path     (require 'path)
     options  (require "../lib/options.js")
     fs       (require 'fs)
     mod      (require 'module))

(def run-in-sandbox (js input-path)
     (when (undefined? input-path)
           (assign input-path "."))
     (set require.main
          'module-cache {}
          'filename (fs.realpath-sync input-path)
          'paths (mod.*node-module-paths
                  (path.dirname
                   (fs.realpath-sync input-path))))
     (require.main.*compile js require.main.filename))


(var cli {
          v         'version
           h         'help
           unhandled 'help
           f         'file
           o         'output
           x         'execute
           e         'eval
           i         'input
           m         'sourcemap
           after-break false
           execute   false
           unlabeled 'file})

(def cli.version ()
     (console.log (sibilant.version-string)))

(def cli.repl (args) (require "../lib/repl"))

(def read-stdin (fn)
     (var stdin process.stdin
          data "")
     (stdin.resume)
     (stdin.set-encoding "utf8")
     (stdin.on 'data (#(chunk) (assign data (concat data chunk))))
     (stdin.on 'end (#> (fn data))))

(def cli.eval (args options)
     (set options 'execute true)
     (cli.input args options))

(def cli.input (args options)
     (def process (sibilant-code)
          (var js-code (sibilant.sibilize sibilant-code))
          (if options.execute
              (run-in-sandbox js-code)
              (console.log js-code)))
     (if (empty? args)
         (read-stdin process)
         (process (first args))))

(def cli.help (args options)
     (fs.read-file (concat **dirname "/../cli-help") { encoding 'utf8 }
                   (#(err data)
                     (when err (throw err))
                     (console.log data))))

(var cli-options (options cli)
     args (or cli-options.after-break []))

(args.unshift (second process.argv) "FILENAME")

(set process 'argv args 'ARGV args)

(when (empty? (keys cli-options)) (cli.repl))

(each (input-file) (or cli-options.file [])
      (var input-path (path.join (process.cwd) input-file)
           input-extname (path.extname input-path)
           input-basename (path.basename input-path input-extname)
           translated (if (= ".son" input-extname)
                          (sibilant.sibilize-json input-path)
                          (sibilant.sibilize-file input-path))
           output-dir (when cli-options.output
                            (or (first cli-options.output)
                                (path.dirname input-path)))
           map-dir (when cli-options.sourcemap 
                         (or (first cli-options.sourcemap)
                             output-dir))
           output-extname (if (= ".son" input-extname) ".json" ".js"))

      (if output-dir (do
                      (var output-path (concat (path.join output-dir input-basename)
                                               output-extname))

                      (fs.write-file output-path translated)
                      (when map-dir
                            (var map-path (concat (path.join map-dir input-basename) ".map"))
                            ;; yes, it's dumb that this reads the file twice
                            (fs.write-file map-path (sibilant.sourcemap-file input-path))))
          
          cli-options.execute (run-in-sandbox translated input-path)

          (console.log translated)))