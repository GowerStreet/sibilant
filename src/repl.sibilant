(|> "source-map-support" require .install)
(source-mapping-url "../maps/repl.map")

(require! sibilant: "./sibilant",
          'cardinal, 'util, 'vm)

(var input      (process.open-stdin)
     output     process.stdout
     readline   (|> 'readline require (.create-interface input output))
     context    undefined
     cmd-buffer "")

(def create-context ()
     (var context (vm.create-context))
     (set module 'filename (|> (process.cwd) (concat "/exec")))
     (set context
          '*sibilant sibilant
          'module  module
          'require require)
     (each-key key global (set context key (get global key)))
     context)

(assign context (create-context))

(def display-prompt ()
     (readline.set-prompt
      (concat (if (> cmd-buffer.length 10)
                  ("..." (cmd-buffer.slice -10))
                  (if (> cmd-buffer.length 0) cmd-buffer "sibilant"))
              "> "))
     (readline.prompt))

(def handle-line (cmd)
     (var js-line "")

     (try
      (do
       (assign cmd-buffer (concat cmd-buffer cmd)
               {js} (sibilant cmd-buffer))

       (var safe-js (if (= (first js) "{")
                        (pipe js
                              ((sibilant.resolve-macro 'scoped))
                              sibilant.transpile
                              sibilant.output-formatter)
                        js))

       (try
        (|> js cardinal.highlight console.log)
        (console.dir js))

       (var result (vm.run-in-context safe-js context "sibilant-repl"))
       (set readline.history 0 cmd-buffer)
       (when (defined? result)
             (output.write ("result: "
                            (util.inspect result { colors true }) "\n")))
       (set context "_" result)
       (assign cmd-buffer ""))
      (do
       (if (match-regex? e.message /unclosed node/)
           (do
            (assign cmd-buffer (concat cmd-buffer " "))
            (readline.history.shift))
           (do
            (set readline.history 0 cmd-buffer)
            (output.write (concat e.stack "\n"))
            (assign  cmd-buffer "")))))
     (display-prompt))

(readline.on 'line handle-line)

(readline.on 'close (#>
                     (output.write "\nexiting")
                     (input.destroy)))

(display-prompt)
