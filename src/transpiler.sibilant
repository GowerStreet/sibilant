(def node? (thing ...types)
     (and
      (exists? thing)
      (= 'object (typeof thing))
      (string? thing.type)
      (or (empty? types) (includes? types thing.type))
      (has-key? thing 'contents)))

(def empty-node? (item)
     (if (node? item) (empty-node? item.contents)
         (list? item) (all? item empty-node?)
         (string? item) (item.match (regex "^\\s*$"))
         (or (= null item)
             (undefined? item)
             (= false item))))

(def compact-node (item)
     (if (node? item) (do
                       (set item 'contents (compact-node item.contents))
                       (if (and item.contents item.contents.length) item null))
         (list? item) (do
                       (var compacted (compact (map item compact-node)))
                       (if (and compacted compacted.length) compacted null))
         (if (or (= item "") (= item false)) null item)))

(def recurse-transpile (node)
     (if (list? node)
         (map node recurse-transpile)

         (node? node 'output)
         (merge-into node { contents: (recurse-transpile node.contents) })

         (node? node)
         (transpile node)

         node))

(def transpile (node preprocessor)
     (if
      (string? node)
      (assign node { type 'js token node contents []})

      (number? node)
      (assign node { type 'number token (node.to-string) contents []}))
     
     (if (list? node) node
         (exists? node) (do
                         (var transpiler (or (get transpile node.type) transpile.default)
                              result (transpiler node)
                              result-node (recurse-transpile (if (node? result) result
                                                                 { contents result
                                                                   type 'output })))
                         (set result-node
                              'contents (compact (flatten result-node.contents))
                              'source node)

                         (when sibilant.debug
                               (console.log (prettify node)
                                            (red "->")
                                            (prettify result-node)))

                         (set node 'transpiled result-node)

                         (if (empty-node? result-node) undefined
                             result-node))))


(set sibilant 'transpile transpile)

(var reader-macros {})

(def transpile.hat (node)
     (var token (get (first node.contents) 'token)
          [ namespace macro ] (if (match-regex? token "\/")
                                  (token.split "/")
                                  [ (first sibilant.macros.search-path) token ]))

     (sibilant.macros.namespaces.core.get.call node
                                               'sibilant.macros.namespaces
                                               (^quote (transpile.literal {token namespace}))
                                               (^quote (transpile.literal {token macro}))))

(def transpile.tick (node)
     (sibilant.macros.namespaces.core.quote.apply node node.contents))

(def transpile.at (node)
     (transpile (first node.contents)))

(def transpile.dots (node)
     (sibilant.macros.namespaces.core.dots.apply node node.contents))

(def transpile.default (node)
     node.token)

(def transpile.output (node)
     node)

(def transpile.number (node)
     (pipe (regex "," 'g)
           (node.token.replace "")
           (parse-float)
           (.to-string)))

(def transpile.root (node)
     (if (= 1 node.contents.length)
         (transpile (first node.contents))
         (pipe node.contents
               (map as-statement)
               (compact)
               (interleave "\n"))))


(def transpile.expression (node preprocessor)
     (if node.contents.length
         (do
          (var head (first node.contents)
               args node.contents
               macro (sibilant.resolve-macro 'call))

          (if (node? head 'string)
              (assign macro (sibilant.resolve-macro 'concat))

              (node? head 'dots)
              (assign macro (sibilant.resolve-macro 'send)
                      args [ (second node.contents) (first head.contents) ...(.slice node.contents 2) ])

              (node? head 'literal 'other-char)
              (do
               (var resolved-macro (sibilant.resolve-macro (output-formatter (transpile head))))
               (when resolved-macro
                     (set head 'hint 'macro)
                     (assign macro resolved-macro
                             args (rest node.contents)))))

          (macro.apply node args))

         "null"))

(def transpile.bracket (node)
     (apply sibilant.macros.namespaces.core.list node.contents))

(def transpile.brace (node) (apply sibilant.macros.namespaces.core.hash node.contents))

(def transpile.literal (node)
     (var string node.token)
     (inject (chain string
                    (replace (regex "\\*" 'g) "_")
                    (replace (regex "\\?$") "__QUERY")
                    (replace (regex "!$") "__BANG"))
             (string.match (regex "-(.)" 'g))
             (#(return-string match)
               (return-string.replace match
                                      (.to-upper-case (second match))))))

(def transpile.string (node)
     (chain node.token
            (split "\n")
            (join "\\n\" +\n\"")))

(def transpile.comment (node) null)

