(macro join (glue arr)
       ["(" (transpile arr) ").join(" (transpile glue) ")"])

(macro set (arr ...kv-pairs)
       (interleave "\n" (bulk-map kv-pairs
                                  (#(k v)
                                    (as-statement ["(" (transpile arr) ")"
                                                    "[" (transpile k) "] = " (transpile v) ])))))

(macro get (obj ...keys)
       ["(" (transpile obj) ")" (map keys (#(key) ["[" (transpile key) "]"]))])

(macro var (...pairs)
       (as-statement
        ["var "
         (interleave ",\n    "
               (bulk-map pairs
                         (#(name value)
                           [ (transpile name) " = " (transpile value) ])))
         ]))

(macro alias-macro (current-macro-name desired-macro-name)
       (var current-macro-name (output-formatter (transpile current-macro-name))
            desired-macro-name (output-formatter (transpile desired-macro-name)))
       (set macros desired-macro-name (get macros current-macro-name))
       null)

(macro send (object method ...args)
       [(transpile object) "." (transpile method)
               "(" (interleave ", " (map args transpile)) ")"])

(macro apply (fn arglist)
       (macros.send fn 'apply 'this arglist))

(macro cons (first rest)
       ["[ " (transpile first) " ].concat(" (transpile rest) ")"])

(macro append (list ...additional)
       (macros.send list 'concat (apply macros.list additional)))


(macro length (arr)
       (macros.get arr "\"length\""))

(macro ternary (cond if-true if-false)
       ["(" (transpile cond) ") ? "
            (transpile if-true) " : "
            (transpile if-false)])

(macro first (arr) (macros.get arr 0))
(macro second (arr) (macros.get arr 1))
(macro third (arr) (macros.get arr 2))
(macro fourth (arr) (macros.get arr 3))
(macro fifth (arr) (macros.get arr 4))
(macro sixth (arr) (macros.get arr 5))
(macro seventh (arr) (macros.get arr 6))
(macro eighth (arr) (macros.get arr 7))
(macro ninth (arr) (macros.get arr 8))

(macro rest (arr)
       (macros.send arr 'slice 1))

(macro last (arr)
       (macros.get (macros.send arr 'slice -1) 0))

(macro = (a b) [ (transpile a) " === " (transpile b) ])
(macro +   (...args)
       ["(" (interleave " + " (map args transpile)) ")"])
(macro -   (...args)
       ["(" (interleave " - " (map args transpile)) ")"])
(macro *   (...args)
       ["(" (interleave " * " (map args transpile)) ")"])
(macro /   (...args)
           ["(" (interleave " / " (map args transpile)) ")"])
(macro or  (...args)
       ["(" (interleave " || " (map args transpile)) ")"])

(macro and (...args)
       (ternary (= 1 (length args)) (transpile (first args))
                ["(" (interleave " && " (map args transpile)) ")"]))

(macro mod (...args)
       ["(" (interleave " % " (map args transpile)) ")"])

(macro infix-comparator (comparator args)
       ["(" (interleave " && "
                  (map (args.slice 0 -1)
                       (#(item index)
                         [ item " " comparator " " (get args (+ 1 index))])))
            ")"])

(macro >  (...args) (macros.infix-comparator  ">"  (map args transpile)))
(macro <  (...args) (macros.infix-comparator  "<"  (map args transpile)))
(macro <= (...args) (macros.infix-comparator "<="  (map args transpile)))
(macro >= (...args) (macros.infix-comparator ">="  (map args transpile)))
(macro != (...args) (macros.infix-comparator "!==" (map args transpile)))

(macro pow (base exponent)
       (macros.call "Math.pow" base exponent))

(macro incr-by (item increment)
       [ (transpile item) " += " (transpile increment)])

(macro incr (item)
       ["((" (transpile item) ")++)"])

(macro decr (item)
       ["((" (transpile item) ")--)"])

(macro new (...args)
       ["(new " (apply macros.call args) ")"])

(macro regex (string glim)
       (call (get macros 'new) 'RegExp string (or glim 'undefined)))

(macro timestamp ()
       ["\"" (send (new Date) to-string) "\""])

(macro comment (...contents)
       (map contents (#(content)
                       ["// "(recurse-map (transpile content)
                                    (#(item)
                                      (ternary item
                                               (send (output-formatter (transpile item)) replace
                                                     (regex "\n" 'g) "\n// ")
                                               null)))])))

(macro meta (body)
       (eval (output-formatter (transpile body))))

(macro zero? (item)
       ((get macros "=") (transpile item) 0))

(macro empty? (arr)
       ["((" (transpile arr) ").length === 0)"])

(macro odd? (number)
       ((get macros "!=") 0
        (macros.mod (transpile number) 2)))

(macro even? (number)
       ((get macros "=") 0
        (macros.mod (transpile number) 2)))


(macro typeof (thing) ["typeof " (transpile thing)])

(macro function? (...things)
       (apply macros.and (map things (#(thing)
                                 ((get macros "=") (macros.typeof thing) "'function'")))))


(macro undefined? (...things)
       (apply macros.and (map things (#(thing)
                                 ((get macros "=") (macros.typeof thing) "'undefined'")))))
(macro defined? (...things)
       (apply macros.and (map things (#(thing)
                                 ((get macros "!=") (macros.typeof thing) "'undefined'")))))

(macro number? (...things)
       (apply macros.and (map things (#(thing)
                                 ((get macros "=") (macros.typeof thing) "'number'")))))

(macro if (arg truebody falsebody)
       ["(function() {"
        (indent ["if (" (transpile arg) ") {"
                        (indent (macros.do truebody))
                        "} else {"
                        (indent (macros.do falsebody))
                        "}"])
         "})()"])

(macro = (first-thing ...other-things)
       (var transpiled-first-thing (transpile first-thing))
       ["(" (interleave " &&\n "
                  (map other-things
                       (#(thing)
                         [ transpiled-first-thing
                                 " === "
                                 (transpile thing) ])))
            ")"])


(macro string? (thing)
       ["typeof(" (transpile thing) ") === \"string\""])

(macro list? (thing)
       (var transpiled (transpile thing))
       ["((" transpiled ") && typeof (" transpiled ") === \"object\" && ("
               transpiled ").constructor.name === \"Array\")"])


(macro when (arg ...body)
       ["(function() {"
        (indent ["if (" (transpile arg) ") {"
                        (indent (apply macros.do body))
                        "}"])
        "})()"])


(macro not (exp)
       ["(!" (transpile exp) ")"])

(macro unless (arg ...body)
       ["(function() {"
        (indent ["if (" (macros.not arg) ") {"
                        (indent (apply macros.do body))
                        "}"])
        "})()"])


(macro slice (arr start end)
       (macros.send (transpile arr) "slice" (transpile start) (transpile end)))

(macro inspect (...args)
       (interleave " + \"\\n\" + "
             (map args
                  (#(arg)
                    ["\"" arg ":\" + " (transpile arg)]))))

(macro each (item array ...body)
       (var this-node this)
       (macros.send array 'for-each
              (macros.lambda {args item body body node this-node})))

(macro setf (...args)
       (interleave "\n"
             (bulk-map args (#(name value)
                              (as-statement [ (transpile name) " = "
                                                    (transpile value)])))))
(alias-macro setf assign)




(macro macro-list ()
       ["[" (indent (interleave ",\n"
                          (map (Object.keys macros) macros.quote)))
            "]"])

(macro macroexpand (name)
       (var macro (get macros (transpile name)))
       (if macro
           ("// macro: " name "\n" (macro.to-string))
           "undefined"))


(macro throw (...string)
       ["throw new Error (" (interleave " " (map string transpile)) ")"])

(macro as-boolean (expr)
       ["(!!(" (transpile expr) "))"])

(macro try (tryblock catchblock)
       ["(function() {"
        (indent ["try {"
                 (indent (macros.do tryblock))
                 "} catch (e) {"
                 (indent (macros.do catchblock))
                 "}"])
        "})()"])


(macro while (condition ...block)
       (macros.scoped
        (macros.var '**return-value**)
        ["while (" (transpile condition) ") {"
                   (indent (macros.setf '**return-value**
                                  (apply macros.scoped block)))
        "}"]
        '**return-value**))

(macro until (condition ...block)
       (macros.scoped
        (macros.var '**return-value**)
        ["while (" (macros.not condition) ") {"
                   (indent (macros.setf '**return-value**
                                  (apply macros.scoped block)))
        "}"]
        '**return-value**))


(macro thunk (...body)
       (var node this)
       (macros.lambda {node node args [] body body }))
(alias-macro thunk #>)

(macro keys (obj)
       (macros.call "Object.keys" (transpile obj)))

(macro delete (...objects)
       (interleave "\n" (map objects (#(obj)
                                 (as-statement ["delete " (transpile obj)])))))

(macro delmacro (...macro-names)
       (each (macro-name) macro-names
             (delete (get macros (output-formatter (transpile macro-name)))))
       null)
(alias-macro delmacro delete-macro)


(macro rename-macro (current-macro-name desired-macro-name)
       (macros.alias-macro current-macro-name desired-macro-name)
       (macros.delmacro current-macro-name)
       null)

(macro arguments ()
       ["(Array.prototype.slice.apply(arguments))"])

(macro scoped (...body)
       (macros.call (apply macros.thunk body)))

(macro each-key (as obj ...body)
       ["(function() {"
        (indent
         ["for (var " (transpile as) " in " (transpile obj) ") "
           (as-statement (apply macros.scoped body))
           ])
        "})()"])

(macro match? (regexp string)
       (macros.send string 'match regexp))

(macro switch (obj ...cases)
       ["(function() {"
         (indent ["switch(" (transpile obj) ") {"
                   (map cases (#(case-def)
                                (var case-name-node (first case-def.contents)
                                     case-labels (if (or (node? case-name-node 'expression)
                                                         (node? case-name-node 'bracket))
                                                     case-name-node.contents
                                                     [case-name-node])
                                     case-string (interleave "\n" (map case-labels (#(c)
                                                                                     (if (= 'default c.token)
                                                                                         "default:"
                                                                                         ["case " (transpile c) ":"])))))
                                ["\n" case-string (indent (apply macros.do (rest case-def.contents)))]))
                   "}"])
         "})()"])

(macro if (...args)
       ["(function() {"
        (indent
         (interleave " else "
               (bulk-map args
                         (#(cond val)
                           (if (!= (typeof val) 'undefined)
                                 ["if (" (transpile cond) ") {"
                                   (indent (macros.do val))
                                   "}"]
                                 ["{" (indent (macros.do cond)) "}"])))))
        "})()"])

(macro chain (object ...calls)
       (if (= 0 calls.length) (transpile object)
           (= 1 calls.length) (apply macros.send (cons object (get (first calls) 'contents)))
           (do
            (var lines (map calls (#(call index)
                                    ["." (transpile (first call.contents))
                                         "(" (interleave ", " (map (rest call.contents) transpile)) ")"])))

            [ (transpile object)
              (first lines)
              "\n  "
              (recurse-indent
               (interleave "\n" (rest lines)))])))

(macro chainable (...names)
       ;; this is a mess, but it'll get better soon with quoting
       (each (name) names
             (macros.macro name (first (get (restructure (parse "(target ...calls)")) 'contents))
                     (first (get (restructure
                                  (parse ("(macros.chain (macros.call \""
                                          (output-formatter (transpile name)) "\" target) ...calls)"))) 'contents)))))

(macro let (args body)
       ["let ("
         (interleave ", " (bulk-map args
                   (#(k v)
                     [ (transpile k) " = " (transpile v) ])))
         (if (undefined? body) ");"
             [") {" (indent (transpile body)) "}"])])

(macro instance-of? (item type)
       ["(" (transpile item) " instanceof " (transpile type) ")"])

(macro slice (list begin end)
       ["Array.prototype.slice.call(" (transpile list)
                                      ", " (or (transpile begin) 0)
                                      (if (defined? end) (", " (transpile end) ")") ")")])

(macro includes? (list item)
       (call (get macros "!=") -1 (macros.send list 'index-of item)))

(macro excludes? (list item)
       (call (get macros "=") -1 (macros.send list 'index-of item)))

(macro exists? (thing)
       (call (get macros "and")
             (macros.defined? thing)
             (call (get macros "!=") thing 'null)))

(macro state (...pairs)
       (set macros.state 'data (or macros.state.data {}))

       (if (= 1 (length pairs))
           (get macros.state.data (output-formatter (transpile (first pairs))))
           (do (bulk-map pairs (#(k v) (set macros.state.data (output-formatter (transpile k)) (eval (output-formatter (transpile v))))))
               null)))

(macro with-state (k v ...body)
       (var before (macros.state k))
       (macros.state k v)
       (var return-value
            (interleave "\n" (map body transpile)))
       (macros.state k before)
       return-value)

(macro join (glue arr)
       (if (and (defined? glue) (undefined? arr))
           (assign arr glue glue undefined))
       ["(" (transpile arr) ").join(" (if glue (transpile glue) "\"\"") ")"])


(macro symbol ()
       (var symbol-count (or (macros.state 'symbol-count) 0)
            new-symbol-count (+ 1 symbol-count))
       (macros.state 'symbol-count new-symbol-count)
       ["$_symbol" new-symbol-count "_$"])

(macro var (...pairs)
       (var destructured [])
       (bulk-map pairs (#(lhs rhs)
                         (switch lhs.type
                                 ('bracket
                                  (var symbol (macros.symbol))
                                  (destructured.push [symbol (transpile rhs)])
                                  (each (item index) lhs.contents
                                        (destructured.push [(transpile item) (macros.get symbol index)]))
                                  (destructured.push [symbol 'undefined]))
                                 ('brace
                                  (var symbol (macros.symbol))
                                  (destructured.push [symbol (transpile rhs)])
                                  (each (item index) lhs.contents
                                        (var tr-item (transpile item))
                                        (destructured.push [tr-item (macros.get symbol ["\"" tr-item "\""])]))
                                  (destructured.push [symbol 'undefined]))

                                 (default
                                  (destructured.push [(transpile lhs)
                                                       (if rhs (transpile rhs) 'undefined)])))))

       (as-statement
        ["var " (interleave ",\n    "
           (map destructured
                (#(pair)
                  [(first pair) " = " (second pair)]
                  )))]))


