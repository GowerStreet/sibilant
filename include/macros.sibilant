(macro join (glue arr)
       ["(" (transpile arr) ").join(" (transpile glue) ")"])

(macro set (arr ...kv-pairs)
       (interleave "\n" (bulk-map kv-pairs
                                  (#(k v)
                                    (as-statement ["(" (transpile arr) ")"
                                                    "[" (transpile k) "] = " (transpile v) ])))))

(macro get (obj ...keys)
       ["(" (transpile obj) ")" (map keys (#(key) ["[" (transpile key) "]"]))])

(macro var (...pairs)
       (as-statement
        ["var "
         (interleave ",\n    "
               (bulk-map pairs
                         (#(name value)
                           [ (transpile name) " = " (transpile value) ])))
         ]))

(macro alias-macro (current-macro-name desired-macro-name)
       (var current-macro-name (output-formatter (transpile current-macro-name))
            desired-macro-name (output-formatter (transpile desired-macro-name)))
       (set macros desired-macro-name (get macros current-macro-name))
       null)

(macro send (object method ...args)
       [(transpile object) "." (transpile method)
               "(" (interleave ", " (map args transpile)) ")"])

(macro apply (fn arglist)
       (^send fn 'apply 'this arglist))

(macro list (...args)
       ["[ " (interleave ", " (map args transpile)) " ]"])

(macro cons (first rest)
       ["[ " (transpile first) " ].concat(" (transpile rest) ")"])

(macro append (list ...additional)
       (^send list 'concat (apply ^list additional)))


(macro length (arr)
       (^get arr "\"length\""))

(macro ternary (cond if-true if-false)
       ["(" (transpile cond) ") ? "
            (transpile if-true) " : "
            (transpile if-false)])

(macro first (arr) (^get arr 0))
(macro second (arr) (^get arr 1))
(macro third (arr) (^get arr 2))
(macro fourth (arr) (^get arr 3))
(macro fifth (arr) (^get arr 4))
(macro sixth (arr) (^get arr 5))
(macro seventh (arr) (^get arr 6))
(macro eighth (arr) (^get arr 7))
(macro ninth (arr) (^get arr 8))

(macro rest (arr)
       (^send arr 'slice 1))

(macro last (arr)
       (^get (^send arr 'slice -1) 0))

(macro = (a b) [ (transpile a) " === " (transpile b) ])
(macro +   (...args)
       ["(" (interleave " + " (map args transpile)) ")"])
(macro -   (...args)
       ["(" (interleave " - " (map args transpile)) ")"])
(macro *   (...args)
       ["(" (interleave " * " (map args transpile)) ")"])
(macro /   (...args)
           ["(" (interleave " / " (map args transpile)) ")"])
(macro or  (...args)
       ["(" (interleave " || " (map args transpile)) ")"])

(macro and (...args)
       (ternary (= 1 (length args)) (transpile (first args))
                ["(" (interleave " && " (map args transpile)) ")"]))

(macro mod (...args)
       ["(" (interleave " % " (map args transpile)) ")"])

(macro infix-comparator (comparator args)
       ["(" (interleave " && "
                  (map (args.slice 0 -1)
                       (#(item index)
                         [ item " " comparator " " (get args (+ 1 index))])))
            ")"])

(macro >  (...args) (^infix-comparator  ">"  (map args transpile)))
(macro <  (...args) (^infix-comparator  "<"  (map args transpile)))
(macro <= (...args) (^infix-comparator "<="  (map args transpile)))
(macro >= (...args) (^infix-comparator ">="  (map args transpile)))
(macro != (...args) (^infix-comparator "!==" (map args transpile)))

(macro pow (base exponent)
       (^call "Math.pow" base exponent))

(macro incr-by (item increment)
       [ (transpile item) " += " (transpile increment)])

(macro incr (item)
       ["((" (transpile item) ")++)"])

(macro decr (item)
       ["((" (transpile item) ")--)"])

(macro new (...args)
       ["(new " (apply ^call args) ")"])

(macro regex (string glim)
       (call (get macros 'new) 'RegExp string (or glim 'undefined)))

(macro timestamp ()
       ["\"" (send (new Date) to-string) "\""])

(macro comment (...contents)
       (map contents (#(content)
                       ["// "(recurse-map (transpile content)
                                    (#(item)
                                      (ternary item
                                               (send (output-formatter (transpile item)) replace
                                                     (regex "\n" 'g) "\n// ")
                                               null)))])))

(macro meta (body)
       (eval (output-formatter (transpile body))))

(macro zero? (item)
       ((get macros "=") (transpile item) 0))

(macro empty? (arr)
       ["((" (transpile arr) ").length === 0)"])

(macro odd? (number)
       ((get macros "!=") 0
        (^mod (transpile number) 2)))

(macro even? (number)
       ((get macros "=") 0
        (^mod (transpile number) 2)))


(macro typeof (thing) ["typeof " (transpile thing)])

(macro function? (...things)
       (apply ^and (map things (#(thing)
                                 ((get macros "=") (^typeof thing) "'function'")))))


(macro undefined? (...things)
       (apply ^and (map things (#(thing)
                                 ((get macros "=") (^typeof thing) "'undefined'")))))
(macro defined? (...things)
       (apply ^and (map things (#(thing)
                                 ((get macros "!=") (^typeof thing) "'undefined'")))))

(macro number? (...things)
       (apply ^and (map things (#(thing)
                                 ((get macros "=") (^typeof thing) "'number'")))))

(macro if (arg truebody falsebody)
       ["(function() {"
        (indent ["if (" (transpile arg) ") {"
                        (indent (^do truebody))
                        "} else {"
                        (indent (^do falsebody))
                        "}"])
         "})()"])

(macro = (first-thing ...other-things)
       (var transpiled-first-thing (transpile first-thing))
       ["(" (interleave " &&\n "
                  (map other-things
                       (#(thing)
                         [ transpiled-first-thing
                                 " === "
                                 (transpile thing) ])))
            ")"])


(macro string? (thing)
       ["typeof(" (transpile thing) ") === \"string\""])

(macro list? (thing)
       (var transpiled (transpile thing))
       ["((" transpiled ") && typeof (" transpiled ") === \"object\" && ("
               transpiled ").constructor.name === \"Array\")"])


(macro when (arg ...body)
       ["(function() {"
        (indent ["if (" (transpile arg) ") {"
                        (indent (apply ^do body))
                        "}"])
        "})()"])


(macro not (exp)
       ["(!" (transpile exp) ")"])

(macro unless (arg ...body)
       ["(function() {"
        (indent ["if (" (^not arg) ") {"
                        (indent (apply ^do body))
                        "}"])
        "})()"])


(macro slice (arr start end)
       (^send (transpile arr) "slice" (transpile start) (transpile end)))

(macro inspect (...args)
       (interleave " + \"\\n\" + "
             (map args
                  (#(arg)
                    ["\"" arg ":\" + " (transpile arg)]))))

(macro each (item array ...body)
       (var this-node this)
       (^send array 'for-each
              (^lambda {args item body body node this-node})))

(macro setf (...args)
       (interleave "\n"
             (bulk-map args (#(name value)
                              (as-statement [ (transpile name) " = "
                                                    (transpile value)])))))
(alias-macro setf assign)




(macro macro-list ()
       ["[" (indent (interleave ",\n"
                          (map (Object.keys macros) ^quote)))
            "]"])

(macro macroexpand (name)
       (var macro (get macros (transpile name)))
       (if macro
           ("// macro: " name "\n" (macro.to-string))
           "undefined"))


(macro throw (...string)
       ["throw new Error (" (interleave " " (map string transpile)) ")"])

(macro as-boolean (expr)
       ["(!!(" (transpile expr) "))"])

(macro try (tryblock catchblock)
       ["(function() {"
        (indent ["try {"
                 (indent (^do tryblock))
                 "} catch (e) {"
                 (indent (^do catchblock))
                 "}"])
        "})()"])


(macro while (condition ...block)
       (^scoped
        (^var '**return-value**)
        ["while (" (transpile condition) ") {"
                   (indent (^setf '**return-value**
                                  (apply ^scoped block)))
        "}"]
        '**return-value**))

(macro until (condition ...block)
       (^scoped
        (^var '**return-value**)
        ["while (" (^not condition) ") {"
                   (indent (^setf '**return-value**
                                  (apply ^scoped block)))
        "}"]
        '**return-value**))


(macro thunk (...body)
       (var node this)
       (^lambda {node node args [] body body }))
(alias-macro thunk #>)

(macro keys (obj)
       (^call "Object.keys" (transpile obj)))

(macro delete (...objects)
       (interleave "\n" (map objects (#(obj)
                                 (as-statement ["delete " (transpile obj)])))))

(macro delmacro (...macro-names)
       (each (macro-name) macro-names
             (delete (get macros (output-formatter (transpile macro-name)))))
       null)
(alias-macro delmacro delete-macro)


(macro rename-macro (current-macro-name desired-macro-name)
       (^alias-macro current-macro-name desired-macro-name)
       (^delmacro current-macro-name)
       null)

(macro arguments ()
       ["(Array.prototype.slice.apply(arguments))"])

(macro scoped (...body)
       (^call (apply ^thunk body)))

(macro each-key (as obj ...body)
       ["(function() {"
        (indent
         ["for (var " (transpile as) " in " (transpile obj) ") "
           (as-statement (apply ^scoped body))
           ])
        "})()"])

(macro match? (regexp string)
       (^send string 'match regexp))

(macro switch (obj ...cases)
       ["(function() {"
         (indent ["switch(" (transpile obj) ") {"
                   (map cases (#(case-def)
                                (var case-name-node (first case-def.contents))
                                (var contents case-name-node.contents)
                                (var case-labels (if contents.length contents [case-name-node]))
                                (var case-string (interleave "\n" (map case-labels (#(c)
                                                                                     (if (= 'default c.token)
                                                                                         "default:"
                                                                                         ["case " (transpile c) ":"])))))

                                ["\n" case-string (indent (apply ^do (rest case-def.contents)))]))
                   "}"])
         "})()"])

(macro if (...args)
       ["(function() {"
        (indent
         (interleave " else "
               (bulk-map args
                         (#(cond val)
                           (if (!= (typeof val) 'undefined)
                                 ["if (" (transpile cond) ") {"
                                   (indent (^do val))
                                   "}"]
                                 ["{" (indent (^do cond)) "}"])))))
        "})()"])

(macro chain (object ...calls)
       (if (= 0 calls.length) (transpile object)
           (= 1 calls.length) (apply ^send (cons object (get (first calls) 'contents)))
           (do
            (var lines (map calls (#(call index)
                                    ["." (transpile (first call.contents))
                                         "(" (interleave ", " (map (rest call.contents) transpile)) ")"])))

            [ (transpile object)
              (first lines)
              "\n  "
              (recurse-indent
               (interleave "\n" (rest lines)))])))

(macro chainable (...names)
       ;; this is a mess, but it'll get better soon with quoting
       (each (name) names
             (^macro name (first (get (restructure (parse "(target ...calls)")) 'contents))
                     (first (get (restructure
                                  (parse ("(^chain (^call \""
                                          (output-formatter (transpile name)) "\" target) ...calls)"))) 'contents)))))

(macro let (args body)
       ["let ("
         (interleave ", " (bulk-map args
                   (#(k v)
                     [ (transpile k) " = " (transpile v) ])))
         (if (undefined? body) ");"
             [") {" (indent (transpile body)) "}"])])

(macro instance-of? (item type)
       ["(" (transpile item) " instanceof " (transpile type) ")"])

(macro slice (list begin end)
       ["Array.prototype.slice.call(" (transpile list)
                                      ", " (or (transpile begin) 0)
                                      (if (defined? end) (", " (transpile end) ")") ")")])

(macro includes? (list item)
       (call (get macros "!=") -1 (^send list 'index-of item)))

(macro excludes? (list item)
       (call (get macros "=") -1 (^send list 'index-of item)))

(macro exists? (thing)
       (call (get macros "and")
             (^defined? thing)
             (call (get macros "!=") thing 'null)))

(macro state (...pairs)
       (set ^state 'data (or ^state.data {}))

       (if (= 1 (length pairs))
           (get ^state.data (output-formatter (transpile (first pairs))))
           (do (bulk-map pairs (#(k v) (set ^state.data (output-formatter (transpile k)) (eval (output-formatter (transpile v))))))
               null)))

(macro with-state (k v ...body)
       (var before (^state k))
       (^state k v)
       (var return-value
            (interleave "\n" (map body transpile)))
       (^state k before)
       return-value)

(macro join (glue arr)
       (if (and (defined? glue) (undefined? arr))
           (assign arr glue glue undefined))
       ["(" (transpile arr) ").join(" (if glue (transpile glue) "\"\"") ")"])


(macro symbol ()
       (var symbol-count (or (^state 'symbol-count) 0)
            new-symbol-count (+ 1 symbol-count))
       (^state 'symbol-count new-symbol-count)
       ["$_symbol" new-symbol-count "_$"])

(macro var (...pairs)
       (var destructured [])
       (bulk-map pairs (#(lhs rhs)
                         (switch lhs.type
                                 ('bracket
                                  (var symbol (^symbol))
                                  (destructured.push [symbol (transpile rhs)])
                                  (each (item index) lhs.contents
                                        (destructured.push [(transpile item) (^get symbol index)]))
                                  (destructured.push [symbol 'undefined]))
                                 ('brace
                                  (var symbol (^symbol))
                                  (destructured.push [symbol (transpile rhs)])
                                  (each (item index) lhs.contents
                                        (var tr-item (transpile item))
                                        (destructured.push [tr-item (^get symbol ["\"" tr-item "\""])]))
                                  (destructured.push [symbol 'undefined]))

                                 (default
                                  (destructured.push [(transpile lhs)
                                                       (if rhs (transpile rhs) 'undefined)])))))

       (as-statement
        ["var " (interleave ",\n    "
           (map destructured
                (#(pair)
                  [(first pair) " = " (second pair)]
                  )))]))

(macro list (...args)
       (var arg-segments [])
       (if (empty? args) "[]"
           (do
            (def simple-list (args)
                 ["[ " (interleave ", " (map args (#(arg) arg.transpiled))) " ]"])

            (args.for-each (#(arg)
                  (var dots (any? arg.modifiers (#(mod) (= "..." mod.token))))
                  (if dots (arg-segments.push {transpiled (transpile arg)})
                   (list? (last arg-segments)) (send (last arg-segments) push {transpiled (transpile arg)})
                   (arg-segments.push [{transpiled (transpile arg)}]))))

            (assign arg-segments (map arg-segments
                                      (#(segment)
                                        (if (list? segment)
                                            (simple-list segment)
                                            segment.transpiled))))

            (if (= 1 (length arg-segments))
                (first arg-segments)
                (apply ^send (cons (first arg-segments)
                                   (cons 'concat (rest arg-segments))))))))


(macro call (fn-name ...args)
       (var dots (detect args (#(arg) (detect arg.modifiers (#(mod) (= "..." mod.token))))))

       (if dots
           (^apply (transpile fn-name) (apply ^list args))
           [ (transpile fn-name)
                   "(" (interleave ", " (map args transpile)) ")" ]))

