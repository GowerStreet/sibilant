(namespace core)

(macro ternary (cond if-true if-false)
       ["(" (transpile cond) ") ? "
            (transpile if-true) " : "
            (transpile if-false)])

(macro join (glue arr)
       ["(" (transpile arr) ").join(" (transpile glue) ")"])

(macro set (arr ...kv-pairs)
       (interleave "\n" (bulk-map kv-pairs
                                  (#(k v)
                                    (as-statement ["(" (transpile arr) ")"
                                                    "[" (transpile k) "] = " (transpile v) ])))))

(macro var (...pairs)
       (as-statement
        ["var "
         (interleave ",\n    "
               (bulk-map pairs
                         (#(name value)
                           [ (transpile name) " = " (transpile value) ])))
         ]))

(macro get (obj ...keys)
       ["(" (transpile obj) ")" (map keys (#(key)
                                            ["[" (transpile key) "]"]))])

(macro alias-macro (current-macro-name desired-macro-name)
       (var current-macro-name (output-formatter (transpile current-macro-name))
            desired-macro-name (output-formatter (transpile desired-macro-name)))
       (set sibilant.macros.namespace
            desired-macro-name (get sibilant.macros.namespace current-macro-name))
       null)

(macro send (object method ...args)
       [(transpile object) "." (transpile method)
               "(" (interleave ", " (map args transpile)) ")"])

(macro apply (fn arglist)
       '(send @fn apply this @arglist))

(macro cons (first rest)
       ["[ " (transpile first) " ].concat(" (transpile rest) ")"])

(macro append (list ...additional)
       '(send @list concat (list ...@additional)))

(macro length (arr)
       '(get @arr 'length))

(macro first (arr) '(get @arr 0))
(macro second (arr) '(get @arr 1))
(macro third (arr) '(get @arr 2))
(macro fourth (arr) '(get @arr 3))
(macro fifth (arr) '(get @arr 4))
(macro sixth (arr) '(get @arr 5))
(macro seventh (arr) '(get @arr 6))
(macro eighth (arr) '(get @arr 7))
(macro ninth (arr) '(get @arr 8))
(macro rest (arr)
       '(send @arr slice 1))

(macro last (arr)
       '(first (send @arr slice -1)))


(macro = (a b) [ (transpile a) " === " (transpile b) ])
(macro +   (...args)
       ["(" (interleave " + " (map args transpile)) ")"])
(macro -   (...args)
       ["(" (interleave " - " (map args transpile)) ")"])
(macro *   (...args)
       ["(" (interleave " * " (map args transpile)) ")"])
(macro /   (...args)
           ["(" (interleave " / " (map args transpile)) ")"])
(macro or  (...args)
       ["(" (interleave " || " (map args transpile)) ")"])

(macro and (...args)
       (ternary (= 1 (length args)) (transpile (first args))
                ["(" (interleave " && " (map args transpile)) ")"]))

(macro mod (...args)
       ["(" (interleave " % " (map args transpile)) ")"])

(macro infix-comparator (comparator args)
       ["(" (interleave " && "
                  (map (args.slice 0 -1)
                       (#(item index)
                         [ item " " comparator " " (get args (+ 1 index))])))
            ")"])

(macro >  (...args) (^infix-comparator  ">"  (map args transpile)))
(macro <  (...args) (^infix-comparator  "<"  (map args transpile)))
(macro <= (...args) (^infix-comparator "<="  (map args transpile)))
(macro >= (...args) (^infix-comparator ">="  (map args transpile)))
(macro != (...args) (^infix-comparator "!==" (map args transpile)))

(macro pow (base exponent)
       '(Math.pow @base @exponent))

(macro incr-by (item increment)
       [ (transpile item) " += " (transpile increment)])

(macro incr (item)
       ["((" (transpile item) ")++)"])

(macro decr (item)
       ["((" (transpile item) ")--)"])

(macro new (...args)
       ["(new " '(call ...@args) ")"])

(macro regex (string glim)
       '(new RegExp @string @(or glim 'undefined)))

(macro timestamp ()
       ["\"" (send (new Date) to-string) "\""])

(macro comment (...contents)
       (map contents (#(content)
                       ["// "(recurse-map (transpile content)
                                    (#(item)
                                      (ternary item
                                               (send (output-formatter (transpile item)) replace
                                                     (regex "\n" 'g) "\n// ")
                                               null)))])))

(macro zero? (item) '(= @item 0))

(macro empty? (arr)
       ["((" (transpile arr) ").length === 0)"])

(macro odd? (number)
       '(= 1 (mod @number 2)))

(macro even? (number)
       '(= 0 (mod @number 2)))

(macro typeof (thing) ["typeof " (transpile thing)])


(macro function? (...things)
       '(and ...@(map things (#(thing) '(= (typeof @thing) 'function)))))
(macro undefined? (...things)
       '(and ...@(map things (#(thing) '(= (typeof @thing) 'undefined)))))
(macro defined? (...things)
       '(and ...@(map things (#(thing) '(!= (typeof @thing) 'undefined)))))
(macro number? (...things)
       '(and ...@(map things (#(thing) '(= (typeof @thing) 'number)))))

(macro if (arg truebody falsebody)
       ["(function() {"
        (indent ["if (" (transpile arg) ") {"
                        (indent '(do ...@truebody))
                        "} else {"
                        (indent '(do ...@falsebody))
                        "}"])
         "})()"])

(macro = (first-thing ...other-things)
       (var transpiled-first-thing (transpile first-thing))
       ["(" (interleave " &&\n "
                  (map other-things
                       (#(thing)
                         [ transpiled-first-thing
                                 " === "
                                 (transpile thing) ])))
            ")"])


(macro string? (thing)
       ["typeof(" (transpile thing) ") === \"string\""])

(macro list? (thing)
       (var transpiled (transpile thing))
       ["((" transpiled ") && typeof (" transpiled ") === \"object\" && ("
               transpiled ").constructor.name === \"Array\")"])


(macro when (arg ...body)
       ["(function() {"
        (indent ["if (" (transpile arg) ") {"
                        (indent '(do ...@body))
                        "}"])
        "})()"])


(macro not (exp)
       ["(!" (transpile exp) ")"])

(macro unless (arg ...body)
       ["(function() {"
        (indent ["if (" '(not @arg) ") {"
                        (indent '(do ...@body))
                        "}"])
        "})()"])


(macro slice (arr start end)
       '(send @arr slice @start @end))

(macro inspect (...args)
       (interleave " + \"\\n\" + "
             (map args
                  (#(arg)
                    ["\"" arg ":\" + " (transpile arg)]))))

(macro each (item array ...body)
       '(send @array for-each
              (lambda @{ node this args item } ...@body)))

(macro assign (...args)
       (interleave "\n"
             (bulk-map args (#(name value)
                              (as-statement [ (transpile name) " = "
                                                    (transpile value)])))))



(macro macro-expand (name)
       (var macro (get macros (output-formatter (transpile name))))
       (if macro
           (macro.to-string)
           "undefined"))

(macro throw (...string)
       ["throw new Error (" (interleave " " (map string transpile)) ")"])

(macro as-boolean (expr)
       ["(!!(" (transpile expr) "))"])

(macro try (tryblock catchblock)
       ["(function() {"
        (indent ["try {"
                 (indent '(do @tryblock))
                 "} catch (e) {"
                 (indent '(do @catchblock))
                 "}"])
         "})()"])

(macro log-pretty (label arg)
       (var node this)
       (when (undefined? arg)
             (assign arg label
                     label ["\"" (prettify label false) "\""]))
       `(console.log (concat @["\"" node.file ":" node.line "\""] " " @label " = " (prettify @arg))))
(alias-macro log-pretty pretty-log)


(macro state (...pairs)
       (if (= 1 (length pairs))
           (get sibilant.state (output-formatter (transpile (first pairs))))
           (do (bulk-map pairs (#(k v) (set sibilant.state (output-formatter (transpile k)) (eval (output-formatter (transpile v))))))
               null)))

(macro symbol ()
       (var symbol-count (or (get sibilant.state 'symbol-count) 0)
            new-symbol-count (+ 1 symbol-count))
       (^state 'symbol-count new-symbol-count)
       ["$_symbol" new-symbol-count "_$"])

(macro while (condition ...block)
       (var symbol (^symbol))
       '(scoped-without-source
         (var @symbol)
         @["while (" (transpile condition) ") {"
           (indent '(assign @symbol (scoped-without-source ...@block)))
            "}"]
         @symbol))

(macro until (condition ...block)
       '(while (not @condition) ...@block))

(macro match? (regexp string)
       '(send @string match @regexp))

(macro match-regex? (string regexp-string glim)
       '(match? (regex @regexp-string @glim) @string))

(macro replace (string regexp-string replacement)
       '(send @string replace
              (regex @regexp-string)
              @replacement))

(macro replace-all (string regexp-string replacement)
       '(send @string replace (regex @regexp-string 'g) @replacement))

(macro thunk (...body)
       '(lambda @{ node this args [] }
       ...@(map-node body
                 (#(node)
                   (if (node? node 'arg-placeholder)
                       '(argument @(replace node.token "^#" ""))
                       node)))))
(alias-macro thunk #>)

(macro keys (obj)
       '(Object.keys @obj))

(macro delete (...objects)
       (interleave "\n" (map objects (#(obj)
                                 (as-statement ["delete " (transpile obj)])))))

(macro delmacro (...macro-names)
       (each (macro-name) macro-names
             (delete (get sibilant.macros.namespace (output-formatter (transpile macro-name)))))
       null)
(alias-macro delmacro delete-macro)


(macro rename-macro (current-macro-name desired-macro-name)
       (^alias-macro current-macro-name desired-macro-name)
       (^delmacro current-macro-name)
       null)

(macro arguments ()
       ["(Array.prototype.slice.apply(arguments))"])

(macro argument (n)
       '(get arguments @n))

(macro scoped (...body)
       '(call (lambda @{node this args []} ...@body)))

(macro scoped-without-source (...body)
       ["(function() {" (indent '(do ...@body)) "})()"])
       

(macro each-key (as obj ...body)
       '(scoped-without-source
         @["for (var " (transpile as) " in " (transpile obj) ") "
            (as-statement '(scoped-without-source ...@body))
            ]
         @obj))

(macro switch (obj ...cases)
       ["(function() {"
         (indent ["switch(" (transpile obj) ") {"
                   (map cases (#(case-def)
                                (var case-name-node (first case-def.contents)
                                     case-labels (if (or (node? case-name-node 'expression)
                                                         (node? case-name-node 'bracket))
                                                     case-name-node.contents
                                                     [case-name-node])
                                     case-string (interleave "\n" (map case-labels (#(c)
                                                                                     (if (= 'default c.token)
                                                                                         "default:"
                                                                                         ["case " (transpile c) ":"])))))
                                ["\n" case-string (indent '(do ...@(rest case-def.contents)))]))
                   "}"])
         "})()"])

(macro if (...args)
       ["(function() {"
        (indent
         (interleave " else "
               (bulk-map args
                         (#(cond val)
                           (if (!= (typeof val) 'undefined)
                                 ["if (" (transpile cond) ") {"
                                   (indent '(do @val))
                                   "}"]
                                 ["{" (indent '(do @cond)) "}"])))))
        "})()"])

(macro chain (object ...calls)
       (if (= 0 calls.length) (transpile object)
           (= 1 calls.length) '(send @object ...@(get (first calls) 'contents))
           (do
            (var lines (map calls (#(call index)
                                    ["." (transpile (first call.contents))
                                         "(" (interleave ", " (map (rest call.contents) transpile)) ")"])))

            [ (transpile object)
              (first lines)
              "\n  "
              (recurse-indent
               (interleave "\n" (rest lines)))])))

(macro chainable (...names)
       (each (name) names
             '(macro @name (target ...calls)
                     '(chain (call @name @target) ...@calls))))

(macro let (args body)
       ["let ("
         (interleave ", " (bulk-map args
                   (#(k v)
                     [ (transpile k) " = " (transpile v) ])))
         (if (undefined? body) ");"
             [") {" (indent (transpile body)) "}"])])

(macro instance-of? (item type)
       ["(" (transpile item) " instanceof " (transpile type) ")"])

(macro slice (list begin end)
       ["Array.prototype.slice.call(" (transpile list)
                                      ", " (or (transpile begin) 0)
                                      (if (defined? end) (", " (transpile end) ")") ")")])

(macro includes? (list item)
       '(!= -1 (send @list index-of @item)))


(macro excludes? (list item)
       '(= -1 (send @list index-of @item)))

(macro exists? (thing)
       '(and (defined? @thing) (!= @thing null)))

(macro with-state (k v ...body)
       (var before (^state k))
       (^state k v)
       (var return-value
            (interleave "\n" (map body transpile)))
       (^state k before)
       return-value)

(macro join (glue arr)
       (if (and (defined? glue) (undefined? arr))
           (assign arr glue glue undefined))
       ["(" (transpile arr) ").join(" (if glue (transpile glue) "\"\"") ")"])

(macro var (...pairs)
       (var destructured [])
       (bulk-map pairs (#(lhs rhs)
                         (switch lhs.type
                                 ('bracket
                                  (var symbol (^symbol))
                                  (destructured.push [symbol (transpile rhs)])
                                  (each (item index) lhs.contents
                                        (destructured.push [(transpile item) '(get @symbol @index)]))
                                  (destructured.push [symbol 'undefined]))
                                 ('brace
                                  (var symbol (^symbol))
                                  (destructured.push [symbol (transpile rhs)])
                                  (each (item index) lhs.contents
                                        (var tr-item (transpile item))
                                        (destructured.push [tr-item '(get @symbol @["\"" tr-item "\""])]))
                                  (destructured.push [symbol 'undefined]))

                                 (default
                                  (destructured.push [(transpile lhs)
                                                       (if rhs (transpile rhs) 'undefined)])))))

       (as-statement
        ["var " (interleave ",\n    "
           (map destructured
                (#(pair)
                  [(first pair) " = " (second pair)]
                  )))]))

(macro default (...pairs)
       (interleave "\n" (bulk-map pairs (#(name value)
                                  '(assign @name (ternary (defined? @name) @name @value))))))


(macro import-namespace (namespace)
       (var namespace-as-string (output-formatter (transpile namespace)))
       (unless (sibilant.macros.namespaces.has-own-property namespace-as-string)
               (set sibilant.macros.namespaces namespace-as-string {}))
       (sibilant.macros.search-path.unshift namespace-as-string)
       undefined)

(macro namespace (namespace)
       `(import-namespace @namespace)
       (set sibilant.macros 'namespace (get sibilant.macros.namespaces (output-formatter (transpile namespace))))
       undefined)

(macro has-key? (object key)
       `(send @object has-own-property @key))

(macro get (obj ...keys)
       [(transpile obj)
         (map keys (#(key)
                     (var transpiled (transpile key)
                          output (output-formatter transpiled))

                     (if (match-regex? output "^\"[a-zA-Z0-9]+\"$")
                         ["." (replace-all output "\"" "") ]
                         ["[" transpiled "]"])))])

(macro set (arr ...kv-pairs)
       (interleave "\n" (bulk-map kv-pairs (#(k v) `(assign (get @arr @k) @v)))))


(macro pipe (...calls)
       (inject undefined calls
         (#(value item)
           (var cloned (clone item))
           (if (undefined? value)
               cloned
               (merge-into cloned
                           { contents [ (first cloned.contents)
                                        value
                                        ...(rest cloned.contents) ] })))))
