
(macro join (glue arr)
       ("(" (transpile arr) ").join(" (transpile glue) ")"))

(macro set (arr ...kv-pairs)
       (join "\n" (bulk-map kv-pairs
                            (#(k v)
                              ("(" (transpile arr) ")"
                                   "[" (transpile k) "] = " (transpile v) ";")))))

(macro get (obj ...keys)
       ("(" (transpile obj) ")"
            (join "" (map keys (#(key) ("[" (transpile key) "]"))))))

(macro var (...pairs)
       (as-statement
        ("var "
         (join ",\n    "
               (bulk-map pairs
                         (#(name value)
                           (concat (transpile name) " = "
                                   (transpile value)))))
         ";")))

(macro alias-macro (current-macro-name desired-macro-name)
       (var current-macro-name (transpile current-macro-name)
            desired-macro-name (transpile desired-macro-name))
       (set macros desired-macro-name (get macros current-macro-name))
       "")

(macro send (object method ...args)
       (concat (transpile object) "." (transpile method)
               "(" (join ", " (map args transpile)) ")"))

(macro apply (fn arglist)
       (^send fn 'apply 'undefined arglist))

(macro list (...args)
       ("[ " (join ", " (map args transpile)) " ]"))

(macro cons (first rest)
       (^send (^list first) 'concat rest))

(macro append (list ...additional)
       (^send list 'concat (apply ^list additional)))


(macro length (arr)
       (^get arr "\"length\""))

(macro ternary (cond if-true if-false)
       ("(" (transpile cond) ") ? "
            (transpile if-true) " : "
            (transpile if-false)))

(macro first (arr) (^get arr 0))
(macro second (arr) (^get arr 1))
(macro third (arr) (^get arr 2))
(macro fourth (arr) (^get arr 3))
(macro fifth (arr) (^get arr 4))
(macro sixth (arr) (^get arr 5))
(macro seventh (arr) (^get arr 6))
(macro eighth (arr) (^get arr 7))
(macro ninth (arr) (^get arr 8))

(macro rest (arr)
       (^send arr 'slice 1))

(macro last (arr)
       (^get (^send arr 'slice -1) 0))

(macro = (a b) (concat (transpile a) " === " (transpile b)))
(macro +   (...args)
       ("(" (join " + " (map args transpile)) ")"))
(macro -   (...args)
       ("(" (join " - " (map args transpile)) ")"))
(macro *   (...args)
       ("(" (join " * " (map args transpile)) ")"))
(macro /   (...args)
           ("(" (join " / " (map args transpile)) ")"))
(macro or  (...args)
       ("(" (join " || " (map args transpile)) ")"))

(macro and (...args)
       (ternary (= 1 (length args)) (transpile (first args))
                ("(" (join " && " (map args transpile)) ")")))

(macro mod (...args)
       ("(" (join " % " (map args transpile)) ")"))

(macro infix-comparator (comparator args)
       ("(" (join " && "
                  (map (args.slice 0 -1)
                       (#(item index)
                         (concat item
                                 " " comparator " "
                                 (get args (+ 1 index))))))
            ")"))

(macro >  (...args) (^infix-comparator  ">"  (map args transpile)))
(macro <  (...args) (^infix-comparator  "<"  (map args transpile)))
(macro <= (...args) (^infix-comparator "<="  (map args transpile)))
(macro >= (...args) (^infix-comparator ">="  (map args transpile)))
(macro != (...args) (^infix-comparator "!==" (map args transpile)))

(macro pow (base exponent)
       (^call "Math.pow" base exponent))

(macro incr-by (item increment)
       (concat (transpile item) " += " (transpile increment)))

(macro incr (item)
       ("((" (transpile item) ")++)"))

(macro decr (item)
       ("((" (transpile item) ")--)"))

(macro new (...args)
       ("(new " (apply ^call args) ")"))

(macro regex (string glim)
       (call (get macros 'new) 'RegExp string (or glim 'undefined)))

(macro timestamp ()
       ("\"" (send (new Date) to-string) "\""))

(macro comment (...contents)
       (map contents
            (#(item)
              (join "\n" (map (send (transpile item) split "\n")
                              (#(line) ("// " line)))))))

(macro meta (body)
       (send (eval (transpile body)) to-string))

(macro zero? (item)
       ((get macros "=") (transpile item) 0))

(macro empty? (arr)
       ("((" (transpile arr) ").length === 0)"))

(macro odd? (number)
       ((get macros "!=") 0
        (^mod (transpile number) 2)))

(macro even? (number)
       ((get macros "=") 0
        (^mod (transpile number) 2)))


(macro typeof (thing) (+ "typeof " (transpile thing)))

(macro function? (...things)
       (apply ^and (map things (#(thing)
                                 ((get macros "=") (^typeof thing) "'function'")))))

(macro undefined? (...things)
       (apply ^and (map things (#(thing)
                                 ((get macros "=") (^typeof thing) "'undefined'")))))

(macro defined? (...things)
       (apply ^and (map things (#(thing)
                                 ((get macros "!=") (^typeof thing) "'undefined'")))))

(macro number? (...things)
       (apply ^and (map things (#(thing)
                                 ((get macros "=") (^typeof thing) "'number'")))))

(macro if (arg truebody falsebody)
       ("(function() {"
        (indent ("if (" (transpile arg) ") {"
                        (indent (^do truebody))
                        "} else {"
                        (indent (^do falsebody))
                        "}"))
        "})()"))

(macro = (first-thing ...other-things)
       (var transpiled-first-thing (transpile first-thing))
       ("(" (join " &&\n "
                  (map other-things
                       (#(thing)
                         (concat transpiled-first-thing
                                 " === "
                                 (transpile thing)))))
            ")"))


(macro string? (thing)
       ("typeof(" (transpile thing) ") === \"string\""))

(macro list? (thing)
       (var transpiled (transpile thing))
       ("((" transpiled ") && typeof (" transpiled ") === \"object\" && ("
               transpiled ").constructor.name === \"Array\")"))


(macro when (arg ...body)
       ("(function() {"
        (indent ("if (" (transpile arg) ") {"
                        (indent (apply ^do body))
                        "}"))
        "})()"))

(macro unless (condition ...body)
       (apply ^when (cons ['not condition] body)))

(macro not (exp)
       ("(!" (transpile exp) ")"))

(macro slice (arr start end)
       (^send (transpile arr) "slice" start end))

(macro inspect (...args)
       (join " + \"\\n\" + "
             (map args
                  (#(arg)
                    ("\"" arg ":\" + " (transpile arg))))))

(macro each (item array ...body)
       (^send (transpile array) 'for-each
              (apply ^lambda (cons item body))))

(macro setf (...args)
       (join "\n"
             (bulk-map args (#(name value)
                              (as-statement (concat (transpile name) " = "
                                                    (transpile value)))))))
(alias-macro setf assign)




(macro macro-list ()
       ("[" (indent (join ",\n"
                          (map (Object.keys macros) ^quote)))
            "]"))

(macro macroexpand (name)
       (var macro (get macros (transpile name)))
       (if macro
           ("// macro: " name "\n" (macro.to-string))
           "undefined"))


(macroexpand each)

(macro throw (...string)
       ("throw new Error (" (join " " (map string transpile)) ")"))

(macro as-boolean (expr)
       ("(!!(" (transpile expr) "))"))


;; (macro chainable (...names)
;;        (each (name) names
;;              (^macro name ['target "..." 'calls]
;;                      ['apply 'macros.chain ['cons ['macros.call ['quote name] 'target] 'calls]])))

(macro try (tryblock catchblock)
       ("(function() {"
        (indent ("try {"
                 (indent (^do tryblock))
                 "} catch (e) {"
                 (indent (^do catchblock))
                 "}"))
        "})()"))


(macro while (condition ...block)
       (^scoped
        (^var '**return-value**)
        ("while (" (transpile condition) ") {"
                   (indent (^setf '**return-value**
                                  (apply ^scoped block))))
        "}"
        '**return-value**))

(macro until (condition ...block)
       (apply (get macros 'while)
              (cons ['not condition] block)))


(macro thunk (...body)
       (apply ^lambda (cons [] body)))
(alias-macro thunk #>)

(macro keys (obj)
       (^call "Object.keys" (transpile obj)))

(macro delete (...objects)
       (join "\n" (map objects (#(obj)
                                 ("delete " (transpile obj) ";")))))

(macro delmacro (macro-name)
       (delete (get macros (transpile macro-name)))
       "")
(alias-macro delmacro delete-macro)


(macro rename-macro (current-macro-name desired-macro-name)
       (^alias-macro current-macro-name desired-macro-name)
       (^delmacro current-macro-name)
       "")

(macro arguments ()
       "(Array.prototype.slice.apply(arguments))")

(macro scoped (...body)
       (^call (apply ^thunk body)))

(macro each-key (as obj ...body)
       ("(function() {"
        (indent
         ("for (var " (transpile as) " in " (transpile obj) ") "
                      (apply ^scoped body)
                      ";"))
        "})();"))

(macro match? (regexp string)
       (^send string 'match regexp))

(macro switch (obj ...cases)

       ;; the complexity of this macro indicates there's a problem
       ;; I'm not quite sure where to fix this, but it has to do with quoting.
       (var lines [("switch(" (transpile obj) ") {")])
       (each (case-def) cases
             (var case-name-node (first case-def.contents))
             (var contents case-name-node.contents)
             (var case-labels (if contents.length contents [case-name-node]))
             (var case-string (join "\n" (map case-labels (#(c)
                                                            (if (= 'default c.token)
                                                                "default:"
                                                                ("case " (transpile c) ":"))))))

             (lines.push (concat case-string
                                 (indent (apply ^do (rest case-def.contents))))))

       ;; the following two lines are to get the whitespace right
       ;; this is necessary because switches are indented weird
       ;; (set lines (- lines.length 1)
       ;;      (chain (get lines (- lines.length 1))
       ;;             (concat "}")))

       ("(function() {" (apply indent lines) "  }\n})()"))

(macro if (...args)
       ("(function() {"
        (indent
         (join " else "
               (bulk-map args
                         (#(cond val)
                           (if (undefined? val)
                               ("{" (indent (^do cond)) "}")
                               ("if (" (transpile cond) ") {"
                                       (indent (^do val))
                                       "}"))))))
        "})()"))


(macro chain (object ...calls)
       (if (= 0 calls.length) (transpile object)
           (= 1 calls.length) (apply ^send (cons object (get (first calls) 'contents)))
           (do
            (var lines (map calls (#(call index)
                                    ("." (transpile (first call.contents))
                                         "(" (join ", " (map (rest call.contents) transpile)) ")"))))

            (concat (transpile object)
                    (first lines)
                    (indent (join "\n" (rest lines)))))))

(macro let (args body)
       ("let (" (bulk-map args
                          (#(h k v)
                            (concat (transpile k) " = " (transpile v))))
                (if (undefined? body) ");"
                    (") {" (indent (transpile body)) "}"))))

(macro instance-of? (item type)
       ("(" (transpile item) " instanceof " (transpile type) ")"))

(macro slice (list begin end)
       ("Array.prototype.slice.call(" (transpile list)
                                      ", " (or (transpile begin) 0)
                                      (if (defined? end) (", " (transpile end) ")") ")")))

(macro includes? (list item)
       (call (get macros "!=") -1 (^send list 'index-of item)))

(macro excludes? (list item)
       (call (get macros "=") -1 (^send list 'index-of item)))

(macro exists? (thing)
       (call (get macros "and")
             (^defined? thing)
             (call (get macros "!=") thing 'null)))

(macro cascade (...commands)
       (transpile (inject []
                          (commands.reverse)
                          (#(output cmd)
                            (if (empty? output) [cmd]
                                [cmd ['thunk output]])))))

(macro state (...pairs)
       (if (undefined? ^state.data)
               (set ^state 'data {}))

       (if (= 1 (length pairs))
           (get ^state.data (transpile (first pairs)))
           (do (bulk-map pairs (#(k v) (set ^state.data (transpile k) (eval (transpile v)))))
               "")))

(macro with-state (k v ...body)
       (var before (^state k))
       (^state k v)
       (var return-value
            (join "\n" (map body transpile)))
       (^state k before)
       return-value)

(macro join (glue arr)
       (if (and (defined? glue) (undefined? arr))
           (assign arr glue glue undefined))
       ("(" (transpile arr) ").join(" (if glue (transpile glue) "\"\"") ")"))


(macro symbol ()
       (var symbol-count (or (^state 'symbol-count) 0)
            new-symbol-count (+ 1 symbol-count))
       (^state 'symbol-count new-symbol-count)
       ("$_symbol" new-symbol-count "_$"))

(macro var (...pairs)
       (var destructured [])
       (bulk-map pairs (#(lhs rhs)
                         (switch lhs.type
                                 ('bracket
                                  (var symbol (^symbol))
                                  (destructured.push [symbol (transpile rhs)])
                                  (each (item index) lhs.contents
                                        (destructured.push [(transpile item) (^get symbol index)]))
                                  (destructured.push [symbol 'undefined]))
                                 ('brace
                                  (var symbol (^symbol))
                                  (destructured.push [symbol (transpile rhs)])
                                  (each (item index) lhs.contents
                                        (var tr-item (transpile item))
                                        (destructured.push [tr-item (^get symbol ("\"" tr-item "\""))]))
                                  (destructured.push [symbol 'undefined]))

                                 (default
                                  (destructured.push [(transpile lhs)
                                                       (if (defined? rhs) (transpile rhs) 'undefined)])))))

       (as-statement
        ("var " (join ",\n    " (map destructured (#(pair) (join " = " pair)))))))

(macro list (...args)
       (var dots false, arg-segments [])

       (if (empty? args) "[]"
           (do
            (def simple-list (args)
                 ("[ " (join ", " (map args transpile)) " ]"))

            (each (arg) args
                  (var dots (detect arg.modifiers (#(mod) (= "..." mod.token))))

                  (if
                   dots (do (arg-segments.push (transpile arg)))
                   (list? (last arg-segments)) (send (last arg-segments) push arg)
                   true
                   (arg-segments.push [arg])))

            (assign arg-segments (map arg-segments
                                      (#(segment)
                                        (if (list? segment)
                                            (simple-list segment)
                                            (transpile segment)))))

            (if (= 1 (length arg-segments))
                (first arg-segments)
                (apply ^send (cons (first arg-segments)
                                   (cons 'concat (rest arg-segments))))))))


(macro call (fn-name ...args)
       (var dots (detect args (#(arg) (detect arg.modifiers (#(mod) (= "..." mod.token))))))

       (if dots
           (^apply (transpile fn-name) (apply ^list args))
           (concat (transpile fn-name)
                   "(" (join ", " (map args transpile)) ")")))

