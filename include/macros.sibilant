(namespace core)

(docs "the simplest way to conditionally execute code."
      example (ternary (< 50 100)
                       "fifty is less than 100"
                       "fifty is more than 100"))

(macro ternary (cond if-true if-false)
       ["(" (transpile cond) ") ? "
            (transpile if-true) " : "
            (transpile if-false)])






(docs "combines elements of array `arr` into a string,
inserting `glue` string between each element
fixme: incorrect argument order"
      example (join " " [ 'a 'few 'words ]))
      
(macro join (glue arr)
       ["(" (transpile arr) ").join(" (transpile glue) ")"])





;; used only for bootstrapping
(macro set (arr ...kv-pairs)
       (interleave "\n" (bulk-map kv-pairs
                                  (#(k v)
                                    (as-statement ["(" (transpile arr) ")"
                                                    "[" (transpile k) "] = " (transpile v) ])))))
(macro var (...pairs)
       (as-statement
        ["var "
         (interleave ",\n    "
               (bulk-map pairs
                         (#(name value)
                           [ (transpile name) " = " (transpile value) ])))
         ]))

(macro get (obj ...keys)
       ["(" (transpile obj) ")" (map keys (#(key)
                                            ["[" (transpile key) "]"]))])





(docs "stores a duplicate copy of `current-macro-name` as
`new-macro-name` in current namespace.  No output.")

(macro alias-macro (current-macro-name new-macro-name)
       (var current-macro-name (output-formatter (transpile current-macro-name))
            new-macro-name (output-formatter (transpile new-macro-name)))
       (set sibilant.macros.namespace
            new-macro-name (get sibilant.macros.namespace current-macro-name))
       null)





(docs "calls the `method` on `object` as a function with `args` as the arguments"
      example (send object method first-argument second-argument third-argument))

(macro send (object method ...args)
       [(transpile object) "." (transpile method)
               "(" (interleave ", " (map args transpile)) ")"])





(docs "calls the function `fn` with arguments passed as an array in `arglist`"
      example (apply my-function [ first-arg second-arg third-arg ]))

(macro apply (fn arglist)
       '(.apply @fn this @arglist))




(docs "builds an array with `first` as the zeroth index and the
elements provided by array `rest` as the subsequent elements, as
siblings with `first`.  deprecated"
      example (cons 1 [ 2 3 4 ]))

(macro cons (first rest)
       ["[ " (transpile first) " ].concat(" (transpile rest) ")"])




(docs "adds `additional` elements onto the right-side (tail) of `list`. deprecated"
example (append [ 1 2 3 ] 4 5 6))
(macro append (list ...additional)
       '(.concat @list (list ...@additional)))





(docs "fetches length attribute from `arr`"
      example (length [ 1 2 3 ]))
(macro length (arr)
       '(get @arr 'length))



(macro first (arr) '(get @arr 0))
(macro second (arr) '(get @arr 1))
(macro third (arr) '(get @arr 2))
(macro fourth (arr) '(get @arr 3))
(macro fifth (arr) '(get @arr 4))
(macro sixth (arr) '(get @arr 5))
(macro seventh (arr) '(get @arr 6))
(macro eighth (arr) '(get @arr 7))
(macro ninth (arr) '(get @arr 8))

(docs "fetches all but the first item of `arr`"
      example (rest [ 1 2 3 ]))
(macro rest (arr) '(.slice @arr 1))

(docs "fetches just the last element of `arr` by slicing."
      example (last [ 1 2 3 ]))
(macro last (arr) '(first (.slice @arr -1)))


(macro = (a b) [ (transpile a) " === " (transpile b) ])

(docs "adds `args` using the javascript `+` operator. Since javascript
overloads this for string concatenation, this macro can be used for
this as well."
      examples [ (+ 1 2 3) (+ 'hello 'world) ])
(macro +   (...args)
       ["(" (interleave " + " (map args transpile)) ")"])


(docs "subtracts each subsequent element of `args`"
      examples [ (- 2 1) (- 10 5 1) ])
(macro -   (...args)
       ["(" (interleave " - " (map args transpile)) ")"])

(docs "multiplies elements of `args`"
      example (* 3 4 5))
(macro *   (...args)
       ["(" (interleave " * " (map args transpile)) ")"])

(docs "divides each subsequent element of `args`"
      examples [ (/ 1 2)
                 (/ 1 2 3) ])
(macro /   (...args)
           ["(" (interleave " / " (map args transpile)) ")"])


(docs "short circuiting operator returns the first element of `args` that evaluates to be truthy"
      example (or (= 1 2) (string? []) "one is not two and an array is not a string"))
(macro or  (...args)
       ["(" (interleave " || " (map args transpile)) ")"])


(docs "returns the last element if all elements of `args` are truthy, or the
first non-truthy element if it exists"
      example (and (string? "string") (number? 10) (= 1 1)))
(macro and (...args)
       (ternary (= 1 (length args)) (transpile (first args))
                ["(" (interleave " && " (map args transpile)) ")"]))

(docs "modulus operator" example (mod 10 2))
(macro mod (...args)
       ["(" (interleave " % " (map args transpile)) ")"])

(macro infix-comparator (comparator args)
       ["(" (interleave " && "
                  (map (args.slice 0 -1)
                       (#(item index)
                         [ item " " comparator " " (get args (+ 1 index))])))
            ")"])

(macro >  (...args) (^infix-comparator  ">"  (map args transpile)))
(macro <  (...args) (^infix-comparator  "<"  (map args transpile)))
(macro <= (...args) (^infix-comparator "<="  (map args transpile)))
(macro >= (...args) (^infix-comparator ">="  (map args transpile)))
(macro != (...args) (^infix-comparator "!==" (map args transpile)))

(macro pow (base exponent)
       '(Math.pow @base @exponent))

(macro incr-by (item increment)
       [ (transpile item) " += " (transpile increment)])

(macro incr (item)
       ["((" (transpile item) ")++)"])

(macro decr (item)
       ["((" (transpile item) ")--)"])

(macro new (...args)
       ["(new " '(call ...@args) ")"])

(macro regex (string glim)
       '(new RegExp @string @(or glim 'undefined)))

(macro timestamp ()
       ["\"" (.to-string (new Date)) "\""])

(macro zero? (item) '(= @item 0))


(docs "returns true if the array `arr` has a length of zero"
      example (empty? []))
(macro empty? (arr)
       `(= 0 (length @arr)))

(docs "returns true if `number` is not divisible by 2"
      example (odd? 5))
(macro odd? (number)
       '(= 1 (mod @number 2)))

(docs "returns true if `number` is divisible by 2 with no remainder"
      example (even? 10))
(macro even? (number)
       '(= 0 (mod @number 2)))

(macro typeof (thing) ["typeof " (transpile thing)])

(macro string? (...things)
       '(and ...@(map things (#(thing) '(= (typeof @thing) 'string)))))
(macro function? (...things)
       '(and ...@(map things (#(thing) '(= (typeof @thing) 'function)))))
(macro undefined? (...things)
       '(and ...@(map things (#(thing) '(= (typeof @thing) 'undefined)))))
(macro defined? (...things)
       '(and ...@(map things (#(thing) '(!= (typeof @thing) 'undefined)))))
(macro number? (...things)
       '(and ...@(map things (#(thing) '(= (typeof @thing) 'number)))))

(macro if (arg truebody falsebody)
       ["(function() {"
        (indent ["if (" (transpile arg) ") {"
                        (indent '(do ...@truebody))
                        "} else {"
                        (indent '(do ...@falsebody))
                        "}"])
         "})()"])

(macro pipe (...calls)
       (inject undefined calls
         (#(value item)
           (var cloned (clone item))
           (if (undefined? value)
               cloned
               (merge-into cloned
                           { contents [ (first cloned.contents)
                                        value
                                        ...(rest cloned.contents) ] })))))


(docs "inserts `contents` transpiled to javascript as a comment in the
output file, removing it from execution."
      example (comment (def foo () 1)))
(macro comment (...contents)
       (map contents (#(content)
                       ["// "(recurse-map (transpile content)
                                    (#(item)
                                      (ternary item
                                               (pipe item
                                                     (transpile)
                                                     (output-formatter)
                                                     (.replace (regex "\n" 'g) "\n// "))
                                               null)))])))


(docs "checks if `first-thing` is equal to all of the `other-things`.
Most of the time, there is only one other thing. Javascript threequals
is always used.  Please note that if evaluating `first-thing` has
side-effects, they will be called `(length other-things)` times."
      examples [ (= 1 2)
                 (= 10 (+ 5 5) (- 15 5)) ])

(macro = (first-thing ...other-things)
       (var transpiled-first-thing (transpile first-thing))
       ["(" (interleave " &&\n "
                  (map other-things
                       (#(thing)
                         [ transpiled-first-thing
                                 " === "
                                 (transpile thing) ])))
            ")"])


(macro list? (thing)
       (var transpiled (transpile thing))
       ["((" transpiled ") && typeof (" transpiled ") === \"object\" && ("
               transpiled ").constructor.name === \"Array\")"])


(macro when (arg ...body)
       ["(function() {"
        (indent ["if (" (transpile arg) ") {"
                        (indent '(do ...@body))
                        "}"])
        "})()"])


(macro not (exp)
       ["(!" (transpile exp) ")"])

(macro unless (arg ...body)
       ["(function() {"
        (indent ["if (" '(not @arg) ") {"
                        (indent '(do ...@body))
                        "}"])
        "})()"])


(macro slice (arr start end)
       '(.slice @arr @start @end))

(macro inspect (...args)
       (interleave " + \"\\n\" + "
             (map args
                  (#(arg)
                    ["\"" arg ":\" + " (transpile arg)]))))

(macro each (item array ...body)
       '(.for-each @array
              (lambda @{ node this args item } ...@body)))

(macro assign (...args)
       (interleave "\n"
             (bulk-map args (#(name value)
                              (as-statement [ (transpile name) " = "
                                                    (transpile value)])))))



(macro macro-expand (name)
       (var macro (get macros (output-formatter (transpile name))))
       (if macro
           (macro.to-string)
           "undefined"))

(macro throw (...string)
       ["throw new Error (" (interleave " " (map string transpile)) ")"])

(macro as-boolean (expr)
       ["(!!(" (transpile expr) "))"])

(macro try (tryblock catchblock)
       ["(function() {"
        (indent ["try {"
                 (indent '(do @tryblock))
                 "} catch (e) {"
                 (indent '(do @catchblock))
                 "}"])
         "})()"])

(macro log-pretty (label arg)
       (var node this)
       (when (undefined? arg)
             (assign arg label
                     label ["\"" (prettify label false) "\""]))
       `(console.log (concat @["\"" node.file ":" node.line "\""] " " @label " = " (prettify @arg))))
(alias-macro log-pretty pretty-log)


(macro state (...pairs)
       (if (= 1 (length pairs))
           (get sibilant.state (output-formatter (transpile (first pairs))))
           (do (bulk-map pairs (#(k v) (set sibilant.state (output-formatter (transpile k)) (eval (output-formatter (transpile v))))))
               null)))

(macro symbol ()
       (var symbol-count (or (get sibilant.state 'symbol-count) 0)
            new-symbol-count (+ 1 symbol-count))
       (^state 'symbol-count new-symbol-count)
       ["$_symbol" new-symbol-count "_$"])

(macro while (condition ...block)
       (var symbol (^symbol))
       '(scoped-without-source
         (var @symbol)
         @["while (" (transpile condition) ") {"
           (indent '(assign @symbol (scoped-without-source ...@block)))
            "}"]
         @symbol))

(macro until (condition ...block)
       '(while (not @condition) ...@block))

(macro match? (regexp string)
       '(.match @string @regexp))

(macro match-regex? (string regexp-string glim)
       '(match? (regex @regexp-string @glim) @string))

(macro replace (string regexp-string replacement)
       '(.replace @string
              (regex @regexp-string)
              @replacement))

(macro replace-all (string regexp-string replacement)
       '(.replace @string (regex @regexp-string 'g) @replacement))

(macro thunk (...body)
       '(lambda @{ node this args [] }
       ...@(map-node body
                 (#(node)
                   (if (node? node 'arg-placeholder)
                       '(argument @(replace node.token "^#" ""))
                       node)))))
(alias-macro thunk #>)

(macro keys (obj)
       '(Object.keys @obj))

(macro delete (...objects)
       (interleave "\n" (map objects (#(obj)
                                 (as-statement ["delete " (transpile obj)])))))

(macro delmacro (...macro-names)
       (each (macro-name) macro-names
             (delete (get sibilant.macros.namespace (output-formatter (transpile macro-name)))))
       null)
(alias-macro delmacro delete-macro)


(macro rename-macro (current-macro-name desired-macro-name)
       (^alias-macro current-macro-name desired-macro-name)
       (^delmacro current-macro-name)
       null)

(macro arguments ()
       ["(Array.prototype.slice.apply(arguments))"])

(macro argument (n)
       '(get arguments @n))

(macro scoped (...body)
       '(call (lambda @{node this args []} ...@body)))

(macro scoped-without-source (...body)
       ["(function() {" (indent '(do ...@body)) "})()"])
       

(macro each-key (as obj ...body)
       '(scoped-without-source
         @["for (var " (transpile as) " in " (transpile obj) ") "
            (as-statement '(scoped-without-source ...@body))
            ]
         @obj))

(macro switch (obj ...cases)
       ["(function() {"
         (indent ["switch(" (transpile obj) ") {"
                   (map cases (#(case-def)
                                (var case-name-node (first case-def.contents)
                                     case-labels (if (node? case-name-node 'expression 'bracket)
                                                     case-name-node.contents
                                                     [case-name-node])
                                     case-string (interleave "\n" (map case-labels (#(c)
                                                                                     (if (= 'default c.token)
                                                                                         "default:"
                                                                                         ["case " (transpile c) ":"])))))
                                ["\n" case-string (indent '(do ...@(rest case-def.contents)))]))
                   "}"])
         "})()"])

(macro if (...args)
       ["(function() {"
        (indent
         (interleave " else "
               (bulk-map args
                         (#(cond val)
                           (if (!= (typeof val) 'undefined)
                                 ["if (" (transpile cond) ") {"
                                   (indent '(do @val))
                                   "}"]
                                 ["{" (indent '(do @cond)) "}"])))))
        "})()"])

(macro chain (object ...calls)
       (if (= 0 calls.length) (transpile object)
           (= 1 calls.length) '(send @object ...@(get (first calls) 'contents))
           (do
            (var lines (map calls (#(call index)
                                    ["." (transpile (first call.contents))
                                         "(" (interleave ", " (map (rest call.contents) transpile)) ")"])))

            [ (transpile object)
              (first lines)
              "\n  "
              (recurse-indent
               (interleave "\n" (rest lines)))])))

(macro chainable (...names)
       (each (name) names
             '(macro @name (target ...calls)
                     '(chain (call @name @target) ...@calls))))

(macro let (args body)
       ["let ("
         (interleave ", " (bulk-map args
                   (#(k v)
                     [ (transpile k) " = " (transpile v) ])))
         (if (undefined? body) ");"
             [") {" (indent (transpile body)) "}"])])

(macro instance-of? (item type)
       ["(" (transpile item) " instanceof " (transpile type) ")"])

(macro slice (list begin end)
       ["Array.prototype.slice.call(" (transpile list)
                                      ", " (or (transpile begin) 0)
                                      (if (defined? end) (", " (transpile end) ")") ")")])

(macro includes? (list item)
       '(pipe @list (.index-of @item) (!= -1)))

(macro excludes? (list item)
       '(pipe @list (.index-of @item) (= -1)))

(macro exists? (thing)
       '(and (defined? @thing) (!= @thing null)))

(macro with-state (k v ...body)
       (var before (^state k))
       (^state k v)
       (var return-value
            (interleave "\n" (map body transpile)))
       (^state k before)
       return-value)

(macro join (glue arr)
       (if (and (defined? glue) (undefined? arr))
           (assign arr glue glue undefined))
       ["(" (transpile arr) ").join(" (if glue (transpile glue) "\"\"") ")"])

(macro var (...pairs)
       (var destructured [])
       (bulk-map pairs (#(lhs rhs)
                         (switch lhs.type
                                 ('bracket
                                  (var symbol (^symbol))
                                  (destructured.push [symbol (transpile rhs)])
                                  (each (item index) lhs.contents
                                        (destructured.push [(transpile item) '(get @symbol @index)]))
                                  (destructured.push [symbol 'undefined]))
                                 ('brace
                                  (var symbol (^symbol))
                                  (destructured.push [symbol (transpile rhs)])
                                  (each (item index) lhs.contents
                                        (var tr-item (transpile item))
                                        (destructured.push [tr-item '(get @symbol @["\"" tr-item "\""])]))
                                  (destructured.push [symbol 'undefined]))

                                 (default
                                  (destructured.push [(transpile lhs)
                                                       (if rhs (transpile rhs) 'undefined)])))))

       (as-statement
        ["var " (interleave ",\n    "
           (map destructured
                (#(pair)
                  [(first pair) " = " (second pair)]
                  )))]))

(macro default (...pairs)
       (interleave "\n" (bulk-map pairs (#(name value)
                                  '(assign @name (ternary (defined? @name) @name @value))))))


(macro import-namespace (namespace)
       (var namespace-as-string (output-formatter (transpile namespace)))
       (unless (sibilant.macros.namespaces.has-own-property namespace-as-string)
               (set sibilant.macros.namespaces namespace-as-string {}))
       (sibilant.macros.search-path.unshift namespace-as-string)
       undefined)


(macro namespace (namespace)
       `(import-namespace @namespace)
       (set sibilant.macros 'namespace (get sibilant.macros.namespaces (output-formatter (transpile namespace))))
       undefined)






(docs "checks if `object` has property `key`.  returns true or false."
      example (has-key? object 'a))

(macro has-key? (object key)
       `(.has-own-property @object @key))







(docs "retreives object properties, potentially deeply. If more than one `keys` are provided,
`get` fetches deeply into nested objects or arrays.
When javascript dot notation can be used (`a.b = 3`), it is.
Otherwise, bracket notation is used."
      examples [ (get an-object 'static-attribute-name)
                 (get object dynamic-attribute-name)
                 (get object "these attributes" "can't be dotted")
                 (get array 0)
                 (get object 'a 'b c)
                 (get array 0 1 2) ])


(macro get (obj ...keys)
       [(transpile obj)
         (map keys (#(key)
                     (var transpiled (transpile key)
                          output (output-formatter transpiled))

                     (if (match-regex? output "^\"[a-zA-Z0-9]+\"$")
                         ["." (replace-all output "\"" "") ]
                         ["[" transpiled "]"])))])










(docs "assigns object properties to `arr` in pairs, alternating between keys and values.
When javascript dot notation can be used (`a.b = 3`), it is.  Otherwise, bracket notation is used"
      examples [ (set an-object 'static-attribute-name 'value)
                 (set object dynamic-attribute-name "key name determined at runtime")
                 (set array 0 "first element of array")
                 (set object "can't be dotted" 'value)
                 (set object 'first-attribute 'first-value
                      'second-attribute 'second-value) ])

(macro set (arr ...kv-pairs)
       (interleave "\n" (bulk-map kv-pairs (#(k v) `(assign (get @arr @k) @v)))))


