(def bulk-map (arr fn)
  (var index 0
          group-size fn.length
          ret-arr [])

  (while (< index arr.length)
    (.push ret-arr
          (apply fn (send arr slice
                          index (+ index group-size))))
    (incr-by index group-size))
  ret-arr)

(def inject (start items fn)
  (var value start)
  (when (list? items)
    (each (item index) items
      (assign value (fn value item index))))
  value)

(def map (items fn)
  (inject [] items
          (#(collector item index)
            (send collector push (fn item index))
            collector)))

(def select (items fn)
  (inject [] items
          (#(collector item index)
            (when (fn item index)
              (send collector push item))
            collector)))

(def detect (items fn)
  (var return-item undefined
          index 0
          items (or items []))

  (until (or (= items.length index) return-item)
         (when (fn (get items index) index)
           (assign return-item (get items index)))
         (incr index))

  return-item)

(def all? (items fn)
     (undefined? (detect items (#(item index) (not (fn item index))))))

(def none? (items fn)
     (undefined? (detect items fn)))

(def any? (items fn)
     (defined? (detect items fn)))

(def reject (items fn)
  (var args [ items fn ])
  (select items (thunk (not (apply fn arguments)))))

(def compact (arr)
     (select arr (#(item)
                   (and
                    (!= null item)
                    (!= false item)
                    (defined? item)))))

(def interleave (glue arr)
     (if (list? glue) (inject [] arr
             (#(collector item index)
               (collector.concat [item (get glue index)])))

         
     (inject [(first arr)] (rest arr)
             (#(collector item index) (collector.concat [glue item])))))


(def flatten (...items)
  (inject [] items
          (#(collector item)
            (collector.concat
             (if (list? item)
               (apply flatten item)
               item)))))


(def recurse-map (item fn)
     (if (list? item) (map item (#(subitem) (recurse-map subitem fn)))
         (fn item)))

(def pluck (items attribute)
     (map items (#(item) (get item attribute))))

(def merge-into (into from)
     (each (key) (keys from) (set into key (get from key)))
     into)

(def clone (object)
     (inject {} (keys object)
             (#(collector key)
               (set collector key (get object key))
               collector)))

(def map-values (object fn)
     (inject {} (keys object)
             (#(collector key index)
               (set collector key (fn (get object key) key))
               collector)))

(def merge-with (into from)
     (merge-into (clone into) from))
