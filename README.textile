h1. Sibilant

There's a ridiculous amount of documentation I need to do, but I wanted to get this out.

You've seen coffeescript, the language that is parsed by javascript and "compiles" to javascript.  Sibilant is like that, but inspired by lisp.  Everything is a list.  Macros that output javascript can be defined in sibilant and included at translation time.

h2. Installation

@bash$ npm install sibilant@

h2. Repl

<pre><code>bash$ sibilant
sibilant> (defvar sys (require 'sys))
sibilant> (sys.puts "hello world")
hello world
sibilant> (defun hello (&rest args)
...est args) > (sys.puts (sys.inspect args)))
result: [Function]
sibilant> (hello 'world)
[ 'world' ]
sibilant> (+ 5 3)
result: 8
sibilant> * ;this is the return value of the last statement
result: 8
</code></pre>

h2. Convert a file

@bash$ sibilant package.lisp@

This outputs to stdout.  To print to a file, use unix.

@bash$ sibilant package.lisp > package.json@

This is actually how package.json is generated.

h2. Language

h3. Literals

h4. Strings

<pre><code>"to the world, he said \"hello\""</code></pre>

Multiline strings are okay:

<pre><code>"this is a
multiline string"</code></pre>

h4. Numbers

Numbers are directly translated to javascript. Valid numbers include @10@, @98.6@, @-100@, et cetera.

h4. Variables

Variables only include lower-case letters.  Hyphens are legal, and are translated into camelcase in javascript.  For example, @j-query@ is @jQuery@.  Asterisks become underscores.  For example @*global-variable*@ would become @_globalVariable_@ in javascript.  Variables can _end_ with question marks and exclamation marks.  These are translated to javascript as "Q" and "B" (for bang).  For example, @ready?@ becomes @readyQ@ and @finish!@ becomes @finishB@.

h3. Quoting

<pre><code>'(a b c d e f g) ;=> ['a', 'b', 'c', 'd', 'e', 'f', 'g']
'hello ;=> "hello"</code></pre>

h4. Lists

<pre><code>(list 1 2 3 4 5) ;=> [1,2,3,4,5]</code></pre>


h3. Defining a variable

<pre><code>(defvar foo "foo now has this value")</code></pre>

h3. Hashes

<pre><code>(hash key1 'value1
		 key2 'value2) ;=> {key1: "value1", key2: "value2"}</code></pre>

h3. Calling functions

Let's say we're in node and want to use the built-in function @require@.

<pre><code>(defvar sys (require 'sys)) ;=> var sys = require("sys")</code></pre>

h3. Defining functions

<pre><code>(defun square (arg1) (* arg1 arg1))
    ;=> var square = function(arg1) { return arg1 * arg1 }

(square 5)
</code></pre>

h2. Examples

Check out "the examples directory":http://github.com/jbr/sibilant/tree/master/examples/ to get a sense of what's possible.  Also, check out "macros.lisp":http://github.com/jbr/sibilant/blob/master/lib/macros.lisp to see how easy it is to write new compiler macros.


Didn't feel like clicking? Here's the example from "nodejs.org":http://nodejs.org/, translated to sibilant:

<pre><code>(defvar http (require 'http))

(defvar server (http.create-server (lambda (request, response)
  (response.write-head 200 (hash "Content-Type" "text/plain"))
  (response.end "Hello World\n"))))

(server.listen 8124 "127.0.0.1")
(console.log "Server running at http://127.0.0.1:8124/")</code></pre>


h1. Contributing

* Mailing List: "sibilantjs@librelist.com":mailto:sibilantjs@librelist.com
