{"version":3,"sources":["/Users/jbr/code/sibilant/src/macros.sibilant","/Users/jbr/code/sibilant/include/macros.sibilant"],"names":[],"mappings":"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","sourcesContent":["(var macros {})\n(set sibilant 'macros macros 'debug false)\n\n\n(def recurse-indent (...args)\n     (map args\n          (#(arg)\n            (if (node? arg) (do (set arg 'contents (apply recurse-indent (compact (flatten arg.contents)))) arg)\n                (list? arg) (apply recurse-indent arg)\n                (number? arg) (arg.to-string)\n                (string? arg)\n                (chain arg\n                       (replace (regex \"\\\\n\" 'g) \"\\n  \")\n                       (replace (regex \"\\\\n\\\\s+\\\\n\" 'g) \"\\n\\n\"))\n\n                 arg))))\n\n(def indent (...args)\n     [\"\\n  \" (recurse-indent args) \"\\n\"])\n\n\n(def escape-regex (string)\n     (string.replace (regex \"[\\\\-\\\\[\\\\]\\\\/\\\\{\\\\}\\\\(\\\\)\\\\*\\\\+\\\\?\\\\.\\\\\\\\\\^\\\\$\\\\|]\" 'g) \"\\\\$&\"))\n\n(def ^return (token)\n     (when sibilant.debug (console.log \"returning \" (prettify token)))\n     (var default-return (as-statement [\"return \" (transpile token)]))\n     (if (and token token.contents token.contents.length)\n         (switch (get (first token.contents) 'token)\n                 (('return 'throw 'do) (transpile token))\n                 ('delete\n                  (var delete-macro (get macros 'delete))\n                  (if (< token.contents.length 3) default-return\n                      [ (as-statement (apply delete-macro (token.contents.slice 1 -1)))\n                        \"\\nreturn \"\n                        (as-statement (call delete-macro (last token.contents)))]))\n                 ('assign\n                  (if (< token.contents.length 4) default-return\n                      [ (apply ^assign\n                               (token.contents.slice 1 (- token.contents.length 2)))\n                        \"\\nreturn \"\n                        (apply ^assign (token.contents.slice -2))]))\n                 ('var\n                  [ (transpile token) \"\\nreturn \" (transpile (if (even? token.contents.length)\n                                                                 (last token.contents)\n                                                                 (first (token.contents.slice -2))))])\n                 ('set\n                  (if (< token.contents.length 5) default-return\n                      (do\n                       (var obj (second token.contents)\n                            non-return-part (token.contents.slice 2 (- token.contents.length 2))\n                            return-part (token.contents.slice -2))\n                       (non-return-part.unshift obj)\n                       (return-part.unshift obj)\n                       [ (^set ...non-return-part)\n                         \"\\nreturn \"\n                         (^set ...return-part)])))\n                 (default default-return))\n         default-return))\n\n\n(def statement? (transpiled)\n     (if (node? transpiled) (statement? transpiled.contents)\n         (list? transpiled) (statement? (last transpiled))\n         (string? transpiled) (= \";\" (last transpiled))\n         false))\n\n(def as-statement (node)\n     (var transpiled (transpile node))\n\n     (if (empty-node? transpiled) undefined\n         (statement? transpiled) transpiled\n         [ transpiled \";\" ]))\n\n(def ^do (...body)\n     (if (= 1 body.length) (^return (first body))\n         body.length [ (interleave \"\\n\" (map (body.slice 0 -1) (#(node) (as-statement node))))\n                       \"\\n\"\n                       (^return (last body)) ]\n         \"\"))\n\n(def ^empty-list () 'null)\n\n(def ^def (fn-name args ...body)\n     (var fn-name-tr (transpile fn-name) this-node this)\n\n     (as-statement [ (if (match? (regex \"\\\\.\") (output-formatter fn-name-tr)) \"\" \"var \")\n                     fn-name-tr \" = \"\n                     (^lambda { name fn-name args args node this-node } ...body )\n                     ] ))\n\n(def ^macro (name args ...body)\n     (var name-tr (output-formatter (transpile name))\n          options { name name args args node this}\n          js (output-formatter (^lambda options ...body)))\n\n     (when sibilant.debug (console.log js))\n     \n     (try (set macros name-tr (eval js))\n          (error (\"error in parsing macro \"\n                  (sibilant.pretty-print name) \":\\n\" js)))\n\n     undefined)\n\n(def ^concat (...args)\n     [\"(\" (interleave \" + \" (map args transpile)) \")\"])\n\n(def ^reverse (arr)\n     (var reversed [])\n     (each (item) arr (reversed.unshift item))\n     reversed)\n\n(var reverse ^reverse)\n\n(def ^lambda (args-or-options ...body)\n     (when sibilant.debug\n           (console.log args-or-options))\n     (var args (or (get args-or-options 'args) args-or-options)\n          body (or (get args-or-options 'body) body)\n          args (if (node? args 'expression) args.contents\n                   (and (node? args) (empty? body)) (do (assign body [ args ]) [])\n                   args)\n          name (when args-or-options.name\n                     (chain (output-formatter (transpile args-or-options.name))\n                            (replace (regex \"\\\\W+\" 'g) \"$\")\n                            (concat \"$\")))\n          rest (detect args\n                       (#(arg) (node? arg 'dots))))\n\n     (var this-node this\n          node (detect\n                [ args-or-options.node this-node args-or-options.name args (first body) ]\n                (#(n) (and (node? n) (get n 'file)))))\n     [\"(function\" (if name (\" \" name) \"\") \"(\"\n       (interleave \", \" (map args transpile)) \") {\"\n       (if (or args-or-options.name node)\n           (indent [\"/*\"\n                     (if args-or-options.name (\" \" (sibilant.pretty-print args-or-options.name false)) \"\")\n                     (if node (\" \" node.file \":\" node.line \":\" node.col) \"\")\n                     \" */\"]) \"\")\n       (when (exists? rest)\n             (indent (as-statement [\"var \" (transpile rest)\n                       \" = Array.prototype.slice.call(arguments, \"\n                       (- args.length 1) \")\"])))\n\n       (indent (apply ^do body))\n       \"})\"])\n\n(set macros \"#\" ^lambda)\n\n(def ^quoted-hash (...pairs)\n     (var cached-quote-value ^hash.quote-keys)\n     (set ^hash 'quote-keys true)\n     (var value (^hash ...pairs))\n     (set ^hash 'quote-keys cached-quote-value)\n     value)\n\n(def ^hash (...pairs)\n     (when (odd? pairs.length)\n           (error (\"odd number of key-value pairs in hash: \"\n                   (call inspect pairs))))\n\n     (var quote-keys ^hash.quote-keys\n          pair-strings (bulk-map pairs (#(key value)\n                                         [ (if (and quote-keys (not (node? key 'string)))\n                                               [\"\\\"\" (transpile key) \"\\\"\"]\n                                               (transpile key))\n                                           \": \"\n                                           (transpile value)])))\n     (if (>= 1 pair-strings.length)\n         [\"{ \" (interleave \", \" pair-strings) \" }\"]\n         [\"{\" (indent (interleave \",\\n\" pair-strings)) \"}\"]))\n\n\n(def qescape (content)\n     (if (not (exists? content)) \"\"\n         (string? content) (chain content\n                                  (replace (regex \"\\\"\" 'g) \"\\\\\\\"\")\n                                  (replace (regex \"\\\\n\" 'g) \"\\\\n\\\" +\\n\\\"\"))\n         content))\n\n(def log-pretty (label arg)\n     (console.log (concat label \": \" (prettify arg)))\n     arg)\n\n(var pretty-log log-pretty)\n\n(def ^quote (content)\n     (if (string? content) (\"\\\"\" (qescape content) \"\\\"\")\n         (number? content) (^quote (content.to-string))\n         (node? content 'literal) [\"\\\"\" (transpile content) \"\\\"\"]\n         (node? content 'expression)\n         (if (length (keys (find-unquotes content)))\n             (^call 'macros.expand-quote.call 'this (^quote content.node-id)\n                    (apply ^quoted-hash (alternating-keys-and-values (find-unquotes content))))\n             [\"\\\"\" (map-node (transpile content) qescape) \"\\\"\"])\n         (do\n          (console.log (\"unknown content\" (prettify content)))\n          content)))\n\n(def ^debug (val)\n     (set sibilant 'debug (eval (output-formatter (transpile val)))) null)\n\n(def map-node (node fn)\n     (if (node? node)\n         (do\n          (var mapped-node (fn node))\n          (when (node? mapped-node)\n                (set mapped-node 'contents (map-node mapped-node.contents fn)))\n\n          mapped-node)\n\n         (list? node) (map node (#(c) (map-node c fn)))\n         (fn node)))\n\n(def each-node (node fn)\n     (if (node? node) (when (fn node) (each-node node.contents fn))\n         (list? node) (each (c) node (each-node c fn))\n         (fn node)))\n\n\n(def map-node-for-quote-expansion (node expansions)\n     (if (node? node)\n         (do\n          (var mapped-node (if (expansions.has-own-property node.node-id) (get expansions node.node-id) (clone node)))\n          (when (node? mapped-node)\n                (set mapped-node 'contents (map-node-for-quote-expansion mapped-node.contents expansions)))\n\n          (assign mapped-node (splice-dots mapped-node))\n          mapped-node)\n\n         (list? node)\n           (map node (#(c) (map-node-for-quote-expansion c expansions)))\n\n         node))\n\n\n(def ^expand-quote (node-id expansions)\n     (var expanded-nodes\n          (map-node-for-quote-expansion (get sibilant.node-cache node-id) expansions))\n\n     (transpile expanded-nodes))\n\n(def unquote? (node) (node? node 'at))\n\n(def find-unquotes (node)\n     (var unquotes {})\n     (each-node node (#(n)\n                       (when (unquote? n)\n                             (set unquotes n.node-id (transpile n)))\n                       (not (node? n 'tick))))\n     unquotes)\n\n(def splice-dots (node)\n     (when (list? node.contents)\n           (var contents [])\n           (each (content) node.contents\n                 (if (and (node? content 'dots)\n                          (list? content.contents)\n                          (= content.contents.length 1)\n                          (list? (first content.contents)))\n                      (contents.push.apply contents (first content.contents))\n                      (contents.push content)))\n\n           (set node 'contents contents))\n     node)\n\n\n(def alternating-keys-and-values (hash)\n     (flatten (map (keys hash)\n                   (#(key) [key, (get hash key)]))))\n\n\n(def ^list (...args)\n       (var arg-segments [])\n       (if (empty? args) \"[]\"\n           (do\n            (def simple-list (args)\n                 [\"[ \" (interleave \", \" (map args (#(arg) arg.transpiled))) \" ]\"])\n\n            (args.for-each (#(arg)\n                  (if (node? arg 'dots) (arg-segments.push {transpiled (transpile arg)})\n                   (list? (last arg-segments)) (send (last arg-segments) push {transpiled (transpile arg)})\n                   (arg-segments.push [{transpiled (transpile arg)}]))))\n\n            (assign arg-segments (map arg-segments\n                                      (#(segment)\n                                        (if (list? segment)\n                                            (simple-list segment)\n                                            segment.transpiled))))\n\n            (if (= 1 (length arg-segments))\n                (first arg-segments)\n                [(first arg-segments) \".concat(\" (interleave \", \" (rest arg-segments))\")\"]))))\n\n\n(def ^call (fn-name ...args)\n     (if (any? args (#(arg) (node? arg 'dots)))\n           (macros.apply fn-name (macros.list ...args))\n           [ (transpile fn-name)\n                   \"(\" (interleave \", \" (map args transpile)) \")\" ]))\n\n(def ^dots (...contents)\n     (transpile contents))\n\n","(macro join (glue arr)\n       [\"(\" (transpile arr) \").join(\" (transpile glue) \")\"])\n\n(macro set (arr ...kv-pairs)\n       (interleave \"\\n\" (bulk-map kv-pairs\n                                  (#(k v)\n                                    (as-statement [\"(\" (transpile arr) \")\"\n                                                    \"[\" (transpile k) \"] = \" (transpile v) ])))))\n\n(macro get (obj ...keys)\n       [\"(\" (transpile obj) \")\" (map keys (#(key) [\"[\" (transpile key) \"]\"]))])\n\n(macro var (...pairs)\n       (as-statement\n        [\"var \"\n         (interleave \",\\n    \"\n               (bulk-map pairs\n                         (#(name value)\n                           [ (transpile name) \" = \" (transpile value) ])))\n         ]))\n\n(macro alias-macro (current-macro-name desired-macro-name)\n       (var current-macro-name (output-formatter (transpile current-macro-name))\n            desired-macro-name (output-formatter (transpile desired-macro-name)))\n       (set macros desired-macro-name (get macros current-macro-name))\n       null)\n\n(macro send (object method ...args)\n       [(transpile object) \".\" (transpile method)\n               \"(\" (interleave \", \" (map args transpile)) \")\"])\n\n(macro apply (fn arglist)\n       '(send @fn apply this @arglist))\n\n(macro cons (first rest)\n       [\"[ \" (transpile first) \" ].concat(\" (transpile rest) \")\"])\n\n(macro append (list ...additional)\n       '(send @list concat (list ...@additional)))\n\n(macro length (arr)\n       '(get @arr 'length))\n\n(macro ternary (cond if-true if-false)\n       [\"(\" (transpile cond) \") ? \"\n            (transpile if-true) \" : \"\n            (transpile if-false)])\n\n(macro first (arr) '(get @arr 0))\n(macro second (arr) '(get @arr 1))\n(macro third (arr) '(get @arr 2))\n(macro fourth (arr) '(get @arr 3))\n(macro fifth (arr) '(get @arr 4))\n(macro sixth (arr) '(get @arr 5))\n(macro seventh (arr) '(get @arr 6))\n(macro eighth (arr) '(get @arr 7))\n(macro ninth (arr) '(get @arr 8))\n(macro rest (arr)\n       '(send @arr slice 1))\n\n(macro last (arr)\n       '(first (send @arr slice -1)))\n\n\n(macro = (a b) [ (transpile a) \" === \" (transpile b) ])\n(macro +   (...args)\n       [\"(\" (interleave \" + \" (map args transpile)) \")\"])\n(macro -   (...args)\n       [\"(\" (interleave \" - \" (map args transpile)) \")\"])\n(macro *   (...args)\n       [\"(\" (interleave \" * \" (map args transpile)) \")\"])\n(macro /   (...args)\n           [\"(\" (interleave \" / \" (map args transpile)) \")\"])\n(macro or  (...args)\n       [\"(\" (interleave \" || \" (map args transpile)) \")\"])\n\n(macro and (...args)\n       (ternary (= 1 (length args)) (transpile (first args))\n                [\"(\" (interleave \" && \" (map args transpile)) \")\"]))\n\n(macro mod (...args)\n       [\"(\" (interleave \" % \" (map args transpile)) \")\"])\n\n(macro infix-comparator (comparator args)\n       [\"(\" (interleave \" && \"\n                  (map (args.slice 0 -1)\n                       (#(item index)\n                         [ item \" \" comparator \" \" (get args (+ 1 index))])))\n            \")\"])\n\n(macro >  (...args) (macros.infix-comparator  \">\"  (map args transpile)))\n(macro <  (...args) (macros.infix-comparator  \"<\"  (map args transpile)))\n(macro <= (...args) (macros.infix-comparator \"<=\"  (map args transpile)))\n(macro >= (...args) (macros.infix-comparator \">=\"  (map args transpile)))\n(macro != (...args) (macros.infix-comparator \"!==\" (map args transpile)))\n\n(macro pow (base exponent)\n       '(Math.pow @base @exponent))\n\n(macro incr-by (item increment)\n       [ (transpile item) \" += \" (transpile increment)])\n\n(macro incr (item)\n       [\"((\" (transpile item) \")++)\"])\n\n(macro decr (item)\n       [\"((\" (transpile item) \")--)\"])\n\n(macro new (...args)\n       [\"(new \" '(call ...@args) \")\"])\n\n(macro regex (string glim)\n       '(new RegExp @string @(or glim 'undefined)))\n\n(macro timestamp ()\n       [\"\\\"\" (send (new Date) to-string) \"\\\"\"])\n\n(macro comment (...contents)\n       (map contents (#(content)\n                       [\"// \"(recurse-map (transpile content)\n                                    (#(item)\n                                      (ternary item\n                                               (send (output-formatter (transpile item)) replace\n                                                     (regex \"\\n\" 'g) \"\\n// \")\n                                               null)))])))\n\n(macro meta (body)\n       (eval (output-formatter (transpile body))))\n\n(macro zero? (item) '(= @item 0))\n\n(macro empty? (arr)\n       [\"((\" (transpile arr) \").length === 0)\"])\n\n(macro odd? (number)\n       '(= 1 (mod @number 2)))\n\n(macro even? (number)\n       '(= 0 (mod @number 2)))\n\n(macro typeof (thing) [\"typeof \" (transpile thing)])\n\n\n(macro function? (...things)\n       '(and ...@(map things (#(thing) '(= (typeof @thing) 'function)))))\n(macro undefined? (...things)\n       '(and ...@(map things (#(thing) '(= (typeof @thing) 'undefined)))))\n(macro defined? (...things)\n       '(and ...@(map things (#(thing) '(!= (typeof @thing) 'undefined)))))\n(macro number? (...things)\n       '(and ...@(map things (#(thing) '(= (typeof @thing) 'number)))))\n\n(macro if (arg truebody falsebody)\n       [\"(function() {\"\n        (indent [\"if (\" (transpile arg) \") {\"\n                        (indent '(do ...@truebody))\n                        \"} else {\"\n                        (indent '(do ...@falsebody))\n                        \"}\"])\n         \"})()\"])\n\n(macro = (first-thing ...other-things)\n       (var transpiled-first-thing (transpile first-thing))\n       [\"(\" (interleave \" &&\\n \"\n                  (map other-things\n                       (#(thing)\n                         [ transpiled-first-thing\n                                 \" === \"\n                                 (transpile thing) ])))\n            \")\"])\n\n\n(macro string? (thing)\n       [\"typeof(\" (transpile thing) \") === \\\"string\\\"\"])\n\n(macro list? (thing)\n       (var transpiled (transpile thing))\n       [\"((\" transpiled \") && typeof (\" transpiled \") === \\\"object\\\" && (\"\n               transpiled \").constructor.name === \\\"Array\\\")\"])\n\n\n(macro when (arg ...body)\n       [\"(function() {\"\n        (indent [\"if (\" (transpile arg) \") {\"\n                        (indent '(do ...@body))\n                        \"}\"])\n        \"})()\"])\n\n\n(macro not (exp)\n       [\"(!\" (transpile exp) \")\"])\n\n(macro unless (arg ...body)\n       [\"(function() {\"\n        (indent [\"if (\" '(not @arg) \") {\"\n                        (indent '(do ...@body))\n                        \"}\"])\n        \"})()\"])\n\n\n(macro slice (arr start end)\n       '(send @arr slice @start @end))\n\n(macro inspect (...args)\n       (interleave \" + \\\"\\\\n\\\" + \"\n             (map args\n                  (#(arg)\n                    [\"\\\"\" arg \":\\\" + \" (transpile arg)]))))\n\n(macro each (item array ...body)\n       '(send @array for-each\n              (lambda @{ node this args item } ...@body)))\n\n(macro assign (...args)\n       (interleave \"\\n\"\n             (bulk-map args (#(name value)\n                              (as-statement [ (transpile name) \" = \"\n                                                    (transpile value)])))))\n\n\n\n\n(macro macro-list ()\n       '(list @(Object.keys macros)))\n\n(macro macroexpand (name)\n       (var macro (get macros (transpile name)))\n       (if macro\n           (\"// macro: \" name \"\\n\" (macro.to-string))\n           \"undefined\"))\n\n\n(macro throw (...string)\n       [\"throw new Error (\" (interleave \" \" (map string transpile)) \")\"])\n\n(macro as-boolean (expr)\n       [\"(!!(\" (transpile expr) \"))\"])\n\n(macro try (tryblock catchblock)\n       [\"(function() {\"\n        (indent [\"try {\"\n                 (indent '(do @tryblock))\n                 \"} catch (e) {\"\n                 (indent '(do @catchblock))\n                 \"}\"])\n        \"})()\"])\n\n(macro state (...pairs)\n       (set macros.state 'data (or macros.state.data {}))\n\n       (if (= 1 (length pairs))\n           (get macros.state.data (output-formatter (transpile (first pairs))))\n           (do (bulk-map pairs (#(k v) (set macros.state.data (output-formatter (transpile k)) (eval (output-formatter (transpile v))))))\n               null)))\n\n(macro symbol ()\n       (var symbol-count (or (macros.state 'symbol-count) 0)\n            new-symbol-count (+ 1 symbol-count))\n       (macros.state 'symbol-count new-symbol-count)\n       [\"$_symbol\" new-symbol-count \"_$\"])\n\n(macro while (condition ...block)\n       (var symbol (macros.symbol))\n       '(scoped-without-source\n         (var @symbol)\n         @[\"while (\" (transpile condition) \") {\"\n           (indent '(assign @symbol (scoped-without-source ...@block)))\n            \"}\"]\n         @symbol))\n\n(macro until (condition ...block)\n       '(while (not @condition) ...@block))\n\n(macro thunk (...body)\n       '(lambda @{ node this args [] } ...@body))\n(alias-macro thunk #>)\n\n(macro keys (obj)\n       '(Object.keys @obj))\n\n(macro delete (...objects)\n       (interleave \"\\n\" (map objects (#(obj)\n                                 (as-statement [\"delete \" (transpile obj)])))))\n\n(macro delmacro (...macro-names)\n       (each (macro-name) macro-names\n             (delete (get macros (output-formatter (transpile macro-name)))))\n       null)\n(alias-macro delmacro delete-macro)\n\n\n(macro rename-macro (current-macro-name desired-macro-name)\n       (macros.alias-macro current-macro-name desired-macro-name)\n       (macros.delmacro current-macro-name)\n       null)\n\n(macro arguments ()\n       [\"(Array.prototype.slice.apply(arguments))\"])\n\n(macro scoped (...body)\n       '(call (lambda @{node this args []} ...@body)))\n\n(macro scoped-without-source (...body)\n       [\"(function() {\" (indent '(do ...@body)) \"})()\"])\n       \n\n(macro each-key (as obj ...body)\n       '(scoped-without-source\n         @[\"for (var \" (transpile as) \" in \" (transpile obj) \") \"\n            (as-statement '(scoped-without-source ...@body))\n            ]\n         @obj))\n\n(macro match? (regexp string)\n       '(send @string match @regexp))\n\n(macro switch (obj ...cases)\n       [\"(function() {\"\n         (indent [\"switch(\" (transpile obj) \") {\"\n                   (map cases (#(case-def)\n                                (var case-name-node (first case-def.contents)\n                                     case-labels (if (or (node? case-name-node 'expression)\n                                                         (node? case-name-node 'bracket))\n                                                     case-name-node.contents\n                                                     [case-name-node])\n                                     case-string (interleave \"\\n\" (map case-labels (#(c)\n                                                                                     (if (= 'default c.token)\n                                                                                         \"default:\"\n                                                                                         [\"case \" (transpile c) \":\"])))))\n                                [\"\\n\" case-string (indent '(do ...@(rest case-def.contents)))]))\n                   \"}\"])\n         \"})()\"])\n\n(macro if (...args)\n       [\"(function() {\"\n        (indent\n         (interleave \" else \"\n               (bulk-map args\n                         (#(cond val)\n                           (if (!= (typeof val) 'undefined)\n                                 [\"if (\" (transpile cond) \") {\"\n                                   (indent '(do @val))\n                                   \"}\"]\n                                 [\"{\" (indent '(do @cond)) \"}\"])))))\n        \"})()\"])\n\n(macro chain (object ...calls)\n       (if (= 0 calls.length) (transpile object)\n           (= 1 calls.length) '(send @object ...@(get (first calls) 'contents))\n           (do\n            (var lines (map calls (#(call index)\n                                    [\".\" (transpile (first call.contents))\n                                         \"(\" (interleave \", \" (map (rest call.contents) transpile)) \")\"])))\n\n            [ (transpile object)\n              (first lines)\n              \"\\n  \"\n              (recurse-indent\n               (interleave \"\\n\" (rest lines)))])))\n\n(macro chainable (...names)\n       (each (name) names\n             '(macro @name (target ...calls)\n                     '(chain (call @name @target) ...@calls))))\n\n(macro let (args body)\n       [\"let (\"\n         (interleave \", \" (bulk-map args\n                   (#(k v)\n                     [ (transpile k) \" = \" (transpile v) ])))\n         (if (undefined? body) \");\"\n             [\") {\" (indent (transpile body)) \"}\"])])\n\n(macro instance-of? (item type)\n       [\"(\" (transpile item) \" instanceof \" (transpile type) \")\"])\n\n(macro slice (list begin end)\n       [\"Array.prototype.slice.call(\" (transpile list)\n                                      \", \" (or (transpile begin) 0)\n                                      (if (defined? end) (\", \" (transpile end) \")\") \")\")])\n\n(macro includes? (list item)\n       '(!= -1 (send @list index-of @item)))\n\n(macro excludes? (list item)\n       '(= -1 (send @list index-of @item)))\n\n(macro exists? (thing)\n       '(and (defined? @thing) (!= @thing null)))\n\n(macro with-state (k v ...body)\n       (var before (macros.state k))\n       (macros.state k v)\n       (var return-value\n            (interleave \"\\n\" (map body transpile)))\n       (macros.state k before)\n       return-value)\n\n(macro join (glue arr)\n       (if (and (defined? glue) (undefined? arr))\n           (assign arr glue glue undefined))\n       [\"(\" (transpile arr) \").join(\" (if glue (transpile glue) \"\\\"\\\"\") \")\"])\n\n(macro var (...pairs)\n       (var destructured [])\n       (bulk-map pairs (#(lhs rhs)\n                         (switch lhs.type\n                                 ('bracket\n                                  (var symbol (macros.symbol))\n                                  (destructured.push [symbol (transpile rhs)])\n                                  (each (item index) lhs.contents\n                                        (destructured.push [(transpile item) '(get @symbol @index)]))\n                                  (destructured.push [symbol 'undefined]))\n                                 ('brace\n                                  (var symbol (macros.symbol))\n                                  (destructured.push [symbol (transpile rhs)])\n                                  (each (item index) lhs.contents\n                                        (var tr-item (transpile item))\n                                        (destructured.push [tr-item '(get @symbol @[\"\\\"\" tr-item \"\\\"\"])]))\n                                  (destructured.push [symbol 'undefined]))\n\n                                 (default\n                                  (destructured.push [(transpile lhs)\n                                                       (if rhs (transpile rhs) 'undefined)])))))\n\n       (as-statement\n        [\"var \" (interleave \",\\n    \"\n           (map destructured\n                (#(pair)\n                  [(first pair) \" = \" (second pair)]\n                  )))]))\n\n\n(debug false)"]}