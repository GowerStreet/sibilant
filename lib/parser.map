{"version":3,"sources":["/Users/jbr/code/sibilant/src/parser.sibilant"],"names":[],"mappings":"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","sourcesContent":["(var parser {})\n(set sibilant 'parser parser)\n(set parser 'tokens\n     { 'regex              \"(\\\\/(\\\\\\\\\\\\\\/|[^\\\\/\\\\n])+\\\\/[glim]*)\"\n       'comment            \"(;.*)\"\n       'string             \"(\\\"(([^\\\"]|(\\\\\\\\\\\"))*[^\\\\\\\\])?\\\")\"\n       'number             \"(-?[0-9][0-9.,]*)\"\n       'literal            \"(-?[*.$a-zA-Z_][*.a-zA-Z0-9-_]*(\\\\?|!)?)\"\n       'special            \"([&'])\"\n       'at                 \"@\"\n       'tick               \"[`']\"\n       'hat                \"(\\\\^)\"\n       'dots               \"(\\\\.+)\"\n       'other-char         \"([#><=!\\\\+\\\\/\\\\*-]+)\"\n       'open-expression    \"(\\\\(|\\\\{|\\\\[)\"\n       'close-expression    \"(\\\\)|\\\\}|\\\\])\"\n       'newline \"\\\\n\"\n       'whitespace \"\\\\s\"\n       'ignored \".\" })\n\n;;(set parser.tokens 'special-literal (concat parser.tokens.special parser.tokens.literal))\n\n(set parser 'token-precedence  [ 'regex\n                                 'comment\n                                 'string\n                                 'number\n                                 'dots\n                                 'tick\n                                 'hat\n                                 'at\n                                 'special\n                                 'literal\n                                 'other-char\n                                 'open-expression\n                                 'close-expression\n                                 'newline\n                                 'whitespace\n                                 'ignored\n                                 ]\n     'ordered-regexes (parser.token-precedence.map\n                       (#(x)\n                         (var r (regex (\"^\" (get parser.tokens x))))\n                         (set r 'name x)\n                         r)))\n\n\n(var ordered-regexes parser.ordered-regexes)\n\n(set sibilant 'node-cache (or sibilant.node-cache {}))\n(def node-id (node)\n     (incr node-id.last-id))\n(def cache-node (node)\n     (var id (node-id node))\n     (set sibilant.node-cache id node)\n     (merge-into node {node-id id}))\n\n(set node-id 'last-id 0)\n\n (def parser.parse (string context)\n     (var context (if context context { position 0\n                        stack []\n                        line 1\n                        last-newline 0 col 0}))\n\n     (var match true\n          regex-name null\n          remaining-input string)\n\n     (while match\n            (detect ordered-regexes\n                    (#(r)\n                      (assign match (r.exec remaining-input)\n                              regex-name r.name)\n                      match))\n\n            (when (exists? match)\n                  (var match-string (first match)\n                       length (length match-string))\n                  \n                  (context.stack.push\n                   (cache-node { contents []\n                                 dir sibilant.dir\n                                 file sibilant.file\n                                 token match-string\n                                 type regex-name\n                                 start context.position\n                                 line context.line\n                                 col context.col\n                                 length length }))\n\n                  (if\n                   (= 'newline regex-name)\n                   (do\n                    (incr context.line)\n                    (set context\n                         'col 0\n                         'last-newline context.position))\n\n\n                   (and (= 'string regex-name) (!= -1 (match-string.index-of \"\\n\")))\n                   (do\n                    (var string-newline-count (- (length (match-string.split \"\\n\")) 1))\n                    (incr-by context.line string-newline-count)\n                    (set context 'col (- length (match-string.last-index-of \"\\n\"))))\n\n                   (incr-by context.col length))\n\n                  (incr-by context.position length)\n                  (assign remaining-input (if remaining-input.length\n                                              (remaining-input.slice length)\n                                              \"\"))))\n     context.stack)\n\n(var parse parser.parse)\n"]}