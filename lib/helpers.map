{"version":3,"sources":["/Users/jbr/code/sibilant/src/helpers.sibilant","/Users/jbr/code/sibilant/include/macros.sibilant"],"names":[],"mappings":"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","sourcesContent":["(def recurse-indent (...args)\n     (map args\n          (#(arg)\n            (if (node? arg) (merge-into arg { contents (apply recurse-indent (compact (flatten arg.contents))) })\n                (list? arg) (apply recurse-indent arg)\n                (number? arg) (arg.to-string)\n\n                (string? arg)\n                (chain arg\n                       (replace (regex \"\\\\n\" 'g) \"\\n  \")\n                       (replace (regex \"\\\\n\\\\s+\\\\n\" 'g) \"\\n\\n\"))\n\n                 arg))))\n\n(def indent (...args)\n     [\"\\n  \" (recurse-indent args) \"\\n\"])\n\n(def escape-regex (string)\n     (string.replace (regex \"[\\\\-\\\\[\\\\]\\\\/\\\\{\\\\}\\\\(\\\\)\\\\*\\\\+\\\\?\\\\.\\\\\\\\\\^\\\\$\\\\|]\" 'g) \"\\\\$&\"))\n\n(def qescape (content)\n     (if (not (exists? content)) \"\"\n         (string? content) (chain content\n                                  (replace (regex \"\\\"\" 'g) \"\\\\\\\"\")\n                                  (replace (regex \"\\\\n\" 'g) \"\\\\n\\\" +\\n\\\"\"))\n         content))\n\n(def map-node (node fn)\n     (if (node? node)\n         (do\n          (var mapped-node (fn node))\n          (when (node? mapped-node)\n                (set mapped-node 'contents (map-node mapped-node.contents fn)))\n\n          mapped-node)\n\n         (list? node) (map node (#> (map-node #0 fn)))\n         (fn node)))\n\n(def each-node (node fn)\n     (if (node? node) (when (fn node) (each-node node.contents fn))\n         (list? node) (each (c) node (each-node c fn))\n         (fn node)))\n\n(def statement? (transpiled)\n     (if (node? transpiled) (statement? transpiled.contents)\n         (list? transpiled) (statement? (last transpiled))\n         (string? transpiled) (= \";\" (last transpiled))\n         false))\n\n(def as-statement (node)\n     (var transpiled (transpile node))\n\n     (if (empty-node? transpiled) undefined\n         (statement? transpiled) transpiled\n         [ transpiled \";\" ]))\n\n(def unquote? (node) (node? node 'at))\n\n(def find-unquotes (node)\n     (var unquotes {})\n     (each-node node (#(n)\n                       (when (unquote? n)\n                             (set unquotes n.node-id (transpile n)))\n                       (not (node? n 'tick))))\n     unquotes)\n\n(def splice-dots (node)\n     (when (and node (list? node.contents))\n           (var contents [])\n           (each (content) node.contents\n                 (if (and (node? content 'dots)\n                          (list? content.contents)\n                          (= content.contents.length 1)\n                          (list? (first content.contents)))\n                      (contents.push.apply contents (first content.contents))\n                      (contents.push content)))\n\n           (set node 'contents contents))\n     node)\n\n\n(def alternating-keys-and-values (hash)\n     (flatten (map (keys hash)\n                   (#(key) [key, (get hash key)]))))\n\n\n(def map-node-for-quote-expansion (node expansions)\n     (if (node? node)\n         (do\n          (var mapped-node (if (expansions.has-own-property node.node-id) (get expansions node.node-id) (clone node)))\n          (when (node? mapped-node)\n                (set mapped-node 'contents (map-node-for-quote-expansion mapped-node.contents expansions)))\n\n          (assign mapped-node (splice-dots mapped-node))\n          mapped-node)\n\n         (list? node)\n           (map node (#> (map-node-for-quote-expansion #0 expansions)))\n\n         node))\n\n","(namespace core)\n\n(macro ternary (cond if-true if-false)\n       [\"(\" (transpile cond) \") ? \"\n            (transpile if-true) \" : \"\n            (transpile if-false)])\n\n(macro join (glue arr)\n       [\"(\" (transpile arr) \").join(\" (transpile glue) \")\"])\n\n(macro set (arr ...kv-pairs)\n       (interleave \"\\n\" (bulk-map kv-pairs\n                                  (#(k v)\n                                    (as-statement [\"(\" (transpile arr) \")\"\n                                                    \"[\" (transpile k) \"] = \" (transpile v) ])))))\n\n(macro var (...pairs)\n       (as-statement\n        [\"var \"\n         (interleave \",\\n    \"\n               (bulk-map pairs\n                         (#(name value)\n                           [ (transpile name) \" = \" (transpile value) ])))\n         ]))\n\n(macro get (obj ...keys)\n       [\"(\" (transpile obj) \")\" (map keys (#(key)\n                                            [\"[\" (transpile key) \"]\"]))])\n\n(macro alias-macro (current-macro-name desired-macro-name)\n       (var current-macro-name (output-formatter (transpile current-macro-name))\n            desired-macro-name (output-formatter (transpile desired-macro-name)))\n       (set sibilant.macros.namespace\n            desired-macro-name (get sibilant.macros.namespace current-macro-name))\n       null)\n\n(macro send (object method ...args)\n       [(transpile object) \".\" (transpile method)\n               \"(\" (interleave \", \" (map args transpile)) \")\"])\n\n(macro apply (fn arglist)\n       '(.apply @fn this @arglist))\n\n(macro cons (first rest)\n       [\"[ \" (transpile first) \" ].concat(\" (transpile rest) \")\"])\n\n(macro append (list ...additional)\n       '(.concat @list (list ...@additional)))\n\n(macro length (arr)\n       '(get @arr 'length))\n\n(macro first (arr) '(get @arr 0))\n(macro second (arr) '(get @arr 1))\n(macro third (arr) '(get @arr 2))\n(macro fourth (arr) '(get @arr 3))\n(macro fifth (arr) '(get @arr 4))\n(macro sixth (arr) '(get @arr 5))\n(macro seventh (arr) '(get @arr 6))\n(macro eighth (arr) '(get @arr 7))\n(macro ninth (arr) '(get @arr 8))\n(macro rest (arr) '(.slice @arr 1))\n\n(macro last (arr) '(first (.slice @arr -1)))\n\n\n(macro = (a b) [ (transpile a) \" === \" (transpile b) ])\n(macro +   (...args)\n       [\"(\" (interleave \" + \" (map args transpile)) \")\"])\n(macro -   (...args)\n       [\"(\" (interleave \" - \" (map args transpile)) \")\"])\n(macro *   (...args)\n       [\"(\" (interleave \" * \" (map args transpile)) \")\"])\n(macro /   (...args)\n           [\"(\" (interleave \" / \" (map args transpile)) \")\"])\n(macro or  (...args)\n       [\"(\" (interleave \" || \" (map args transpile)) \")\"])\n\n(macro and (...args)\n       (ternary (= 1 (length args)) (transpile (first args))\n                [\"(\" (interleave \" && \" (map args transpile)) \")\"]))\n\n(macro mod (...args)\n       [\"(\" (interleave \" % \" (map args transpile)) \")\"])\n\n(macro infix-comparator (comparator args)\n       [\"(\" (interleave \" && \"\n                  (map (args.slice 0 -1)\n                       (#(item index)\n                         [ item \" \" comparator \" \" (get args (+ 1 index))])))\n            \")\"])\n\n(macro >  (...args) (^infix-comparator  \">\"  (map args transpile)))\n(macro <  (...args) (^infix-comparator  \"<\"  (map args transpile)))\n(macro <= (...args) (^infix-comparator \"<=\"  (map args transpile)))\n(macro >= (...args) (^infix-comparator \">=\"  (map args transpile)))\n(macro != (...args) (^infix-comparator \"!==\" (map args transpile)))\n\n(macro pow (base exponent)\n       '(Math.pow @base @exponent))\n\n(macro incr-by (item increment)\n       [ (transpile item) \" += \" (transpile increment)])\n\n(macro incr (item)\n       [\"((\" (transpile item) \")++)\"])\n\n(macro decr (item)\n       [\"((\" (transpile item) \")--)\"])\n\n(macro new (...args)\n       [\"(new \" '(call ...@args) \")\"])\n\n(macro regex (string glim)\n       '(new RegExp @string @(or glim 'undefined)))\n\n(macro timestamp ()\n       [\"\\\"\" (.to-string (new Date)) \"\\\"\"])\n\n(macro zero? (item) '(= @item 0))\n\n(macro empty? (arr)\n       [\"((\" (transpile arr) \").length === 0)\"])\n\n(macro odd? (number)\n       '(= 1 (mod @number 2)))\n\n(macro even? (number)\n       '(= 0 (mod @number 2)))\n\n(macro typeof (thing) [\"typeof \" (transpile thing)])\n\n\n(macro function? (...things)\n       '(and ...@(map things (#(thing) '(= (typeof @thing) 'function)))))\n(macro undefined? (...things)\n       '(and ...@(map things (#(thing) '(= (typeof @thing) 'undefined)))))\n(macro defined? (...things)\n       '(and ...@(map things (#(thing) '(!= (typeof @thing) 'undefined)))))\n(macro number? (...things)\n       '(and ...@(map things (#(thing) '(= (typeof @thing) 'number)))))\n\n(macro if (arg truebody falsebody)\n       [\"(function() {\"\n        (indent [\"if (\" (transpile arg) \") {\"\n                        (indent '(do ...@truebody))\n                        \"} else {\"\n                        (indent '(do ...@falsebody))\n                        \"}\"])\n         \"})()\"])\n\n(macro pipe (...calls)\n       (inject undefined calls\n         (#(value item)\n           (var cloned (clone item))\n           (if (undefined? value)\n               cloned\n               (merge-into cloned\n                           { contents [ (first cloned.contents)\n                                        value\n                                        ...(rest cloned.contents) ] })))))\n\n(macro comment (...contents)\n       (map contents (#(content)\n                       [\"// \"(recurse-map (transpile content)\n                                    (#(item)\n                                      (ternary item\n                                               (pipe item\n                                                     (transpile)\n                                                     (output-formatter)\n                                                     (.replace (regex \"\\n\" 'g) \"\\n// \"))\n                                               null)))])))\n\n(macro = (first-thing ...other-things)\n       (var transpiled-first-thing (transpile first-thing))\n       [\"(\" (interleave \" &&\\n \"\n                  (map other-things\n                       (#(thing)\n                         [ transpiled-first-thing\n                                 \" === \"\n                                 (transpile thing) ])))\n            \")\"])\n\n\n(macro string? (thing)\n       [\"typeof(\" (transpile thing) \") === \\\"string\\\"\"])\n\n(macro list? (thing)\n       (var transpiled (transpile thing))\n       [\"((\" transpiled \") && typeof (\" transpiled \") === \\\"object\\\" && (\"\n               transpiled \").constructor.name === \\\"Array\\\")\"])\n\n\n(macro when (arg ...body)\n       [\"(function() {\"\n        (indent [\"if (\" (transpile arg) \") {\"\n                        (indent '(do ...@body))\n                        \"}\"])\n        \"})()\"])\n\n\n(macro not (exp)\n       [\"(!\" (transpile exp) \")\"])\n\n(macro unless (arg ...body)\n       [\"(function() {\"\n        (indent [\"if (\" '(not @arg) \") {\"\n                        (indent '(do ...@body))\n                        \"}\"])\n        \"})()\"])\n\n\n(macro slice (arr start end)\n       '(.slice @arr @start @end))\n\n(macro inspect (...args)\n       (interleave \" + \\\"\\\\n\\\" + \"\n             (map args\n                  (#(arg)\n                    [\"\\\"\" arg \":\\\" + \" (transpile arg)]))))\n\n(macro each (item array ...body)\n       '(.for-each @array\n              (lambda @{ node this args item } ...@body)))\n\n(macro assign (...args)\n       (interleave \"\\n\"\n             (bulk-map args (#(name value)\n                              (as-statement [ (transpile name) \" = \"\n                                                    (transpile value)])))))\n\n\n\n(macro macro-expand (name)\n       (var macro (get macros (output-formatter (transpile name))))\n       (if macro\n           (macro.to-string)\n           \"undefined\"))\n\n(macro throw (...string)\n       [\"throw new Error (\" (interleave \" \" (map string transpile)) \")\"])\n\n(macro as-boolean (expr)\n       [\"(!!(\" (transpile expr) \"))\"])\n\n(macro try (tryblock catchblock)\n       [\"(function() {\"\n        (indent [\"try {\"\n                 (indent '(do @tryblock))\n                 \"} catch (e) {\"\n                 (indent '(do @catchblock))\n                 \"}\"])\n         \"})()\"])\n\n(macro log-pretty (label arg)\n       (var node this)\n       (when (undefined? arg)\n             (assign arg label\n                     label [\"\\\"\" (prettify label false) \"\\\"\"]))\n       `(console.log (concat @[\"\\\"\" node.file \":\" node.line \"\\\"\"] \" \" @label \" = \" (prettify @arg))))\n(alias-macro log-pretty pretty-log)\n\n\n(macro state (...pairs)\n       (if (= 1 (length pairs))\n           (get sibilant.state (output-formatter (transpile (first pairs))))\n           (do (bulk-map pairs (#(k v) (set sibilant.state (output-formatter (transpile k)) (eval (output-formatter (transpile v))))))\n               null)))\n\n(macro symbol ()\n       (var symbol-count (or (get sibilant.state 'symbol-count) 0)\n            new-symbol-count (+ 1 symbol-count))\n       (^state 'symbol-count new-symbol-count)\n       [\"$_symbol\" new-symbol-count \"_$\"])\n\n(macro while (condition ...block)\n       (var symbol (^symbol))\n       '(scoped-without-source\n         (var @symbol)\n         @[\"while (\" (transpile condition) \") {\"\n           (indent '(assign @symbol (scoped-without-source ...@block)))\n            \"}\"]\n         @symbol))\n\n(macro until (condition ...block)\n       '(while (not @condition) ...@block))\n\n(macro match? (regexp string)\n       '(.match @string @regexp))\n\n(macro match-regex? (string regexp-string glim)\n       '(match? (regex @regexp-string @glim) @string))\n\n(macro replace (string regexp-string replacement)\n       '(.replace @string\n              (regex @regexp-string)\n              @replacement))\n\n(macro replace-all (string regexp-string replacement)\n       '(.replace @string (regex @regexp-string 'g) @replacement))\n\n(macro thunk (...body)\n       '(lambda @{ node this args [] }\n       ...@(map-node body\n                 (#(node)\n                   (if (node? node 'arg-placeholder)\n                       '(argument @(replace node.token \"^#\" \"\"))\n                       node)))))\n(alias-macro thunk #>)\n\n(macro keys (obj)\n       '(Object.keys @obj))\n\n(macro delete (...objects)\n       (interleave \"\\n\" (map objects (#(obj)\n                                 (as-statement [\"delete \" (transpile obj)])))))\n\n(macro delmacro (...macro-names)\n       (each (macro-name) macro-names\n             (delete (get sibilant.macros.namespace (output-formatter (transpile macro-name)))))\n       null)\n(alias-macro delmacro delete-macro)\n\n\n(macro rename-macro (current-macro-name desired-macro-name)\n       (^alias-macro current-macro-name desired-macro-name)\n       (^delmacro current-macro-name)\n       null)\n\n(macro arguments ()\n       [\"(Array.prototype.slice.apply(arguments))\"])\n\n(macro argument (n)\n       '(get arguments @n))\n\n(macro scoped (...body)\n       '(call (lambda @{node this args []} ...@body)))\n\n(macro scoped-without-source (...body)\n       [\"(function() {\" (indent '(do ...@body)) \"})()\"])\n       \n\n(macro each-key (as obj ...body)\n       '(scoped-without-source\n         @[\"for (var \" (transpile as) \" in \" (transpile obj) \") \"\n            (as-statement '(scoped-without-source ...@body))\n            ]\n         @obj))\n\n(macro switch (obj ...cases)\n       [\"(function() {\"\n         (indent [\"switch(\" (transpile obj) \") {\"\n                   (map cases (#(case-def)\n                                (var case-name-node (first case-def.contents)\n                                     case-labels (if (node? case-name-node 'expression 'bracket)\n                                                     case-name-node.contents\n                                                     [case-name-node])\n                                     case-string (interleave \"\\n\" (map case-labels (#(c)\n                                                                                     (if (= 'default c.token)\n                                                                                         \"default:\"\n                                                                                         [\"case \" (transpile c) \":\"])))))\n                                [\"\\n\" case-string (indent '(do ...@(rest case-def.contents)))]))\n                   \"}\"])\n         \"})()\"])\n\n(macro if (...args)\n       [\"(function() {\"\n        (indent\n         (interleave \" else \"\n               (bulk-map args\n                         (#(cond val)\n                           (if (!= (typeof val) 'undefined)\n                                 [\"if (\" (transpile cond) \") {\"\n                                   (indent '(do @val))\n                                   \"}\"]\n                                 [\"{\" (indent '(do @cond)) \"}\"])))))\n        \"})()\"])\n\n(macro chain (object ...calls)\n       (if (= 0 calls.length) (transpile object)\n           (= 1 calls.length) '(send @object ...@(get (first calls) 'contents))\n           (do\n            (var lines (map calls (#(call index)\n                                    [\".\" (transpile (first call.contents))\n                                         \"(\" (interleave \", \" (map (rest call.contents) transpile)) \")\"])))\n\n            [ (transpile object)\n              (first lines)\n              \"\\n  \"\n              (recurse-indent\n               (interleave \"\\n\" (rest lines)))])))\n\n(macro chainable (...names)\n       (each (name) names\n             '(macro @name (target ...calls)\n                     '(chain (call @name @target) ...@calls))))\n\n(macro let (args body)\n       [\"let (\"\n         (interleave \", \" (bulk-map args\n                   (#(k v)\n                     [ (transpile k) \" = \" (transpile v) ])))\n         (if (undefined? body) \");\"\n             [\") {\" (indent (transpile body)) \"}\"])])\n\n(macro instance-of? (item type)\n       [\"(\" (transpile item) \" instanceof \" (transpile type) \")\"])\n\n(macro slice (list begin end)\n       [\"Array.prototype.slice.call(\" (transpile list)\n                                      \", \" (or (transpile begin) 0)\n                                      (if (defined? end) (\", \" (transpile end) \")\") \")\")])\n\n(macro includes? (list item)\n       '(pipe @list (.index-of @item) (!= -1)))\n\n(macro excludes? (list item)\n       '(pipe @list (.index-of @item) (= -1)))\n\n(macro exists? (thing)\n       '(and (defined? @thing) (!= @thing null)))\n\n(macro with-state (k v ...body)\n       (var before (^state k))\n       (^state k v)\n       (var return-value\n            (interleave \"\\n\" (map body transpile)))\n       (^state k before)\n       return-value)\n\n(macro join (glue arr)\n       (if (and (defined? glue) (undefined? arr))\n           (assign arr glue glue undefined))\n       [\"(\" (transpile arr) \").join(\" (if glue (transpile glue) \"\\\"\\\"\") \")\"])\n\n(macro var (...pairs)\n       (var destructured [])\n       (bulk-map pairs (#(lhs rhs)\n                         (switch lhs.type\n                                 ('bracket\n                                  (var symbol (^symbol))\n                                  (destructured.push [symbol (transpile rhs)])\n                                  (each (item index) lhs.contents\n                                        (destructured.push [(transpile item) '(get @symbol @index)]))\n                                  (destructured.push [symbol 'undefined]))\n                                 ('brace\n                                  (var symbol (^symbol))\n                                  (destructured.push [symbol (transpile rhs)])\n                                  (each (item index) lhs.contents\n                                        (var tr-item (transpile item))\n                                        (destructured.push [tr-item '(get @symbol @[\"\\\"\" tr-item \"\\\"\"])]))\n                                  (destructured.push [symbol 'undefined]))\n\n                                 (default\n                                  (destructured.push [(transpile lhs)\n                                                       (if rhs (transpile rhs) 'undefined)])))))\n\n       (as-statement\n        [\"var \" (interleave \",\\n    \"\n           (map destructured\n                (#(pair)\n                  [(first pair) \" = \" (second pair)]\n                  )))]))\n\n(macro default (...pairs)\n       (interleave \"\\n\" (bulk-map pairs (#(name value)\n                                  '(assign @name (ternary (defined? @name) @name @value))))))\n\n\n(macro import-namespace (namespace)\n       (var namespace-as-string (output-formatter (transpile namespace)))\n       (unless (sibilant.macros.namespaces.has-own-property namespace-as-string)\n               (set sibilant.macros.namespaces namespace-as-string {}))\n       (sibilant.macros.search-path.unshift namespace-as-string)\n       undefined)\n\n(macro namespace (namespace)\n       `(import-namespace @namespace)\n       (set sibilant.macros 'namespace (get sibilant.macros.namespaces (output-formatter (transpile namespace))))\n       undefined)\n\n(macro has-key? (object key)\n       `(.has-own-property @object @key))\n\n(macro get (obj ...keys)\n       [(transpile obj)\n         (map keys (#(key)\n                     (var transpiled (transpile key)\n                          output (output-formatter transpiled))\n\n                     (if (match-regex? output \"^\\\"[a-zA-Z0-9]+\\\"$\")\n                         [\".\" (replace-all output \"\\\"\" \"\") ]\n                         [\"[\" transpiled \"]\"])))])\n\n(macro set (arr ...kv-pairs)\n       (interleave \"\\n\" (bulk-map kv-pairs (#(k v) `(assign (get @arr @k) @v)))))\n\n\n"]}