{"version":3,"sources":["/Users/jbr/code/sibilant/src/transpiler.sibilant","/Users/jbr/code/sibilant/include/macros.sibilant"],"names":[],"mappings":"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","sourcesContent":[";; (def flatten-output (nodes)\n;;      (inject [] nodes\n;;              (#(collector item)\n;;                (if (list? item) (apply flatten-output item)\n;;                   (if \n                                \n\n(def node? (thing type)\n     (and\n      (exists? thing)\n      (= 'object (typeof thing))\n      (string? thing.type)\n      (or (undefined? type) (= thing.type type))\n      (thing.has-own-property 'contents)))\n\n(def empty-node? (item)\n     (if (node? item) (empty-node? item.contents)\n         (list? item) (all? item empty-node?)\n         (string? item) (item.match (regex \"^\\\\s*$\"))\n         (or (= null item)\n             (undefined? item)\n             (= false item))))\n\n(def compact-node (item)\n     (if (node? item) (do\n                       (set item 'contents (compact-node item.contents))\n                       (if (and item.contents item.contents.length) item null))\n         (list? item) (do\n                       (var compacted (compact (map item compact-node)))\n                       (if (and compacted compacted.length) compacted null))\n         (if (or (= item \"\") (= item false)) null item)))\n\n(def recurse-transpile (node)\n     (if (list? node) (map node recurse-transpile)\n         (and (node? node) (!= 'output node.type)) (transpile node)\n         (and (node? node) (= 'output node.type)) (do\n                                                   (set node 'contents (recurse-transpile node.contents))\n                                                   node)\n         node))\n\n(def transpile (node preprocessor)\n     (if\n      (string? node)\n      (assign node { type 'js token node contents []})\n\n      (number? node)\n      (assign node { type 'number token (node.to-string) contents []}))\n     \n     (if (list? node) node\n         (exists? node) (do\n                         (var transpiler (or (get transpile node.type) transpile.default))\n                         (var result (transpiler node))\n                         (var result-node (recurse-transpile (if (node? result) result\n                                              { contents result type 'output })))\n                         (set result-node\n                              'contents (compact (flatten result-node.contents))\n                              'source node)\n\n                         (when sibilant.debug\n                               (console.log (prettify node)\n                                            (red \"->\")\n                                            (prettify result-node)))\n\n                         (set node 'transpiled result-node)\n\n                         \n                         (if (empty-node? result-node) undefined\n                             result-node))))\n\n\n(set sibilant 'transpile transpile)\n\n(var reader-macros {})\n\n(def transpile.hat (node)\n     (var output (transpile (first node.contents)))\n     (set output 'contents [(\"macros.\" (first output.contents))])\n     output)\n\n(def transpile.tick (node)\n     (^quote.apply node node.contents))\n\n(def transpile.at (node)\n     (transpile (first node.contents)))\n\n(def transpile.dots (node)\n     (^dots.apply node node.contents))\n\n\n(def transpile.default (node)\n     node.token)\n\n(def transpile.output (node)\n     node)\n\n(def transpile.number (node)\n     (send (parse-float (node.token.replace (regex \",\" 'g) \"\")) to-string))\n\n(def transpile.root (node)\n     (if (= 1 node.contents.length)\n         (transpile (first node.contents))\n         (interleave \"\\n\" (compact (map node.contents as-statement)))))\n\n(def transpile.expression (node preprocessor)\n     (if node.contents.length\n         (do\n          (var head (first node.contents)\n               args (rest node.contents)\n               macro (get macros (output-formatter (transpile head))))\n\n          (when (exists? macro) (set head 'hint 'macro))\n\n          (when (and head (= 'string head.type))\n                (assign macro macros.concat args node.contents))\n\n          (when (undefined? macro)\n                (assign macro macros.call args node.contents))\n\n          (macro.apply node args))\n\n         \"null\"))\n\n(def transpile.bracket (node)\n     (apply macros.list node.contents))\n\n(def transpile.brace (node) (apply macros.hash node.contents))\n\n(def transpile.literal (node)\n     (var string node.token)\n     (inject (chain string\n                    (replace (regex \"\\\\*\" 'g) \"_\")\n                    (replace (regex \"\\\\?$\") \"__QUERY\")\n                    (replace (regex \"!$\") \"__BANG\"))\n             (string.match (regex \"-(.)\" 'g))\n             (#(return-string match)\n               (return-string.replace match\n                                      (send (second match) to-upper-case)))))\n\n(def transpile.string (node)\n     (chain node.token (split \"\\n\")\n            (join \"\\\\n\\\" +\\n\\\"\")))\n\n(def transpile.comment (node) null)\n\n","(macro join (glue arr)\n       [\"(\" (transpile arr) \").join(\" (transpile glue) \")\"])\n\n(macro set (arr ...kv-pairs)\n       (interleave \"\\n\" (bulk-map kv-pairs\n                                  (#(k v)\n                                    (as-statement [\"(\" (transpile arr) \")\"\n                                                    \"[\" (transpile k) \"] = \" (transpile v) ])))))\n\n(macro get (obj ...keys)\n       [\"(\" (transpile obj) \")\" (map keys (#(key) [\"[\" (transpile key) \"]\"]))])\n\n(macro var (...pairs)\n       (as-statement\n        [\"var \"\n         (interleave \",\\n    \"\n               (bulk-map pairs\n                         (#(name value)\n                           [ (transpile name) \" = \" (transpile value) ])))\n         ]))\n\n(macro alias-macro (current-macro-name desired-macro-name)\n       (var current-macro-name (output-formatter (transpile current-macro-name))\n            desired-macro-name (output-formatter (transpile desired-macro-name)))\n       (set macros desired-macro-name (get macros current-macro-name))\n       null)\n\n(macro send (object method ...args)\n       [(transpile object) \".\" (transpile method)\n               \"(\" (interleave \", \" (map args transpile)) \")\"])\n\n(macro apply (fn arglist)\n       '(send @fn apply this @arglist))\n\n(macro cons (first rest)\n       [\"[ \" (transpile first) \" ].concat(\" (transpile rest) \")\"])\n\n(macro append (list ...additional)\n       '(send @list concat (list ...@additional)))\n\n(macro length (arr)\n       '(get @arr 'length))\n\n(macro ternary (cond if-true if-false)\n       [\"(\" (transpile cond) \") ? \"\n            (transpile if-true) \" : \"\n            (transpile if-false)])\n\n(macro first (arr) '(get @arr 0))\n(macro second (arr) '(get @arr 1))\n(macro third (arr) '(get @arr 2))\n(macro fourth (arr) '(get @arr 3))\n(macro fifth (arr) '(get @arr 4))\n(macro sixth (arr) '(get @arr 5))\n(macro seventh (arr) '(get @arr 6))\n(macro eighth (arr) '(get @arr 7))\n(macro ninth (arr) '(get @arr 8))\n(macro rest (arr)\n       '(send @arr slice 1))\n\n(macro last (arr)\n       '(first (send @arr slice -1)))\n\n\n(macro = (a b) [ (transpile a) \" === \" (transpile b) ])\n(macro +   (...args)\n       [\"(\" (interleave \" + \" (map args transpile)) \")\"])\n(macro -   (...args)\n       [\"(\" (interleave \" - \" (map args transpile)) \")\"])\n(macro *   (...args)\n       [\"(\" (interleave \" * \" (map args transpile)) \")\"])\n(macro /   (...args)\n           [\"(\" (interleave \" / \" (map args transpile)) \")\"])\n(macro or  (...args)\n       [\"(\" (interleave \" || \" (map args transpile)) \")\"])\n\n(macro and (...args)\n       (ternary (= 1 (length args)) (transpile (first args))\n                [\"(\" (interleave \" && \" (map args transpile)) \")\"]))\n\n(macro mod (...args)\n       [\"(\" (interleave \" % \" (map args transpile)) \")\"])\n\n(macro infix-comparator (comparator args)\n       [\"(\" (interleave \" && \"\n                  (map (args.slice 0 -1)\n                       (#(item index)\n                         [ item \" \" comparator \" \" (get args (+ 1 index))])))\n            \")\"])\n\n(macro >  (...args) (macros.infix-comparator  \">\"  (map args transpile)))\n(macro <  (...args) (macros.infix-comparator  \"<\"  (map args transpile)))\n(macro <= (...args) (macros.infix-comparator \"<=\"  (map args transpile)))\n(macro >= (...args) (macros.infix-comparator \">=\"  (map args transpile)))\n(macro != (...args) (macros.infix-comparator \"!==\" (map args transpile)))\n\n(macro pow (base exponent)\n       '(Math.pow @base @exponent))\n\n(macro incr-by (item increment)\n       [ (transpile item) \" += \" (transpile increment)])\n\n(macro incr (item)\n       [\"((\" (transpile item) \")++)\"])\n\n(macro decr (item)\n       [\"((\" (transpile item) \")--)\"])\n\n(macro new (...args)\n       [\"(new \" '(call ...@args) \")\"])\n\n(macro regex (string glim)\n       '(new RegExp @string @(or glim 'undefined)))\n\n(macro timestamp ()\n       [\"\\\"\" (send (new Date) to-string) \"\\\"\"])\n\n(macro comment (...contents)\n       (map contents (#(content)\n                       [\"// \"(recurse-map (transpile content)\n                                    (#(item)\n                                      (ternary item\n                                               (send (output-formatter (transpile item)) replace\n                                                     (regex \"\\n\" 'g) \"\\n// \")\n                                               null)))])))\n\n(macro meta (body)\n       (eval (output-formatter (transpile body))))\n\n(macro zero? (item) '(= @item 0))\n\n(macro empty? (arr)\n       [\"((\" (transpile arr) \").length === 0)\"])\n\n(macro odd? (number)\n       '(= 1 (mod @number 2)))\n\n(macro even? (number)\n       '(= 0 (mod @number 2)))\n\n(macro typeof (thing) [\"typeof \" (transpile thing)])\n\n\n(macro function? (...things)\n       '(and ...@(map things (#(thing) '(= (typeof @thing) 'function)))))\n(macro undefined? (...things)\n       '(and ...@(map things (#(thing) '(= (typeof @thing) 'undefined)))))\n(macro defined? (...things)\n       '(and ...@(map things (#(thing) '(!= (typeof @thing) 'undefined)))))\n(macro number? (...things)\n       '(and ...@(map things (#(thing) '(= (typeof @thing) 'number)))))\n\n(macro if (arg truebody falsebody)\n       [\"(function() {\"\n        (indent [\"if (\" (transpile arg) \") {\"\n                        (indent '(do ...@truebody))\n                        \"} else {\"\n                        (indent '(do ...@falsebody))\n                        \"}\"])\n         \"})()\"])\n\n(macro = (first-thing ...other-things)\n       (var transpiled-first-thing (transpile first-thing))\n       [\"(\" (interleave \" &&\\n \"\n                  (map other-things\n                       (#(thing)\n                         [ transpiled-first-thing\n                                 \" === \"\n                                 (transpile thing) ])))\n            \")\"])\n\n\n(macro string? (thing)\n       [\"typeof(\" (transpile thing) \") === \\\"string\\\"\"])\n\n(macro list? (thing)\n       (var transpiled (transpile thing))\n       [\"((\" transpiled \") && typeof (\" transpiled \") === \\\"object\\\" && (\"\n               transpiled \").constructor.name === \\\"Array\\\")\"])\n\n\n(macro when (arg ...body)\n       [\"(function() {\"\n        (indent [\"if (\" (transpile arg) \") {\"\n                        (indent '(do ...@body))\n                        \"}\"])\n        \"})()\"])\n\n\n(macro not (exp)\n       [\"(!\" (transpile exp) \")\"])\n\n(macro unless (arg ...body)\n       [\"(function() {\"\n        (indent [\"if (\" '(not @arg) \") {\"\n                        (indent '(do ...@body))\n                        \"}\"])\n        \"})()\"])\n\n\n(macro slice (arr start end)\n       '(send @arr slice @start @end))\n\n(macro inspect (...args)\n       (interleave \" + \\\"\\\\n\\\" + \"\n             (map args\n                  (#(arg)\n                    [\"\\\"\" arg \":\\\" + \" (transpile arg)]))))\n\n(macro each (item array ...body)\n       '(send @array for-each\n              (lambda @{ node this args item } ...@body)))\n\n(macro assign (...args)\n       (interleave \"\\n\"\n             (bulk-map args (#(name value)\n                              (as-statement [ (transpile name) \" = \"\n                                                    (transpile value)])))))\n\n\n\n(macro macro-expand (name)\n       (var macro (get macros (output-formatter (transpile name))))\n       (if macro\n           (macro.to-string)\n           \"undefined\"))\n\n(macro throw (...string)\n       [\"throw new Error (\" (interleave \" \" (map string transpile)) \")\"])\n\n(macro as-boolean (expr)\n       [\"(!!(\" (transpile expr) \"))\"])\n\n(macro try (tryblock catchblock)\n       [\"(function() {\"\n        (indent [\"try {\"\n                 (indent '(do @tryblock))\n                 \"} catch (e) {\"\n                 (indent '(do @catchblock))\n                 \"}\"])\n        \"})()\"])\n\n(macro state (...pairs)\n       (set macros.state 'data (or macros.state.data {}))\n\n       (if (= 1 (length pairs))\n           (get macros.state.data (output-formatter (transpile (first pairs))))\n           (do (bulk-map pairs (#(k v) (set macros.state.data (output-formatter (transpile k)) (eval (output-formatter (transpile v))))))\n               null)))\n\n(macro symbol ()\n       (var symbol-count (or (macros.state 'symbol-count) 0)\n            new-symbol-count (+ 1 symbol-count))\n       (macros.state 'symbol-count new-symbol-count)\n       [\"$_symbol\" new-symbol-count \"_$\"])\n\n(macro while (condition ...block)\n       (var symbol (macros.symbol))\n       '(scoped-without-source\n         (var @symbol)\n         @[\"while (\" (transpile condition) \") {\"\n           (indent '(assign @symbol (scoped-without-source ...@block)))\n            \"}\"]\n         @symbol))\n\n(macro until (condition ...block)\n       '(while (not @condition) ...@block))\n\n(macro thunk (...body)\n       '(lambda @{ node this args [] } ...@body))\n(alias-macro thunk #>)\n\n(macro keys (obj)\n       '(Object.keys @obj))\n\n(macro delete (...objects)\n       (interleave \"\\n\" (map objects (#(obj)\n                                 (as-statement [\"delete \" (transpile obj)])))))\n\n(macro delmacro (...macro-names)\n       (each (macro-name) macro-names\n             (delete (get macros (output-formatter (transpile macro-name)))))\n       null)\n(alias-macro delmacro delete-macro)\n\n\n(macro rename-macro (current-macro-name desired-macro-name)\n       (macros.alias-macro current-macro-name desired-macro-name)\n       (macros.delmacro current-macro-name)\n       null)\n\n(macro arguments ()\n       [\"(Array.prototype.slice.apply(arguments))\"])\n\n(macro scoped (...body)\n       '(call (lambda @{node this args []} ...@body)))\n\n(macro scoped-without-source (...body)\n       [\"(function() {\" (indent '(do ...@body)) \"})()\"])\n       \n\n(macro each-key (as obj ...body)\n       '(scoped-without-source\n         @[\"for (var \" (transpile as) \" in \" (transpile obj) \") \"\n            (as-statement '(scoped-without-source ...@body))\n            ]\n         @obj))\n\n(macro match? (regexp string)\n       '(send @string match @regexp))\n\n(macro switch (obj ...cases)\n       [\"(function() {\"\n         (indent [\"switch(\" (transpile obj) \") {\"\n                   (map cases (#(case-def)\n                                (var case-name-node (first case-def.contents)\n                                     case-labels (if (or (node? case-name-node 'expression)\n                                                         (node? case-name-node 'bracket))\n                                                     case-name-node.contents\n                                                     [case-name-node])\n                                     case-string (interleave \"\\n\" (map case-labels (#(c)\n                                                                                     (if (= 'default c.token)\n                                                                                         \"default:\"\n                                                                                         [\"case \" (transpile c) \":\"])))))\n                                [\"\\n\" case-string (indent '(do ...@(rest case-def.contents)))]))\n                   \"}\"])\n         \"})()\"])\n\n(macro if (...args)\n       [\"(function() {\"\n        (indent\n         (interleave \" else \"\n               (bulk-map args\n                         (#(cond val)\n                           (if (!= (typeof val) 'undefined)\n                                 [\"if (\" (transpile cond) \") {\"\n                                   (indent '(do @val))\n                                   \"}\"]\n                                 [\"{\" (indent '(do @cond)) \"}\"])))))\n        \"})()\"])\n\n(macro chain (object ...calls)\n       (if (= 0 calls.length) (transpile object)\n           (= 1 calls.length) '(send @object ...@(get (first calls) 'contents))\n           (do\n            (var lines (map calls (#(call index)\n                                    [\".\" (transpile (first call.contents))\n                                         \"(\" (interleave \", \" (map (rest call.contents) transpile)) \")\"])))\n\n            [ (transpile object)\n              (first lines)\n              \"\\n  \"\n              (recurse-indent\n               (interleave \"\\n\" (rest lines)))])))\n\n(macro chainable (...names)\n       (each (name) names\n             '(macro @name (target ...calls)\n                     '(chain (call @name @target) ...@calls))))\n\n(macro let (args body)\n       [\"let (\"\n         (interleave \", \" (bulk-map args\n                   (#(k v)\n                     [ (transpile k) \" = \" (transpile v) ])))\n         (if (undefined? body) \");\"\n             [\") {\" (indent (transpile body)) \"}\"])])\n\n(macro instance-of? (item type)\n       [\"(\" (transpile item) \" instanceof \" (transpile type) \")\"])\n\n(macro slice (list begin end)\n       [\"Array.prototype.slice.call(\" (transpile list)\n                                      \", \" (or (transpile begin) 0)\n                                      (if (defined? end) (\", \" (transpile end) \")\") \")\")])\n\n(macro includes? (list item)\n       '(!= -1 (send @list index-of @item)))\n\n(macro excludes? (list item)\n       '(= -1 (send @list index-of @item)))\n\n(macro exists? (thing)\n       '(and (defined? @thing) (!= @thing null)))\n\n(macro with-state (k v ...body)\n       (var before (macros.state k))\n       (macros.state k v)\n       (var return-value\n            (interleave \"\\n\" (map body transpile)))\n       (macros.state k before)\n       return-value)\n\n(macro join (glue arr)\n       (if (and (defined? glue) (undefined? arr))\n           (assign arr glue glue undefined))\n       [\"(\" (transpile arr) \").join(\" (if glue (transpile glue) \"\\\"\\\"\") \")\"])\n\n(macro var (...pairs)\n       (var destructured [])\n       (bulk-map pairs (#(lhs rhs)\n                         (switch lhs.type\n                                 ('bracket\n                                  (var symbol (macros.symbol))\n                                  (destructured.push [symbol (transpile rhs)])\n                                  (each (item index) lhs.contents\n                                        (destructured.push [(transpile item) '(get @symbol @index)]))\n                                  (destructured.push [symbol 'undefined]))\n                                 ('brace\n                                  (var symbol (macros.symbol))\n                                  (destructured.push [symbol (transpile rhs)])\n                                  (each (item index) lhs.contents\n                                        (var tr-item (transpile item))\n                                        (destructured.push [tr-item '(get @symbol @[\"\\\"\" tr-item \"\\\"\"])]))\n                                  (destructured.push [symbol 'undefined]))\n\n                                 (default\n                                  (destructured.push [(transpile lhs)\n                                                       (if rhs (transpile rhs) 'undefined)])))))\n\n       (as-statement\n        [\"var \" (interleave \",\\n    \"\n           (map destructured\n                (#(pair)\n                  [(first pair) \" = \" (second pair)]\n                  )))]))\n\n\n(debug false)"]}