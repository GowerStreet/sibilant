{"version":3,"sources":["/Users/jbr/code/sibilant/src/transpiler.sibilant","/Users/jbr/code/sibilant-clean/include/macros.sibilant"],"names":[],"mappings":"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","sourcesContent":["(def node? (thing type)\n     (and\n      (exists? thing)\n      (= 'object (typeof thing))\n      (string? thing.type)\n      (or (undefined? type) (= thing.type type))\n      (thing.has-own-property 'contents)))\n\n(def empty-node? (item)\n     (if (node? item) (empty-node? item.contents)\n         (list? item) (all? item empty-node?)\n         (string? item) (item.match (regex \"^\\\\s*$\"))\n         (or (= null item)\n             (undefined? item)\n             (= false item))))\n\n(def compact-node (item)\n     (if (node? item) (do\n                       (set item 'contents (compact-node item.contents))\n                       (if (and item.contents item.contents.length) item null))\n         (list? item) (do\n                       (var compacted (compact (map item compact-node)))\n                       (if (and compacted compacted.length) compacted null))\n         (if (or (= item \"\") (= item false)) null item)))\n\n(def recurse-transpile (node)\n     (if (list? node) (map node recurse-transpile)\n         (and (node? node) (!= 'output node.type)) (transpile node)\n         (and (node? node) (= 'output node.type)) (do\n                                                   (set node 'contents (recurse-transpile node.contents))\n                                                   node)\n         node))\n\n(def transpile (node preprocessor)\n     (if\n      (string? node)\n      (assign node { type 'js token node contents []})\n\n      (number? node)\n      (assign node { type 'number token (node.to-string) contents []}))\n     \n     (if (list? node) node\n         (exists? node) (do\n                         (var transpiler (or (get transpile node.type) transpile.default))\n                         (var result (transpiler node))\n                         (var result-node (recurse-transpile (if (node? result) result\n                                              { contents result type 'output })))\n                         (set result-node\n                              'contents (compact (flatten result-node.contents))\n                              'source node)\n\n                         (when sibilant.debug\n                               (console.log (prettify node)\n                                            (red \"->\")\n                                            (prettify result-node)))\n\n                         (set node 'transpiled result-node)\n\n                         \n                         (if (empty-node? result-node) undefined\n                             result-node))))\n\n\n(set sibilant 'transpile transpile)\n\n(var reader-macros {})\n\n(def transpile.hat (node)\n     (var output (transpile (first node.contents)))\n     (set output 'contents [\"sibilant.macros.namespace[\\\"\" (first output.contents) \"\\\"]\"])\n     output)\n\n(def transpile.tick (node)\n     (sibilant.macros.namespaces.core.quote.apply node node.contents))\n\n(def transpile.at (node)\n     (transpile (first node.contents)))\n\n(def transpile.dots (node)\n     (sibilant.macros.namespaces.core.dots.apply node node.contents))\n\n(def transpile.default (node)\n     node.token)\n\n(def transpile.output (node)\n     node)\n\n(def transpile.number (node)\n     (send (parse-float (node.token.replace (regex \",\" 'g) \"\")) to-string))\n\n(def transpile.root (node)\n     (if (= 1 node.contents.length)\n         (transpile (first node.contents))\n         (interleave \"\\n\" (compact (map node.contents as-statement)))))\n\n(def transpile.expression (node preprocessor)\n     (if node.contents.length\n         (do\n          (var head (first node.contents)\n               args node.contents\n               macro (sibilant.resolve-macro 'call))\n\n          (if (and head (= 'string head.type)) (assign macro (sibilant.resolve-macro 'concat))\n              (do\n               (var resolved-macro (sibilant.resolve-macro (output-formatter (transpile head))))\n               (when resolved-macro\n                     (set head 'hint 'macro)\n                     (assign macro resolved-macro\n                             args (rest node.contents)))))\n\n          (macro.apply node args))\n\n         \"null\"))\n\n(def transpile.bracket (node)\n     (apply sibilant.macros.namespaces.core.list node.contents))\n\n(def transpile.brace (node) (apply sibilant.macros.namespaces.core.hash node.contents))\n\n(def transpile.literal (node)\n     (var string node.token)\n     (inject (chain string\n                    (replace (regex \"\\\\*\" 'g) \"_\")\n                    (replace (regex \"\\\\?$\") \"__QUERY\")\n                    (replace (regex \"!$\") \"__BANG\"))\n             (string.match (regex \"-(.)\" 'g))\n             (#(return-string match)\n               (return-string.replace match\n                                      (send (second match) to-upper-case)))))\n\n(def transpile.string (node)\n     (chain node.token (split \"\\n\")\n            (join \"\\\\n\\\" +\\n\\\"\")))\n\n(def transpile.comment (node) null)\n\n","(macro join (glue arr)\n       [\"(\" (transpile arr) \").join(\" (transpile glue) \")\"])\n\n(macro set (arr ...kv-pairs)\n       (interleave \"\\n\" (bulk-map kv-pairs\n                                  (#(k v)\n                                    (as-statement [\"(\" (transpile arr) \")\"\n                                                    \"[\" (transpile k) \"] = \" (transpile v) ])))))\n\n(macro get (obj ...keys)\n       [\"(\" (transpile obj) \")\" (map keys (#(key) [\"[\" (transpile key) \"]\"]))])\n\n(macro var (...pairs)\n       (as-statement\n        [\"var \"\n         (interleave \",\\n    \"\n               (bulk-map pairs\n                         (#(name value)\n                           [ (transpile name) \" = \" (transpile value) ])))\n         ]))\n\n(macro alias-macro (current-macro-name desired-macro-name)\n       (var current-macro-name (output-formatter (transpile current-macro-name))\n            desired-macro-name (output-formatter (transpile desired-macro-name)))\n       (set macros desired-macro-name (get macros current-macro-name))\n       null)\n\n(macro send (object method ...args)\n       [(transpile object) \".\" (transpile method)\n               \"(\" (interleave \", \" (map args transpile)) \")\"])\n\n(macro apply (fn arglist)\n       '(send @fn apply this @arglist))\n\n(macro cons (first rest)\n       [\"[ \" (transpile first) \" ].concat(\" (transpile rest) \")\"])\n\n(macro append (list ...additional)\n       '(send @list concat (list ...@additional)))\n\n(macro length (arr)\n       '(get @arr 'length))\n\n(macro ternary (cond if-true if-false)\n       [\"(\" (transpile cond) \") ? \"\n            (transpile if-true) \" : \"\n            (transpile if-false)])\n\n(macro first (arr) '(get @arr 0))\n(macro second (arr) '(get @arr 1))\n(macro third (arr) '(get @arr 2))\n(macro fourth (arr) '(get @arr 3))\n(macro fifth (arr) '(get @arr 4))\n(macro sixth (arr) '(get @arr 5))\n(macro seventh (arr) '(get @arr 6))\n(macro eighth (arr) '(get @arr 7))\n(macro ninth (arr) '(get @arr 8))\n(macro rest (arr)\n       '(send @arr slice 1))\n\n(macro last (arr)\n       '(first (send @arr slice -1)))\n\n\n(macro = (a b) [ (transpile a) \" === \" (transpile b) ])\n(macro +   (...args)\n       [\"(\" (interleave \" + \" (map args transpile)) \")\"])\n(macro -   (...args)\n       [\"(\" (interleave \" - \" (map args transpile)) \")\"])\n(macro *   (...args)\n       [\"(\" (interleave \" * \" (map args transpile)) \")\"])\n(macro /   (...args)\n           [\"(\" (interleave \" / \" (map args transpile)) \")\"])\n(macro or  (...args)\n       [\"(\" (interleave \" || \" (map args transpile)) \")\"])\n\n(macro and (...args)\n       (ternary (= 1 (length args)) (transpile (first args))\n                [\"(\" (interleave \" && \" (map args transpile)) \")\"]))\n\n(macro mod (...args)\n       [\"(\" (interleave \" % \" (map args transpile)) \")\"])\n\n(macro infix-comparator (comparator args)\n       [\"(\" (interleave \" && \"\n                  (map (args.slice 0 -1)\n                       (#(item index)\n                         [ item \" \" comparator \" \" (get args (+ 1 index))])))\n            \")\"])\n\n(macro >  (...args) (macros.infix-comparator  \">\"  (map args transpile)))\n(macro <  (...args) (macros.infix-comparator  \"<\"  (map args transpile)))\n(macro <= (...args) (macros.infix-comparator \"<=\"  (map args transpile)))\n(macro >= (...args) (macros.infix-comparator \">=\"  (map args transpile)))\n(macro != (...args) (macros.infix-comparator \"!==\" (map args transpile)))\n\n(macro pow (base exponent)\n       '(Math.pow @base @exponent))\n\n(macro incr-by (item increment)\n       [ (transpile item) \" += \" (transpile increment)])\n\n(macro incr (item)\n       [\"((\" (transpile item) \")++)\"])\n\n(macro decr (item)\n       [\"((\" (transpile item) \")--)\"])\n\n(macro new (...args)\n       [\"(new \" '(call ...@args) \")\"])\n\n(macro regex (string glim)\n       '(new RegExp @string @(or glim 'undefined)))\n\n(macro timestamp ()\n       [\"\\\"\" (send (new Date) to-string) \"\\\"\"])\n\n(macro comment (...contents)\n       (map contents (#(content)\n                       [\"// \"(recurse-map (transpile content)\n                                    (#(item)\n                                      (ternary item\n                                               (send (output-formatter (transpile item)) replace\n                                                     (regex \"\\n\" 'g) \"\\n// \")\n                                               null)))])))\n\n(macro zero? (item) '(= @item 0))\n\n(macro empty? (arr)\n       [\"((\" (transpile arr) \").length === 0)\"])\n\n(macro odd? (number)\n       '(= 1 (mod @number 2)))\n\n(macro even? (number)\n       '(= 0 (mod @number 2)))\n\n(macro typeof (thing) [\"typeof \" (transpile thing)])\n\n\n(macro function? (...things)\n       '(and ...@(map things (#(thing) '(= (typeof @thing) 'function)))))\n(macro undefined? (...things)\n       '(and ...@(map things (#(thing) '(= (typeof @thing) 'undefined)))))\n(macro defined? (...things)\n       '(and ...@(map things (#(thing) '(!= (typeof @thing) 'undefined)))))\n(macro number? (...things)\n       '(and ...@(map things (#(thing) '(= (typeof @thing) 'number)))))\n\n(macro if (arg truebody falsebody)\n       [\"(function() {\"\n        (indent [\"if (\" (transpile arg) \") {\"\n                        (indent '(do ...@truebody))\n                        \"} else {\"\n                        (indent '(do ...@falsebody))\n                        \"}\"])\n         \"})()\"])\n\n(macro = (first-thing ...other-things)\n       (var transpiled-first-thing (transpile first-thing))\n       [\"(\" (interleave \" &&\\n \"\n                  (map other-things\n                       (#(thing)\n                         [ transpiled-first-thing\n                                 \" === \"\n                                 (transpile thing) ])))\n            \")\"])\n\n\n(macro string? (thing)\n       [\"typeof(\" (transpile thing) \") === \\\"string\\\"\"])\n\n(macro list? (thing)\n       (var transpiled (transpile thing))\n       [\"((\" transpiled \") && typeof (\" transpiled \") === \\\"object\\\" && (\"\n               transpiled \").constructor.name === \\\"Array\\\")\"])\n\n\n(macro when (arg ...body)\n       [\"(function() {\"\n        (indent [\"if (\" (transpile arg) \") {\"\n                        (indent '(do ...@body))\n                        \"}\"])\n        \"})()\"])\n\n\n(macro not (exp)\n       [\"(!\" (transpile exp) \")\"])\n\n(macro unless (arg ...body)\n       [\"(function() {\"\n        (indent [\"if (\" '(not @arg) \") {\"\n                        (indent '(do ...@body))\n                        \"}\"])\n        \"})()\"])\n\n\n(macro slice (arr start end)\n       '(send @arr slice @start @end))\n\n(macro inspect (...args)\n       (interleave \" + \\\"\\\\n\\\" + \"\n             (map args\n                  (#(arg)\n                    [\"\\\"\" arg \":\\\" + \" (transpile arg)]))))\n\n(macro each (item array ...body)\n       '(send @array for-each\n              (lambda @{ node this args item } ...@body)))\n\n(macro assign (...args)\n       (interleave \"\\n\"\n             (bulk-map args (#(name value)\n                              (as-statement [ (transpile name) \" = \"\n                                                    (transpile value)])))))\n\n\n\n(macro macro-expand (name)\n       (var macro (get macros (output-formatter (transpile name))))\n       (if macro\n           (macro.to-string)\n           \"undefined\"))\n\n(macro throw (...string)\n       [\"throw new Error (\" (interleave \" \" (map string transpile)) \")\"])\n\n(macro as-boolean (expr)\n       [\"(!!(\" (transpile expr) \"))\"])\n\n(macro try (tryblock catchblock)\n       [\"(function() {\"\n        (indent [\"try {\"\n                 (indent '(do @tryblock))\n                 \"} catch (e) {\"\n                 (indent '(do @catchblock))\n                 \"}\"])\n        \"})()\"])\n\n(macro state (...pairs)\n       (set macros.state 'data (or macros.state.data {}))\n\n       (if (= 1 (length pairs))\n           (get macros.state.data (output-formatter (transpile (first pairs))))\n           (do (bulk-map pairs (#(k v) (set macros.state.data (output-formatter (transpile k)) (eval (output-formatter (transpile v))))))\n               null)))\n\n(macro symbol ()\n       (var symbol-count (or (macros.state 'symbol-count) 0)\n            new-symbol-count (+ 1 symbol-count))\n       (macros.state 'symbol-count new-symbol-count)\n       [\"$_symbol\" new-symbol-count \"_$\"])\n\n(macro while (condition ...block)\n       (var symbol (macros.symbol))\n       '(scoped-without-source\n         (var @symbol)\n         @[\"while (\" (transpile condition) \") {\"\n           (indent '(assign @symbol (scoped-without-source ...@block)))\n            \"}\"]\n         @symbol))\n\n(macro until (condition ...block)\n       '(while (not @condition) ...@block))\n\n(macro match? (regexp string)\n       '(send @string match @regexp))\n\n(macro match-regex? (string regexp-string glim)\n       '(match? (regex @regexp-string @glim) @string))\n\n(macro replace (string regexp-string replacement)\n       '(send @string replace\n              (regex @regexp-string)\n              @replacement))\n\n(macro replace-all (string regexp-string replacement)\n       '(replace @string @regexp-string 'g))\n\n(macro thunk (...body)\n       '(lambda @{ node this args [] }\n       ...@(map-node body\n                 (#(node)\n                   (if (node? node 'arg-placeholder)\n                       '(argument @(replace node.token \"^#\" \"\"))\n                       node)))))\n(alias-macro thunk #>)\n\n(macro keys (obj)\n       '(Object.keys @obj))\n\n(macro delete (...objects)\n       (interleave \"\\n\" (map objects (#(obj)\n                                 (as-statement [\"delete \" (transpile obj)])))))\n\n(macro delmacro (...macro-names)\n       (each (macro-name) macro-names\n             (delete (get macros (output-formatter (transpile macro-name)))))\n       null)\n(alias-macro delmacro delete-macro)\n\n\n(macro rename-macro (current-macro-name desired-macro-name)\n       (macros.alias-macro current-macro-name desired-macro-name)\n       (macros.delmacro current-macro-name)\n       null)\n\n(macro arguments ()\n       [\"(Array.prototype.slice.apply(arguments))\"])\n\n(macro argument (n)\n       '(get arguments @n))\n\n(macro scoped (...body)\n       '(call (lambda @{node this args []} ...@body)))\n\n(macro scoped-without-source (...body)\n       [\"(function() {\" (indent '(do ...@body)) \"})()\"])\n       \n\n(macro each-key (as obj ...body)\n       '(scoped-without-source\n         @[\"for (var \" (transpile as) \" in \" (transpile obj) \") \"\n            (as-statement '(scoped-without-source ...@body))\n            ]\n         @obj))\n\n(macro switch (obj ...cases)\n       [\"(function() {\"\n         (indent [\"switch(\" (transpile obj) \") {\"\n                   (map cases (#(case-def)\n                                (var case-name-node (first case-def.contents)\n                                     case-labels (if (or (node? case-name-node 'expression)\n                                                         (node? case-name-node 'bracket))\n                                                     case-name-node.contents\n                                                     [case-name-node])\n                                     case-string (interleave \"\\n\" (map case-labels (#(c)\n                                                                                     (if (= 'default c.token)\n                                                                                         \"default:\"\n                                                                                         [\"case \" (transpile c) \":\"])))))\n                                [\"\\n\" case-string (indent '(do ...@(rest case-def.contents)))]))\n                   \"}\"])\n         \"})()\"])\n\n(macro if (...args)\n       [\"(function() {\"\n        (indent\n         (interleave \" else \"\n               (bulk-map args\n                         (#(cond val)\n                           (if (!= (typeof val) 'undefined)\n                                 [\"if (\" (transpile cond) \") {\"\n                                   (indent '(do @val))\n                                   \"}\"]\n                                 [\"{\" (indent '(do @cond)) \"}\"])))))\n        \"})()\"])\n\n(macro chain (object ...calls)\n       (if (= 0 calls.length) (transpile object)\n           (= 1 calls.length) '(send @object ...@(get (first calls) 'contents))\n           (do\n            (var lines (map calls (#(call index)\n                                    [\".\" (transpile (first call.contents))\n                                         \"(\" (interleave \", \" (map (rest call.contents) transpile)) \")\"])))\n\n            [ (transpile object)\n              (first lines)\n              \"\\n  \"\n              (recurse-indent\n               (interleave \"\\n\" (rest lines)))])))\n\n(macro chainable (...names)\n       (each (name) names\n             '(macro @name (target ...calls)\n                     '(chain (call @name @target) ...@calls))))\n\n(macro let (args body)\n       [\"let (\"\n         (interleave \", \" (bulk-map args\n                   (#(k v)\n                     [ (transpile k) \" = \" (transpile v) ])))\n         (if (undefined? body) \");\"\n             [\") {\" (indent (transpile body)) \"}\"])])\n\n(macro instance-of? (item type)\n       [\"(\" (transpile item) \" instanceof \" (transpile type) \")\"])\n\n(macro slice (list begin end)\n       [\"Array.prototype.slice.call(\" (transpile list)\n                                      \", \" (or (transpile begin) 0)\n                                      (if (defined? end) (\", \" (transpile end) \")\") \")\")])\n\n(macro includes? (list item)\n       '(!= -1 (send @list index-of @item)))\n\n\n(macro excludes? (list item)\n       '(= -1 (send @list index-of @item)))\n\n(macro exists? (thing)\n       '(and (defined? @thing) (!= @thing null)))\n\n(macro with-state (k v ...body)\n       (var before (macros.state k))\n       (macros.state k v)\n       (var return-value\n            (interleave \"\\n\" (map body transpile)))\n       (macros.state k before)\n       return-value)\n\n(macro join (glue arr)\n       (if (and (defined? glue) (undefined? arr))\n           (assign arr glue glue undefined))\n       [\"(\" (transpile arr) \").join(\" (if glue (transpile glue) \"\\\"\\\"\") \")\"])\n\n(macro var (...pairs)\n       (var destructured [])\n       (bulk-map pairs (#(lhs rhs)\n                         (switch lhs.type\n                                 ('bracket\n                                  (var symbol (macros.symbol))\n                                  (destructured.push [symbol (transpile rhs)])\n                                  (each (item index) lhs.contents\n                                        (destructured.push [(transpile item) '(get @symbol @index)]))\n                                  (destructured.push [symbol 'undefined]))\n                                 ('brace\n                                  (var symbol (macros.symbol))\n                                  (destructured.push [symbol (transpile rhs)])\n                                  (each (item index) lhs.contents\n                                        (var tr-item (transpile item))\n                                        (destructured.push [tr-item '(get @symbol @[\"\\\"\" tr-item \"\\\"\"])]))\n                                  (destructured.push [symbol 'undefined]))\n\n                                 (default\n                                  (destructured.push [(transpile lhs)\n                                                       (if rhs (transpile rhs) 'undefined)])))))\n\n       (as-statement\n        [\"var \" (interleave \",\\n    \"\n           (map destructured\n                (#(pair)\n                  [(first pair) \" = \" (second pair)]\n                  )))]))\n\n\n(debug false)\n\n(macro default (...pairs)\n       (interleave \"\\n\" (bulk-map pairs (#(name value)\n                                  '(assign @name (ternary (defined? @name) @name @value))))))\n\n(macro namespace () undefined)\n"]}