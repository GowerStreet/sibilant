{"version":3,"sources":["/Users/jbr/code/sibilant/src/transpiler.sibilant","/Users/jbr/code/sibilant/include/macros.sibilant"],"names":[],"mappings":"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","sourcesContent":["(def node? (thing ...types)\n     (and\n      (exists? thing)\n      (= 'object (typeof thing))\n      (string? thing.type)\n      (or (empty? types) (includes? types thing.type))\n      (has-key? thing 'contents)))\n\n(def empty-node? (item)\n     (if (node? item) (empty-node? item.contents)\n         (list? item) (all? item empty-node?)\n         (string? item) (item.match (regex \"^\\\\s*$\"))\n         (or (= null item)\n             (undefined? item)\n             (= false item))))\n\n(def compact-node (item)\n     (if (node? item) (do\n                       (set item 'contents (compact-node item.contents))\n                       (if (and item.contents item.contents.length) item null))\n         (list? item) (do\n                       (var compacted (compact (map item compact-node)))\n                       (if (and compacted compacted.length) compacted null))\n         (if (or (= item \"\") (= item false)) null item)))\n\n(def recurse-transpile (node)\n     (if (list? node)\n         (map node recurse-transpile)\n\n         (node? node 'output)\n         (merge-into node { contents: (recurse-transpile node.contents) })\n\n         (node? node)\n         (transpile node)\n\n         node))\n\n(def transpile (node preprocessor)\n     (if\n      (string? node)\n      (assign node { type 'js token node contents []})\n\n      (number? node)\n      (assign node { type 'number token (node.to-string) contents []}))\n     \n     (if (list? node) node\n         (exists? node) (do\n                         (var transpiler (or (get transpile node.type) transpile.default)\n                              result (transpiler node)\n                              result-node (recurse-transpile (if (node? result) result\n                                                                 { contents result\n                                                                   type 'output })))\n                         (set result-node\n                              'contents (compact (flatten result-node.contents))\n                              'source node)\n\n                         (when sibilant.debug\n                               (console.log (prettify node)\n                                            (red \"->\")\n                                            (prettify result-node)))\n\n                         (set node 'transpiled result-node)\n\n                         (if (empty-node? result-node) undefined\n                             result-node))))\n\n\n(set sibilant 'transpile transpile)\n\n(var reader-macros {})\n\n(def transpile.hat (node)\n     (var output (transpile (first node.contents)))\n     (merge-into output\n                 { contents [\"sibilant.macros.namespace[\\\"\"\n                              (first output.contents)\n                              \"\\\"]\"]}))\n\n(def transpile.tick (node)\n     (sibilant.macros.namespaces.core.quote.apply node node.contents))\n\n(def transpile.at (node)\n     (transpile (first node.contents)))\n\n(def transpile.dots (node)\n     (sibilant.macros.namespaces.core.dots.apply node node.contents))\n\n(def transpile.default (node)\n     node.token)\n\n(def transpile.output (node)\n     node)\n\n(def transpile.number (node)\n     (pipe (regex \",\" 'g)\n           (node.token.replace \"\")\n           (parse-float)\n           (.to-string)))\n\n(def transpile.root (node)\n     (if (= 1 node.contents.length)\n         (transpile (first node.contents))\n         (pipe node.contents\n               (map as-statement)\n               (compact)\n               (interleave \"\\n\"))))\n\n\n(def transpile.expression (node preprocessor)\n     (if node.contents.length\n         (do\n          (var head (first node.contents)\n               args node.contents\n               macro (sibilant.resolve-macro 'call))\n\n          (if (node? head 'string)\n              (assign macro (sibilant.resolve-macro 'concat))\n\n              (node? head 'dots)\n              (assign macro (sibilant.resolve-macro 'send)\n                      args [ (second node.contents) (first head.contents) ...(slice node.contents 2) ])\n\n              (node? head 'literal 'other-char)\n              (do\n               (var resolved-macro (sibilant.resolve-macro (output-formatter (transpile head))))\n               (when resolved-macro\n                     (set head 'hint 'macro)\n                     (assign macro resolved-macro\n                             args (rest node.contents)))))\n\n          (macro.apply node args))\n\n         \"null\"))\n\n(def transpile.bracket (node)\n     (apply sibilant.macros.namespaces.core.list node.contents))\n\n(def transpile.brace (node) (apply sibilant.macros.namespaces.core.hash node.contents))\n\n(def transpile.literal (node)\n     (var string node.token)\n     (inject (chain string\n                    (replace (regex \"\\\\*\" 'g) \"_\")\n                    (replace (regex \"\\\\?$\") \"__QUERY\")\n                    (replace (regex \"!$\") \"__BANG\"))\n             (string.match (regex \"-(.)\" 'g))\n             (#(return-string match)\n               (return-string.replace match\n                                      (.to-upper-case (second match))))))\n\n(def transpile.string (node)\n     (chain node.token\n            (split \"\\n\")\n            (join \"\\\\n\\\" +\\n\\\"\")))\n\n(def transpile.comment (node) null)\n\n","(namespace core)\n\n(docs \"the simplest way to conditionally execute code.\"\n      example (ternary (< 50 100)\n                       \"fifty is less than 100\"\n                       \"fifty is more than 100\"))\n\n(macro ternary (cond if-true if-false)\n       [\"(\" (transpile cond) \") ? \"\n            (transpile if-true) \" : \"\n            (transpile if-false)])\n\n\n\n\n\n\n(docs \"combines elements of array `arr` into a string,\ninserting `glue` string between each element\nfixme: incorrect argument order\"\n      example (join \" \" [ 'a 'few 'words ]))\n      \n(macro join (glue arr)\n       [\"(\" (transpile arr) \").join(\" (transpile glue) \")\"])\n\n\n\n\n\n;; used only for bootstrapping\n(macro set (arr ...kv-pairs)\n       (interleave \"\\n\" (bulk-map kv-pairs\n                                  (#(k v)\n                                    (as-statement [\"(\" (transpile arr) \")\"\n                                                    \"[\" (transpile k) \"] = \" (transpile v) ])))))\n(macro var (...pairs)\n       (as-statement\n        [\"var \"\n         (interleave \",\\n    \"\n               (bulk-map pairs\n                         (#(name value)\n                           [ (transpile name) \" = \" (transpile value) ])))\n         ]))\n\n(macro get (obj ...keys)\n       [\"(\" (transpile obj) \")\" (map keys (#(key)\n                                            [\"[\" (transpile key) \"]\"]))])\n\n\n\n\n\n(docs \"stores a duplicate copy of `current-macro-name` as\n`new-macro-name` in current namespace.  No output.\")\n\n(macro alias-macro (current-macro-name new-macro-name)\n       (var current-macro-name (output-formatter (transpile current-macro-name))\n            new-macro-name (output-formatter (transpile new-macro-name)))\n       (set sibilant.macros.namespace\n            new-macro-name (get sibilant.macros.namespace current-macro-name))\n       null)\n\n\n\n\n\n(docs \"calls the `method` on `object` as a function with `args` as the arguments\"\n      example (send object method first-argument second-argument third-argument))\n\n(macro send (object method ...args)\n       [(transpile object) \".\" (transpile method)\n               \"(\" (interleave \", \" (map args transpile)) \")\"])\n\n\n\n\n\n(docs \"calls the function `fn` with arguments passed as an array in `arglist`\"\n      example (apply my-function [ first-arg second-arg third-arg ]))\n\n(macro apply (fn arglist)\n       '(.apply @fn this @arglist))\n\n\n\n\n(docs \"builds an array with `first` as the zeroth index and the\nelements provided by array `rest` as the subsequent elements, as\nsiblings with `first`.  deprecated\"\n      example (cons 1 [ 2 3 4 ]))\n\n(macro cons (first rest)\n       [\"[ \" (transpile first) \" ].concat(\" (transpile rest) \")\"])\n\n\n\n\n(docs \"adds `additional` elements onto the right-side (tail) of `list`. deprecated\"\nexample (append [ 1 2 3 ] 4 5 6))\n(macro append (list ...additional)\n       '(.concat @list (list ...@additional)))\n\n\n\n\n\n(docs \"fetches length attribute from `arr`\"\n      example (length [ 1 2 3 ]))\n(macro length (arr)\n       '(get @arr 'length))\n\n\n\n(macro first (arr) '(get @arr 0))\n(macro second (arr) '(get @arr 1))\n(macro third (arr) '(get @arr 2))\n(macro fourth (arr) '(get @arr 3))\n(macro fifth (arr) '(get @arr 4))\n(macro sixth (arr) '(get @arr 5))\n(macro seventh (arr) '(get @arr 6))\n(macro eighth (arr) '(get @arr 7))\n(macro ninth (arr) '(get @arr 8))\n\n(docs \"fetches all but the first item of `arr`\"\n      example (rest [ 1 2 3 ]))\n(macro rest (arr) '(.slice @arr 1))\n\n(docs \"fetches just the last element of `arr` by slicing.\"\n      example (last [ 1 2 3 ]))\n(macro last (arr) '(first (.slice @arr -1)))\n\n\n(macro = (a b) [ (transpile a) \" === \" (transpile b) ])\n\n(docs \"adds `args` using the javascript `+` operator. Since javascript\noverloads this for string concatenation, this macro can be used for\nthis as well.\"\n      examples [ (+ 1 2 3) (+ 'hello 'world) ])\n(macro +   (...args)\n       [\"(\" (interleave \" + \" (map args transpile)) \")\"])\n\n\n(docs \"subtracts each subsequent element of `args`\"\n      examples [ (- 2 1) (- 10 5 1) ])\n(macro -   (...args)\n       [\"(\" (interleave \" - \" (map args transpile)) \")\"])\n\n(docs \"multiplies elements of `args`\"\n      example (* 3 4 5))\n(macro *   (...args)\n       [\"(\" (interleave \" * \" (map args transpile)) \")\"])\n\n;; (docs \"divides each subsequent element of `args`\"\n;;       examples [ (/ 1 2)\n;;                  (/ 1 2 4) ])\n(macro /   (...args)\n           [\"(\" (interleave \" / \" (map args transpile)) \")\"])\n(macro or  (...args)\n       [\"(\" (interleave \" || \" (map args transpile)) \")\"])\n\n(macro and (...args)\n       (ternary (= 1 (length args)) (transpile (first args))\n                [\"(\" (interleave \" && \" (map args transpile)) \")\"]))\n\n(macro mod (...args)\n       [\"(\" (interleave \" % \" (map args transpile)) \")\"])\n\n(macro infix-comparator (comparator args)\n       [\"(\" (interleave \" && \"\n                  (map (args.slice 0 -1)\n                       (#(item index)\n                         [ item \" \" comparator \" \" (get args (+ 1 index))])))\n            \")\"])\n\n(macro >  (...args) (^infix-comparator  \">\"  (map args transpile)))\n(macro <  (...args) (^infix-comparator  \"<\"  (map args transpile)))\n(macro <= (...args) (^infix-comparator \"<=\"  (map args transpile)))\n(macro >= (...args) (^infix-comparator \">=\"  (map args transpile)))\n(macro != (...args) (^infix-comparator \"!==\" (map args transpile)))\n\n(macro pow (base exponent)\n       '(Math.pow @base @exponent))\n\n(macro incr-by (item increment)\n       [ (transpile item) \" += \" (transpile increment)])\n\n(macro incr (item)\n       [\"((\" (transpile item) \")++)\"])\n\n(macro decr (item)\n       [\"((\" (transpile item) \")--)\"])\n\n(macro new (...args)\n       [\"(new \" '(call ...@args) \")\"])\n\n(macro regex (string glim)\n       '(new RegExp @string @(or glim 'undefined)))\n\n(macro timestamp ()\n       [\"\\\"\" (.to-string (new Date)) \"\\\"\"])\n\n(macro zero? (item) '(= @item 0))\n\n(macro empty? (arr)\n       [\"((\" (transpile arr) \").length === 0)\"])\n\n(macro odd? (number)\n       '(= 1 (mod @number 2)))\n\n(macro even? (number)\n       '(= 0 (mod @number 2)))\n\n(macro typeof (thing) [\"typeof \" (transpile thing)])\n\n(macro string? (...things)\n       '(and ...@(map things (#(thing) '(= (typeof @thing) 'string)))))\n(macro function? (...things)\n       '(and ...@(map things (#(thing) '(= (typeof @thing) 'function)))))\n(macro undefined? (...things)\n       '(and ...@(map things (#(thing) '(= (typeof @thing) 'undefined)))))\n(macro defined? (...things)\n       '(and ...@(map things (#(thing) '(!= (typeof @thing) 'undefined)))))\n(macro number? (...things)\n       '(and ...@(map things (#(thing) '(= (typeof @thing) 'number)))))\n\n(macro if (arg truebody falsebody)\n       [\"(function() {\"\n        (indent [\"if (\" (transpile arg) \") {\"\n                        (indent '(do ...@truebody))\n                        \"} else {\"\n                        (indent '(do ...@falsebody))\n                        \"}\"])\n         \"})()\"])\n\n(macro pipe (...calls)\n       (inject undefined calls\n         (#(value item)\n           (var cloned (clone item))\n           (if (undefined? value)\n               cloned\n               (merge-into cloned\n                           { contents [ (first cloned.contents)\n                                        value\n                                        ...(rest cloned.contents) ] })))))\n\n\n(docs \"inserts `contents` transpiled to javascript as a comment in the\noutput file, removing it from execution.\"\n      example (comment (def foo () 1)))\n(macro comment (...contents)\n       (map contents (#(content)\n                       [\"// \"(recurse-map (transpile content)\n                                    (#(item)\n                                      (ternary item\n                                               (pipe item\n                                                     (transpile)\n                                                     (output-formatter)\n                                                     (.replace (regex \"\\n\" 'g) \"\\n// \"))\n                                               null)))])))\n\n\n(docs \"checks if `first-thing` is equal to all of the `other-things`.\nMost of the time, there is only one other thing. Javascript threequals\nis always used.  Please note that if evaluating `first-thing` has\nside-effects, they will be called `(length other-things)` times.\"\n      examples [ (= 1 2)\n                 (= 10 (+ 5 5) (- 15 5)) ])\n\n(macro = (first-thing ...other-things)\n       (var transpiled-first-thing (transpile first-thing))\n       [\"(\" (interleave \" &&\\n \"\n                  (map other-things\n                       (#(thing)\n                         [ transpiled-first-thing\n                                 \" === \"\n                                 (transpile thing) ])))\n            \")\"])\n\n\n(macro list? (thing)\n       (var transpiled (transpile thing))\n       [\"((\" transpiled \") && typeof (\" transpiled \") === \\\"object\\\" && (\"\n               transpiled \").constructor.name === \\\"Array\\\")\"])\n\n\n(macro when (arg ...body)\n       [\"(function() {\"\n        (indent [\"if (\" (transpile arg) \") {\"\n                        (indent '(do ...@body))\n                        \"}\"])\n        \"})()\"])\n\n\n(macro not (exp)\n       [\"(!\" (transpile exp) \")\"])\n\n(macro unless (arg ...body)\n       [\"(function() {\"\n        (indent [\"if (\" '(not @arg) \") {\"\n                        (indent '(do ...@body))\n                        \"}\"])\n        \"})()\"])\n\n\n(macro slice (arr start end)\n       '(.slice @arr @start @end))\n\n(macro inspect (...args)\n       (interleave \" + \\\"\\\\n\\\" + \"\n             (map args\n                  (#(arg)\n                    [\"\\\"\" arg \":\\\" + \" (transpile arg)]))))\n\n(macro each (item array ...body)\n       '(.for-each @array\n              (lambda @{ node this args item } ...@body)))\n\n(macro assign (...args)\n       (interleave \"\\n\"\n             (bulk-map args (#(name value)\n                              (as-statement [ (transpile name) \" = \"\n                                                    (transpile value)])))))\n\n\n\n(macro macro-expand (name)\n       (var macro (get macros (output-formatter (transpile name))))\n       (if macro\n           (macro.to-string)\n           \"undefined\"))\n\n(macro throw (...string)\n       [\"throw new Error (\" (interleave \" \" (map string transpile)) \")\"])\n\n(macro as-boolean (expr)\n       [\"(!!(\" (transpile expr) \"))\"])\n\n(macro try (tryblock catchblock)\n       [\"(function() {\"\n        (indent [\"try {\"\n                 (indent '(do @tryblock))\n                 \"} catch (e) {\"\n                 (indent '(do @catchblock))\n                 \"}\"])\n         \"})()\"])\n\n(macro log-pretty (label arg)\n       (var node this)\n       (when (undefined? arg)\n             (assign arg label\n                     label [\"\\\"\" (prettify label false) \"\\\"\"]))\n       `(console.log (concat @[\"\\\"\" node.file \":\" node.line \"\\\"\"] \" \" @label \" = \" (prettify @arg))))\n(alias-macro log-pretty pretty-log)\n\n\n(macro state (...pairs)\n       (if (= 1 (length pairs))\n           (get sibilant.state (output-formatter (transpile (first pairs))))\n           (do (bulk-map pairs (#(k v) (set sibilant.state (output-formatter (transpile k)) (eval (output-formatter (transpile v))))))\n               null)))\n\n(macro symbol ()\n       (var symbol-count (or (get sibilant.state 'symbol-count) 0)\n            new-symbol-count (+ 1 symbol-count))\n       (^state 'symbol-count new-symbol-count)\n       [\"$_symbol\" new-symbol-count \"_$\"])\n\n(macro while (condition ...block)\n       (var symbol (^symbol))\n       '(scoped-without-source\n         (var @symbol)\n         @[\"while (\" (transpile condition) \") {\"\n           (indent '(assign @symbol (scoped-without-source ...@block)))\n            \"}\"]\n         @symbol))\n\n(macro until (condition ...block)\n       '(while (not @condition) ...@block))\n\n(macro match? (regexp string)\n       '(.match @string @regexp))\n\n(macro match-regex? (string regexp-string glim)\n       '(match? (regex @regexp-string @glim) @string))\n\n(macro replace (string regexp-string replacement)\n       '(.replace @string\n              (regex @regexp-string)\n              @replacement))\n\n(macro replace-all (string regexp-string replacement)\n       '(.replace @string (regex @regexp-string 'g) @replacement))\n\n(macro thunk (...body)\n       '(lambda @{ node this args [] }\n       ...@(map-node body\n                 (#(node)\n                   (if (node? node 'arg-placeholder)\n                       '(argument @(replace node.token \"^#\" \"\"))\n                       node)))))\n(alias-macro thunk #>)\n\n(macro keys (obj)\n       '(Object.keys @obj))\n\n(macro delete (...objects)\n       (interleave \"\\n\" (map objects (#(obj)\n                                 (as-statement [\"delete \" (transpile obj)])))))\n\n(macro delmacro (...macro-names)\n       (each (macro-name) macro-names\n             (delete (get sibilant.macros.namespace (output-formatter (transpile macro-name)))))\n       null)\n(alias-macro delmacro delete-macro)\n\n\n(macro rename-macro (current-macro-name desired-macro-name)\n       (^alias-macro current-macro-name desired-macro-name)\n       (^delmacro current-macro-name)\n       null)\n\n(macro arguments ()\n       [\"(Array.prototype.slice.apply(arguments))\"])\n\n(macro argument (n)\n       '(get arguments @n))\n\n(macro scoped (...body)\n       '(call (lambda @{node this args []} ...@body)))\n\n(macro scoped-without-source (...body)\n       [\"(function() {\" (indent '(do ...@body)) \"})()\"])\n       \n\n(macro each-key (as obj ...body)\n       '(scoped-without-source\n         @[\"for (var \" (transpile as) \" in \" (transpile obj) \") \"\n            (as-statement '(scoped-without-source ...@body))\n            ]\n         @obj))\n\n(macro switch (obj ...cases)\n       [\"(function() {\"\n         (indent [\"switch(\" (transpile obj) \") {\"\n                   (map cases (#(case-def)\n                                (var case-name-node (first case-def.contents)\n                                     case-labels (if (node? case-name-node 'expression 'bracket)\n                                                     case-name-node.contents\n                                                     [case-name-node])\n                                     case-string (interleave \"\\n\" (map case-labels (#(c)\n                                                                                     (if (= 'default c.token)\n                                                                                         \"default:\"\n                                                                                         [\"case \" (transpile c) \":\"])))))\n                                [\"\\n\" case-string (indent '(do ...@(rest case-def.contents)))]))\n                   \"}\"])\n         \"})()\"])\n\n(macro if (...args)\n       [\"(function() {\"\n        (indent\n         (interleave \" else \"\n               (bulk-map args\n                         (#(cond val)\n                           (if (!= (typeof val) 'undefined)\n                                 [\"if (\" (transpile cond) \") {\"\n                                   (indent '(do @val))\n                                   \"}\"]\n                                 [\"{\" (indent '(do @cond)) \"}\"])))))\n        \"})()\"])\n\n(macro chain (object ...calls)\n       (if (= 0 calls.length) (transpile object)\n           (= 1 calls.length) '(send @object ...@(get (first calls) 'contents))\n           (do\n            (var lines (map calls (#(call index)\n                                    [\".\" (transpile (first call.contents))\n                                         \"(\" (interleave \", \" (map (rest call.contents) transpile)) \")\"])))\n\n            [ (transpile object)\n              (first lines)\n              \"\\n  \"\n              (recurse-indent\n               (interleave \"\\n\" (rest lines)))])))\n\n(macro chainable (...names)\n       (each (name) names\n             '(macro @name (target ...calls)\n                     '(chain (call @name @target) ...@calls))))\n\n(macro let (args body)\n       [\"let (\"\n         (interleave \", \" (bulk-map args\n                   (#(k v)\n                     [ (transpile k) \" = \" (transpile v) ])))\n         (if (undefined? body) \");\"\n             [\") {\" (indent (transpile body)) \"}\"])])\n\n(macro instance-of? (item type)\n       [\"(\" (transpile item) \" instanceof \" (transpile type) \")\"])\n\n(macro slice (list begin end)\n       [\"Array.prototype.slice.call(\" (transpile list)\n                                      \", \" (or (transpile begin) 0)\n                                      (if (defined? end) (\", \" (transpile end) \")\") \")\")])\n\n(macro includes? (list item)\n       '(pipe @list (.index-of @item) (!= -1)))\n\n(macro excludes? (list item)\n       '(pipe @list (.index-of @item) (= -1)))\n\n(macro exists? (thing)\n       '(and (defined? @thing) (!= @thing null)))\n\n(macro with-state (k v ...body)\n       (var before (^state k))\n       (^state k v)\n       (var return-value\n            (interleave \"\\n\" (map body transpile)))\n       (^state k before)\n       return-value)\n\n(macro join (glue arr)\n       (if (and (defined? glue) (undefined? arr))\n           (assign arr glue glue undefined))\n       [\"(\" (transpile arr) \").join(\" (if glue (transpile glue) \"\\\"\\\"\") \")\"])\n\n(macro var (...pairs)\n       (var destructured [])\n       (bulk-map pairs (#(lhs rhs)\n                         (switch lhs.type\n                                 ('bracket\n                                  (var symbol (^symbol))\n                                  (destructured.push [symbol (transpile rhs)])\n                                  (each (item index) lhs.contents\n                                        (destructured.push [(transpile item) '(get @symbol @index)]))\n                                  (destructured.push [symbol 'undefined]))\n                                 ('brace\n                                  (var symbol (^symbol))\n                                  (destructured.push [symbol (transpile rhs)])\n                                  (each (item index) lhs.contents\n                                        (var tr-item (transpile item))\n                                        (destructured.push [tr-item '(get @symbol @[\"\\\"\" tr-item \"\\\"\"])]))\n                                  (destructured.push [symbol 'undefined]))\n\n                                 (default\n                                  (destructured.push [(transpile lhs)\n                                                       (if rhs (transpile rhs) 'undefined)])))))\n\n       (as-statement\n        [\"var \" (interleave \",\\n    \"\n           (map destructured\n                (#(pair)\n                  [(first pair) \" = \" (second pair)]\n                  )))]))\n\n(macro default (...pairs)\n       (interleave \"\\n\" (bulk-map pairs (#(name value)\n                                  '(assign @name (ternary (defined? @name) @name @value))))))\n\n\n(macro import-namespace (namespace)\n       (var namespace-as-string (output-formatter (transpile namespace)))\n       (unless (sibilant.macros.namespaces.has-own-property namespace-as-string)\n               (set sibilant.macros.namespaces namespace-as-string {}))\n       (sibilant.macros.search-path.unshift namespace-as-string)\n       undefined)\n\n\n(macro namespace (namespace)\n       `(import-namespace @namespace)\n       (set sibilant.macros 'namespace (get sibilant.macros.namespaces (output-formatter (transpile namespace))))\n       undefined)\n\n\n\n\n\n\n(docs \"checks if `object` has property `key`.  returns true or false.\"\n      example (has-key? object 'a))\n\n(macro has-key? (object key)\n       `(.has-own-property @object @key))\n\n\n\n\n\n\n\n(docs \"retreives object properties, potentially deeply. If more than one `keys` are provided,\n`get` fetches deeply into nested objects or arrays.\nWhen javascript dot notation can be used (`a.b = 3`), it is.\nOtherwise, bracket notation is used.\"\n      examples [ (get an-object 'static-attribute-name)\n                 (get object dynamic-attribute-name)\n                 (get object \"these attributes\" \"can't be dotted\")\n                 (get array 0)\n                 (get object 'a 'b c)\n                 (get array 0 1 2) ])\n\n\n(macro get (obj ...keys)\n       [(transpile obj)\n         (map keys (#(key)\n                     (var transpiled (transpile key)\n                          output (output-formatter transpiled))\n\n                     (if (match-regex? output \"^\\\"[a-zA-Z0-9]+\\\"$\")\n                         [\".\" (replace-all output \"\\\"\" \"\") ]\n                         [\"[\" transpiled \"]\"])))])\n\n\n\n\n\n\n\n\n\n\n(docs \"assigns object properties to `arr` in pairs, alternating between keys and values.\nWhen javascript dot notation can be used (`a.b = 3`), it is.  Otherwise, bracket notation is used\"\n      examples [ (set an-object 'static-attribute-name 'value)\n                 (set object dynamic-attribute-name \"key name determined at runtime\")\n                 (set array 0 \"first element of array\")\n                 (set object \"can't be dotted\" 'value)\n                 (set object 'first-attribute 'first-value\n                      'second-attribute 'second-value) ])\n\n(macro set (arr ...kv-pairs)\n       (interleave \"\\n\" (bulk-map kv-pairs (#(k v) `(assign (get @arr @k) @v)))))\n\n\n"]}