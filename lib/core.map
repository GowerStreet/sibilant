{"version":3,"sources":["/Users/jbr/code/sibilant/src/core.sibilant","/Users/jbr/code/sibilant/include/macros.sibilant"],"names":[],"mappings":"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","sourcesContent":["(def sibilant.macros.namespaces.core.return (token)\n     (when sibilant.debug (console.log \"returning \" (prettify token)))\n     (var default-return (as-statement [\"return \" (transpile token)]))\n     (if (and token token.contents token.contents.length)\n         (switch (get (first token.contents) 'token)\n                 (('return 'throw 'do) (transpile token))\n\n                 ('delete\n                  (var delete-macro (get macros 'delete))\n                  (if (< token.contents.length 3) default-return\n                      [ (as-statement (apply delete-macro (token.contents.slice 1 -1)))\n                        \"\\nreturn \"\n                        (as-statement (call delete-macro (last token.contents)))]))\n\n                 ('assign\n                  (if (< token.contents.length 4) default-return\n                      [ (apply sibilant.macros.namespaces.core.assign\n                               (token.contents.slice 1 (- token.contents.length 2)))\n                        \"\\nreturn \"\n                        (apply sibilant.macros.namespaces.core.assign (token.contents.slice -2))]))\n\n                 ('var\n                  [ (transpile token) \"\\nreturn \" (transpile (if (even? token.contents.length)\n                                                                 (last token.contents)\n                                                                 (first (token.contents.slice -2))))])\n\n                 ('set\n                  (if (< token.contents.length 5) default-return\n                      (do\n                       (var obj (second token.contents)\n                            non-return-part (token.contents.slice 2 (- token.contents.length 2))\n                            return-part (token.contents.slice -2))\n                       (non-return-part.unshift obj)\n                       (return-part.unshift obj)\n                       [ (sibilant.macros.namespaces.core.set ...non-return-part)\n                         \"\\nreturn \"\n                         (sibilant.macros.namespaces.core.set ...return-part)])))\n\n                 (default default-return))\n         default-return))\n\n\n(def sibilant.macros.namespaces.core.do (...body)\n     (if (= 1 body.length) (sibilant.macros.namespaces.core.return (first body))\n\n         body.length [ (interleave \"\\n\" (map (body.slice 0 -1) (#> (as-statement #0))))\n                       \"\\n\"\n                       (sibilant.macros.namespaces.core.return (last body)) ]\n         \"\"))\n\n(def sibilant.macros.namespaces.core.empty-list () 'null)\n\n(def sibilant.macros.namespaces.core.def (fn-name args ...body)\n     (if (undefined? fn-name) (error \"invalid function definition. missing name.\")\n         (undefined? args) (error \"invalid function definition. missing arguments or return value.\"))\n\n     (var fn-name-tr (transpile fn-name) this-node this)\n     (sibilant.docs.record (\"function \" fn-name-tr) this)\n\n     (as-statement [ (if (match? (regex \"\\\\.\") (output-formatter fn-name-tr)) \"\" \"var \")\n                     fn-name-tr \" = \"\n                     (sibilant.macros.namespaces.core.lambda { name fn-name args args node this-node } ...body )\n                     ] ))\n\n(def sibilant.macros.namespaces.core.macro (name args ...body)\n     (var name-tr (output-formatter (transpile name))\n          options { name name args args node this}\n          js (output-formatter (sibilant.macros.namespaces.core.lambda options ...body)))\n\n     (when sibilant.debug (console.log js))\n\n     (sibilant.docs.record (\"macro \" (first sibilant.macros.search-path) \"/\" name-tr) this)\n     \n     (try (set sibilant.macros.namespace name-tr (eval js))\n          (error (\"error in parsing macro \"\n                  (sibilant.pretty-print name) \":\\n\" js)))\n\n     undefined)\n\n(def sibilant.macros.namespaces.core.meta (...body)\n     (var js (output-formatter (sibilant.macros.namespaces.core.scoped ...body)))\n     (when sibilant.debug (console.log js))\n     (output-formatter (eval js)))\n\n\n(def sibilant.macros.namespaces.core.concat (...args)\n     [\"(\" (interleave \" + \" (map args transpile)) \")\"])\n\n(def sibilant.macros.namespaces.core.reverse (arr)\n     (var reversed [])\n     (each (item) arr (reversed.unshift item))\n     reversed)\n\n(var reverse sibilant.macros.namespaces.core.reverse)\n\n(def sibilant.macros.namespaces.core.lambda (args-or-options ...body)\n     (when sibilant.debug\n           (console.log args-or-options))\n     (var args (or (get args-or-options 'args) args-or-options)\n          body (or (get args-or-options 'body) body)\n          args (if (node? args 'expression) args.contents\n                   (and (node? args) (empty? body)) (do (assign body [ args ]) [])\n                   args)\n          name (when args-or-options.name\n                     (chain (output-formatter (transpile args-or-options.name))\n                            (replace (regex \"\\\\W+\" 'g) \"$\")\n                            (concat \"$\")))\n          rest (detect args\n                       (#> (node? #0 'dots))))\n\n     (var this-node this\n          node (detect\n                [ args-or-options.node this-node args-or-options.name args (first body) ]\n                (#(n) (and (node? n) (get n 'file)))))\n     [\"(function\" (if name (\" \" name) \"\") \"(\"\n       (interleave \", \" (map args transpile)) \") {\"\n       (if (or args-or-options.name node)\n           (indent [\"/*\"\n                     (if args-or-options.name (\" \" (sibilant.pretty-print args-or-options.name false)) \"\")\n                     (if node (\" \" node.file \":\" node.line \":\" node.col) \"\")\n                     \" */\"]) \"\")\n       (when (exists? rest)\n             (indent (as-statement [\"var \" (transpile rest)\n                       \" = Array.prototype.slice.call(arguments, \"\n                       (- args.length 1) \")\"])))\n\n       (indent (apply sibilant.macros.namespaces.core.do body))\n       \"})\"])\n\n(set sibilant.macros.namespaces.core \"#\" sibilant.macros.namespaces.core.lambda)\n\n(def sibilant.macros.namespaces.core.quoted-hash (...pairs)\n     (var cached-quote-value sibilant.macros.namespaces.core.hash.quote-keys)\n     (set sibilant.macros.namespaces.core.hash 'quote-keys true)\n     (var value (sibilant.macros.namespaces.core.hash ...pairs))\n     (set sibilant.macros.namespaces.core.hash 'quote-keys cached-quote-value)\n     value)\n\n(def sibilant.macros.namespaces.core.hash (...pairs)\n     (when (odd? pairs.length)\n           (error (\"odd number of key-value pairs in hash: \"\n                   (call inspect pairs))))\n\n     (var quote-keys sibilant.macros.namespaces.core.hash.quote-keys\n          pair-strings (bulk-map pairs (#(key value)\n                                         [ (if (and quote-keys (not (node? key 'string)))\n                                               [\"\\\"\" (transpile key) \"\\\"\"]\n                                               (transpile key))\n                                           \": \"\n                                           (transpile value)])))\n     (if (>= 1 pair-strings.length)\n         [\"{ \" (interleave \", \" pair-strings) \" }\"]\n         [\"{\" (indent (interleave \",\\n\" pair-strings)) \"}\"]))\n\n\n(def sibilant.macros.namespaces.core.quote (content)\n     (if (string? content) (\"\\\"\" (qescape content) \"\\\"\")\n         (number? content) (sibilant.macros.namespaces.core.quote (content.to-string))\n         (node? content 'literal) [\"\\\"\" (transpile content) \"\\\"\"]\n         \n         (node? content 'expression)\n         (if (length (keys (find-unquotes content)))\n             (sibilant.macros.namespaces.core.call 'macros.expand-quote.call 'this (sibilant.macros.namespaces.core.quote content.node-id)\n                    (apply sibilant.macros.namespaces.core.quoted-hash (alternating-keys-and-values (find-unquotes content))))\n             [\"\\\"\" (map-node (transpile content) qescape) \"\\\"\"])\n\n         (node? content 'bracket)\n         (if (length (keys (find-unquotes content)))\n             (sibilant.macros.namespaces.core.call 'macros.expand-quote.call 'this (sibilant.macros.namespaces.core.quote content.node-id)\n                    (apply sibilant.macros.namespaces.core.quoted-hash (alternating-keys-and-values (find-unquotes content))))\n             (sibilant.macros.namespaces.core.list ...(map content.contents sibilant.macros.namespaces.core.quote)))\n\n         (node? content 'brace)\n         (if (length (keys (find-unquotes content)))\n             (sibilant.macros.namespaces.core.call 'macros.expand-quote.call 'this (sibilant.macros.namespaces.core.quote content.node-id)\n                    (apply sibilant.macros.namespaces.core.quoted-hash (alternating-keys-and-values (find-unquotes content))))\n             (sibilant.macros.namespaces.core.hash ...(map content.contents sibilant.macros.namespaces.core.quote)))\n\n         (do\n          (console.log (\"unknown content\" (prettify content)))\n          content)))\n\n(def sibilant.macros.namespaces.core.debug (val)\n     (set sibilant 'debug (eval (output-formatter (transpile val)))) null)\n\n(def sibilant.macros.namespaces.core.expand-quote (node-id expansions)\n     (var expanded-nodes\n          (map-node-for-quote-expansion (get sibilant.node-cache node-id) expansions))\n\n     (transpile expanded-nodes))\n\n\n(def sibilant.macros.namespaces.core.list (...args)\n       (var arg-segments [])\n       (if (empty? args) \"[]\"\n           (do\n            (def simple-list (args)\n                 [\"[ \" (interleave \", \" (map args (#(arg) arg.transpiled))) \" ]\"])\n\n            (args.for-each (#(arg)\n                  (if (node? arg 'dots) (arg-segments.push {transpiled (transpile arg)})\n                   (list? (last arg-segments)) (.push (last arg-segments) { transpiled (transpile arg)})\n                   (arg-segments.push [{transpiled (transpile arg)}]))))\n\n            (assign arg-segments (map arg-segments\n                                      (#(segment)\n                                        (if (list? segment)\n                                            (simple-list segment)\n                                            segment.transpiled))))\n\n            (if (= 1 (length arg-segments))\n                (first arg-segments)\n                [(first arg-segments) \".concat(\" (interleave \", \" (rest arg-segments))\")\"]))))\n\n\n(def sibilant.macros.namespaces.core.call (fn-name ...args)\n     (if (any? args (#> (node? #0 'dots)))\n           (macros.apply fn-name (macros.list ...args))\n           [ (transpile fn-name)\n                   \"(\" (interleave \", \" (map args transpile)) \")\" ]))\n\n(def sibilant.macros.namespaces.core.dots (...contents)\n     (transpile contents))\n\n(def sibilant.macros.namespaces.core.include (...files)\n     (pipe files\n           (.map (#(file)\n                   (sibilant.with-default-search-path\n                    (#> (pipe file\n                              (transpile)\n                              (output-formatter)\n                              (eval)\n                              (sibilant.include))))))\n           (interleave \"\\n\")))\n\n\n(def sibilant.macros.namespaces.core.docs (...options)\n     (var options-string undefined\n          options-hash {})\n\n     (when (odd? options.length)\n           (if (node? (first options) 'string)\n               (assign options-string (options.shift))\n\n               (node? (last options) 'string)\n               (assign options-string  (options.pop))))\n\n     (bulk-map options (#(key value)\n                         (set options-hash (pipe key (transpile) (output-formatter)) value)))\n\n     (when (and (has-key? options-hash 'examples) (node? options-hash.examples 'bracket))\n           (set options-hash 'examples options-hash.examples.contents))\n\n     (when (has-key? options-hash 'example)\n           (when (has-key? options-hash 'examples) (error \"please provide example OR examples, not both\"))\n           (set options-hash 'examples [options-hash.example])\n           (delete options-hash.example))\n\n     (when options-string\n           (set options-hash 'doc-string (pipe options-string\n                                               (transpile)\n                                               (output-formatter)\n                                               (eval))))\n\n     (set sibilant.docs 'last-doc options-hash)\n     null)\n","(namespace core)\n\n(docs \"the simplest way to conditionally execute code.\"\n      example (ternary (< 50 100)\n                       \"fifty is less than 100\"\n                       \"fifty is more than 100\"))\n\n(macro ternary (cond if-true if-false)\n       [\"(\" (transpile cond) \") ? \"\n            (transpile if-true) \" : \"\n            (transpile if-false)])\n\n\n\n\n\n\n(docs \"combines elements of array `arr` into a string,\ninserting `glue` string between each element\nfixme: incorrect argument order\"\n      example (join \" \" [ 'a 'few 'words ]))\n      \n(macro join (glue arr)\n       [\"(\" (transpile arr) \").join(\" (transpile glue) \")\"])\n\n\n\n\n\n;; used only for bootstrapping\n(macro set (arr ...kv-pairs)\n       (interleave \"\\n\" (bulk-map kv-pairs\n                                  (#(k v)\n                                    (as-statement [\"(\" (transpile arr) \")\"\n                                                    \"[\" (transpile k) \"] = \" (transpile v) ])))))\n(macro var (...pairs)\n       (as-statement\n        [\"var \"\n         (interleave \",\\n    \"\n               (bulk-map pairs\n                         (#(name value)\n                           [ (transpile name) \" = \" (transpile value) ])))\n         ]))\n\n(macro get (obj ...keys)\n       [\"(\" (transpile obj) \")\" (map keys (#(key)\n                                            [\"[\" (transpile key) \"]\"]))])\n\n\n\n\n\n(docs \"stores a duplicate copy of `current-macro-name` as\n`new-macro-name` in current namespace.  No output.\")\n\n(macro alias-macro (current-macro-name new-macro-name)\n       (var current-macro-name (output-formatter (transpile current-macro-name))\n            new-macro-name (output-formatter (transpile new-macro-name)))\n       (set sibilant.macros.namespace\n            new-macro-name (get sibilant.macros.namespace current-macro-name))\n       null)\n\n\n\n\n\n(docs \"calls the `method` on `object` as a function with `args` as the arguments\"\n      example (send object method first-argument second-argument third-argument))\n\n(macro send (object method ...args)\n       [(transpile object) \".\" (transpile method)\n               \"(\" (interleave \", \" (map args transpile)) \")\"])\n\n\n\n\n\n(docs \"calls the function `fn` with arguments passed as an array in `arglist`\"\n      example (apply my-function [ first-arg second-arg third-arg ]))\n\n(macro apply (fn arglist)\n       '(.apply @fn this @arglist))\n\n\n\n\n(docs \"builds an array with `first` as the zeroth index and the\nelements provided by array `rest` as the subsequent elements, as\nsiblings with `first`.  deprecated\"\n      example (cons 1 [ 2 3 4 ]))\n\n(macro cons (first rest)\n       [\"[ \" (transpile first) \" ].concat(\" (transpile rest) \")\"])\n\n\n\n\n(docs \"adds `additional` elements onto the right-side (tail) of `list`. deprecated\"\nexample (append [ 1 2 3 ] 4 5 6))\n(macro append (list ...additional)\n       '(.concat @list (list ...@additional)))\n\n\n\n\n\n(docs \"fetches length attribute from `arr`\"\n      example (length [ 1 2 3 ]))\n(macro length (arr)\n       '(get @arr 'length))\n\n\n\n(macro first (arr) '(get @arr 0))\n(macro second (arr) '(get @arr 1))\n(macro third (arr) '(get @arr 2))\n(macro fourth (arr) '(get @arr 3))\n(macro fifth (arr) '(get @arr 4))\n(macro sixth (arr) '(get @arr 5))\n(macro seventh (arr) '(get @arr 6))\n(macro eighth (arr) '(get @arr 7))\n(macro ninth (arr) '(get @arr 8))\n\n(docs \"fetches all but the first item of `arr`\"\n      example (rest [ 1 2 3 ]))\n(macro rest (arr) '(.slice @arr 1))\n\n(docs \"fetches just the last element of `arr` by slicing.\"\n      example (last [ 1 2 3 ]))\n(macro last (arr) '(first (.slice @arr -1)))\n\n\n(macro = (a b) [ (transpile a) \" === \" (transpile b) ])\n\n(docs \"adds `args` using the javascript `+` operator. Since javascript\noverloads this for string concatenation, this macro can be used for\nthis as well.\"\n      examples [ (+ 1 2 3) (+ 'hello 'world) ])\n(macro +   (...args)\n       [\"(\" (interleave \" + \" (map args transpile)) \")\"])\n\n\n(docs \"subtracts each subsequent element of `args`\"\n      examples [ (- 2 1) (- 10 5 1) ])\n(macro -   (...args)\n       [\"(\" (interleave \" - \" (map args transpile)) \")\"])\n\n(docs \"multiplies elements of `args`\"\n      example (* 3 4 5))\n(macro *   (...args)\n       [\"(\" (interleave \" * \" (map args transpile)) \")\"])\n\n;; (docs \"divides each subsequent element of `args`\"\n;;       examples [ (/ 1 2)\n;;                  (/ 1 2 4) ])\n(macro /   (...args)\n           [\"(\" (interleave \" / \" (map args transpile)) \")\"])\n(macro or  (...args)\n       [\"(\" (interleave \" || \" (map args transpile)) \")\"])\n\n(macro and (...args)\n       (ternary (= 1 (length args)) (transpile (first args))\n                [\"(\" (interleave \" && \" (map args transpile)) \")\"]))\n\n(macro mod (...args)\n       [\"(\" (interleave \" % \" (map args transpile)) \")\"])\n\n(macro infix-comparator (comparator args)\n       [\"(\" (interleave \" && \"\n                  (map (args.slice 0 -1)\n                       (#(item index)\n                         [ item \" \" comparator \" \" (get args (+ 1 index))])))\n            \")\"])\n\n(macro >  (...args) (^infix-comparator  \">\"  (map args transpile)))\n(macro <  (...args) (^infix-comparator  \"<\"  (map args transpile)))\n(macro <= (...args) (^infix-comparator \"<=\"  (map args transpile)))\n(macro >= (...args) (^infix-comparator \">=\"  (map args transpile)))\n(macro != (...args) (^infix-comparator \"!==\" (map args transpile)))\n\n(macro pow (base exponent)\n       '(Math.pow @base @exponent))\n\n(macro incr-by (item increment)\n       [ (transpile item) \" += \" (transpile increment)])\n\n(macro incr (item)\n       [\"((\" (transpile item) \")++)\"])\n\n(macro decr (item)\n       [\"((\" (transpile item) \")--)\"])\n\n(macro new (...args)\n       [\"(new \" '(call ...@args) \")\"])\n\n(macro regex (string glim)\n       '(new RegExp @string @(or glim 'undefined)))\n\n(macro timestamp ()\n       [\"\\\"\" (.to-string (new Date)) \"\\\"\"])\n\n(macro zero? (item) '(= @item 0))\n\n(macro empty? (arr)\n       [\"((\" (transpile arr) \").length === 0)\"])\n\n(macro odd? (number)\n       '(= 1 (mod @number 2)))\n\n(macro even? (number)\n       '(= 0 (mod @number 2)))\n\n(macro typeof (thing) [\"typeof \" (transpile thing)])\n\n(macro string? (...things)\n       '(and ...@(map things (#(thing) '(= (typeof @thing) 'string)))))\n(macro function? (...things)\n       '(and ...@(map things (#(thing) '(= (typeof @thing) 'function)))))\n(macro undefined? (...things)\n       '(and ...@(map things (#(thing) '(= (typeof @thing) 'undefined)))))\n(macro defined? (...things)\n       '(and ...@(map things (#(thing) '(!= (typeof @thing) 'undefined)))))\n(macro number? (...things)\n       '(and ...@(map things (#(thing) '(= (typeof @thing) 'number)))))\n\n(macro if (arg truebody falsebody)\n       [\"(function() {\"\n        (indent [\"if (\" (transpile arg) \") {\"\n                        (indent '(do ...@truebody))\n                        \"} else {\"\n                        (indent '(do ...@falsebody))\n                        \"}\"])\n         \"})()\"])\n\n(macro pipe (...calls)\n       (inject undefined calls\n         (#(value item)\n           (var cloned (clone item))\n           (if (undefined? value)\n               cloned\n               (merge-into cloned\n                           { contents [ (first cloned.contents)\n                                        value\n                                        ...(rest cloned.contents) ] })))))\n\n\n(docs \"inserts `contents` transpiled to javascript as a comment in the\noutput file, removing it from execution.\"\n      example (comment (def foo () 1)))\n(macro comment (...contents)\n       (map contents (#(content)\n                       [\"// \"(recurse-map (transpile content)\n                                    (#(item)\n                                      (ternary item\n                                               (pipe item\n                                                     (transpile)\n                                                     (output-formatter)\n                                                     (.replace (regex \"\\n\" 'g) \"\\n// \"))\n                                               null)))])))\n\n\n(docs \"checks if `first-thing` is equal to all of the `other-things`.\nMost of the time, there is only one other thing. Javascript threequals\nis always used.  Please note that if evaluating `first-thing` has\nside-effects, they will be called `(length other-things)` times.\"\n      examples [ (= 1 2)\n                 (= 10 (+ 5 5) (- 15 5)) ])\n\n(macro = (first-thing ...other-things)\n       (var transpiled-first-thing (transpile first-thing))\n       [\"(\" (interleave \" &&\\n \"\n                  (map other-things\n                       (#(thing)\n                         [ transpiled-first-thing\n                                 \" === \"\n                                 (transpile thing) ])))\n            \")\"])\n\n\n(macro list? (thing)\n       (var transpiled (transpile thing))\n       [\"((\" transpiled \") && typeof (\" transpiled \") === \\\"object\\\" && (\"\n               transpiled \").constructor.name === \\\"Array\\\")\"])\n\n\n(macro when (arg ...body)\n       [\"(function() {\"\n        (indent [\"if (\" (transpile arg) \") {\"\n                        (indent '(do ...@body))\n                        \"}\"])\n        \"})()\"])\n\n\n(macro not (exp)\n       [\"(!\" (transpile exp) \")\"])\n\n(macro unless (arg ...body)\n       [\"(function() {\"\n        (indent [\"if (\" '(not @arg) \") {\"\n                        (indent '(do ...@body))\n                        \"}\"])\n        \"})()\"])\n\n\n(macro slice (arr start end)\n       '(.slice @arr @start @end))\n\n(macro inspect (...args)\n       (interleave \" + \\\"\\\\n\\\" + \"\n             (map args\n                  (#(arg)\n                    [\"\\\"\" arg \":\\\" + \" (transpile arg)]))))\n\n(macro each (item array ...body)\n       '(.for-each @array\n              (lambda @{ node this args item } ...@body)))\n\n(macro assign (...args)\n       (interleave \"\\n\"\n             (bulk-map args (#(name value)\n                              (as-statement [ (transpile name) \" = \"\n                                                    (transpile value)])))))\n\n\n\n(macro macro-expand (name)\n       (var macro (get macros (output-formatter (transpile name))))\n       (if macro\n           (macro.to-string)\n           \"undefined\"))\n\n(macro throw (...string)\n       [\"throw new Error (\" (interleave \" \" (map string transpile)) \")\"])\n\n(macro as-boolean (expr)\n       [\"(!!(\" (transpile expr) \"))\"])\n\n(macro try (tryblock catchblock)\n       [\"(function() {\"\n        (indent [\"try {\"\n                 (indent '(do @tryblock))\n                 \"} catch (e) {\"\n                 (indent '(do @catchblock))\n                 \"}\"])\n         \"})()\"])\n\n(macro log-pretty (label arg)\n       (var node this)\n       (when (undefined? arg)\n             (assign arg label\n                     label [\"\\\"\" (prettify label false) \"\\\"\"]))\n       `(console.log (concat @[\"\\\"\" node.file \":\" node.line \"\\\"\"] \" \" @label \" = \" (prettify @arg))))\n(alias-macro log-pretty pretty-log)\n\n\n(macro state (...pairs)\n       (if (= 1 (length pairs))\n           (get sibilant.state (output-formatter (transpile (first pairs))))\n           (do (bulk-map pairs (#(k v) (set sibilant.state (output-formatter (transpile k)) (eval (output-formatter (transpile v))))))\n               null)))\n\n(macro symbol ()\n       (var symbol-count (or (get sibilant.state 'symbol-count) 0)\n            new-symbol-count (+ 1 symbol-count))\n       (^state 'symbol-count new-symbol-count)\n       [\"$_symbol\" new-symbol-count \"_$\"])\n\n(macro while (condition ...block)\n       (var symbol (^symbol))\n       '(scoped-without-source\n         (var @symbol)\n         @[\"while (\" (transpile condition) \") {\"\n           (indent '(assign @symbol (scoped-without-source ...@block)))\n            \"}\"]\n         @symbol))\n\n(macro until (condition ...block)\n       '(while (not @condition) ...@block))\n\n(macro match? (regexp string)\n       '(.match @string @regexp))\n\n(macro match-regex? (string regexp-string glim)\n       '(match? (regex @regexp-string @glim) @string))\n\n(macro replace (string regexp-string replacement)\n       '(.replace @string\n              (regex @regexp-string)\n              @replacement))\n\n(macro replace-all (string regexp-string replacement)\n       '(.replace @string (regex @regexp-string 'g) @replacement))\n\n(macro thunk (...body)\n       '(lambda @{ node this args [] }\n       ...@(map-node body\n                 (#(node)\n                   (if (node? node 'arg-placeholder)\n                       '(argument @(replace node.token \"^#\" \"\"))\n                       node)))))\n(alias-macro thunk #>)\n\n(macro keys (obj)\n       '(Object.keys @obj))\n\n(macro delete (...objects)\n       (interleave \"\\n\" (map objects (#(obj)\n                                 (as-statement [\"delete \" (transpile obj)])))))\n\n(macro delmacro (...macro-names)\n       (each (macro-name) macro-names\n             (delete (get sibilant.macros.namespace (output-formatter (transpile macro-name)))))\n       null)\n(alias-macro delmacro delete-macro)\n\n\n(macro rename-macro (current-macro-name desired-macro-name)\n       (^alias-macro current-macro-name desired-macro-name)\n       (^delmacro current-macro-name)\n       null)\n\n(macro arguments ()\n       [\"(Array.prototype.slice.apply(arguments))\"])\n\n(macro argument (n)\n       '(get arguments @n))\n\n(macro scoped (...body)\n       '(call (lambda @{node this args []} ...@body)))\n\n(macro scoped-without-source (...body)\n       [\"(function() {\" (indent '(do ...@body)) \"})()\"])\n       \n\n(macro each-key (as obj ...body)\n       '(scoped-without-source\n         @[\"for (var \" (transpile as) \" in \" (transpile obj) \") \"\n            (as-statement '(scoped-without-source ...@body))\n            ]\n         @obj))\n\n(macro switch (obj ...cases)\n       [\"(function() {\"\n         (indent [\"switch(\" (transpile obj) \") {\"\n                   (map cases (#(case-def)\n                                (var case-name-node (first case-def.contents)\n                                     case-labels (if (node? case-name-node 'expression 'bracket)\n                                                     case-name-node.contents\n                                                     [case-name-node])\n                                     case-string (interleave \"\\n\" (map case-labels (#(c)\n                                                                                     (if (= 'default c.token)\n                                                                                         \"default:\"\n                                                                                         [\"case \" (transpile c) \":\"])))))\n                                [\"\\n\" case-string (indent '(do ...@(rest case-def.contents)))]))\n                   \"}\"])\n         \"})()\"])\n\n(macro if (...args)\n       [\"(function() {\"\n        (indent\n         (interleave \" else \"\n               (bulk-map args\n                         (#(cond val)\n                           (if (!= (typeof val) 'undefined)\n                                 [\"if (\" (transpile cond) \") {\"\n                                   (indent '(do @val))\n                                   \"}\"]\n                                 [\"{\" (indent '(do @cond)) \"}\"])))))\n        \"})()\"])\n\n(macro chain (object ...calls)\n       (if (= 0 calls.length) (transpile object)\n           (= 1 calls.length) '(send @object ...@(get (first calls) 'contents))\n           (do\n            (var lines (map calls (#(call index)\n                                    [\".\" (transpile (first call.contents))\n                                         \"(\" (interleave \", \" (map (rest call.contents) transpile)) \")\"])))\n\n            [ (transpile object)\n              (first lines)\n              \"\\n  \"\n              (recurse-indent\n               (interleave \"\\n\" (rest lines)))])))\n\n(macro chainable (...names)\n       (each (name) names\n             '(macro @name (target ...calls)\n                     '(chain (call @name @target) ...@calls))))\n\n(macro let (args body)\n       [\"let (\"\n         (interleave \", \" (bulk-map args\n                   (#(k v)\n                     [ (transpile k) \" = \" (transpile v) ])))\n         (if (undefined? body) \");\"\n             [\") {\" (indent (transpile body)) \"}\"])])\n\n(macro instance-of? (item type)\n       [\"(\" (transpile item) \" instanceof \" (transpile type) \")\"])\n\n(macro slice (list begin end)\n       [\"Array.prototype.slice.call(\" (transpile list)\n                                      \", \" (or (transpile begin) 0)\n                                      (if (defined? end) (\", \" (transpile end) \")\") \")\")])\n\n(macro includes? (list item)\n       '(pipe @list (.index-of @item) (!= -1)))\n\n(macro excludes? (list item)\n       '(pipe @list (.index-of @item) (= -1)))\n\n(macro exists? (thing)\n       '(and (defined? @thing) (!= @thing null)))\n\n(macro with-state (k v ...body)\n       (var before (^state k))\n       (^state k v)\n       (var return-value\n            (interleave \"\\n\" (map body transpile)))\n       (^state k before)\n       return-value)\n\n(macro join (glue arr)\n       (if (and (defined? glue) (undefined? arr))\n           (assign arr glue glue undefined))\n       [\"(\" (transpile arr) \").join(\" (if glue (transpile glue) \"\\\"\\\"\") \")\"])\n\n(macro var (...pairs)\n       (var destructured [])\n       (bulk-map pairs (#(lhs rhs)\n                         (switch lhs.type\n                                 ('bracket\n                                  (var symbol (^symbol))\n                                  (destructured.push [symbol (transpile rhs)])\n                                  (each (item index) lhs.contents\n                                        (destructured.push [(transpile item) '(get @symbol @index)]))\n                                  (destructured.push [symbol 'undefined]))\n                                 ('brace\n                                  (var symbol (^symbol))\n                                  (destructured.push [symbol (transpile rhs)])\n                                  (each (item index) lhs.contents\n                                        (var tr-item (transpile item))\n                                        (destructured.push [tr-item '(get @symbol @[\"\\\"\" tr-item \"\\\"\"])]))\n                                  (destructured.push [symbol 'undefined]))\n\n                                 (default\n                                  (destructured.push [(transpile lhs)\n                                                       (if rhs (transpile rhs) 'undefined)])))))\n\n       (as-statement\n        [\"var \" (interleave \",\\n    \"\n           (map destructured\n                (#(pair)\n                  [(first pair) \" = \" (second pair)]\n                  )))]))\n\n(macro default (...pairs)\n       (interleave \"\\n\" (bulk-map pairs (#(name value)\n                                  '(assign @name (ternary (defined? @name) @name @value))))))\n\n\n(macro import-namespace (namespace)\n       (var namespace-as-string (output-formatter (transpile namespace)))\n       (unless (sibilant.macros.namespaces.has-own-property namespace-as-string)\n               (set sibilant.macros.namespaces namespace-as-string {}))\n       (sibilant.macros.search-path.unshift namespace-as-string)\n       undefined)\n\n\n(macro namespace (namespace)\n       `(import-namespace @namespace)\n       (set sibilant.macros 'namespace (get sibilant.macros.namespaces (output-formatter (transpile namespace))))\n       undefined)\n\n\n\n\n\n\n(docs \"checks if `object` has property `key`.  returns true or false.\"\n      example (has-key? object 'a))\n\n(macro has-key? (object key)\n       `(.has-own-property @object @key))\n\n\n\n\n\n\n\n(docs \"retreives object properties, potentially deeply. If more than one `keys` are provided,\n`get` fetches deeply into nested objects or arrays.\nWhen javascript dot notation can be used (`a.b = 3`), it is.\nOtherwise, bracket notation is used.\"\n      examples [ (get an-object 'static-attribute-name)\n                 (get object dynamic-attribute-name)\n                 (get object \"these attributes\" \"can't be dotted\")\n                 (get array 0)\n                 (get object 'a 'b c)\n                 (get array 0 1 2) ])\n\n\n(macro get (obj ...keys)\n       [(transpile obj)\n         (map keys (#(key)\n                     (var transpiled (transpile key)\n                          output (output-formatter transpiled))\n\n                     (if (match-regex? output \"^\\\"[a-zA-Z0-9]+\\\"$\")\n                         [\".\" (replace-all output \"\\\"\" \"\") ]\n                         [\"[\" transpiled \"]\"])))])\n\n\n\n\n\n\n\n\n\n\n(docs \"assigns object properties to `arr` in pairs, alternating between keys and values.\nWhen javascript dot notation can be used (`a.b = 3`), it is.  Otherwise, bracket notation is used\"\n      examples [ (set an-object 'static-attribute-name 'value)\n                 (set object dynamic-attribute-name \"key name determined at runtime\")\n                 (set array 0 \"first element of array\")\n                 (set object \"can't be dotted\" 'value)\n                 (set object 'first-attribute 'first-value\n                      'second-attribute 'second-value) ])\n\n(macro set (arr ...kv-pairs)\n       (interleave \"\\n\" (bulk-map kv-pairs (#(k v) `(assign (get @arr @k) @v)))))\n\n\n"]}