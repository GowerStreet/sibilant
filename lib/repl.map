{"version":3,"sources":["/Users/jbr/code/sibilant/src/repl.sibilant","/Users/jbr/code/sibilant/include/macros.sibilant"],"names":[],"mappings":"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","sourcesContent":["(.install (require \"source-map-support\"))\n(meta \"//# sourceMappingURL=./repl.map\\n\")\n\n(var input      (process.open-stdin)\n     output     process.stdout\n     vm         (require 'vm)\n     readline   (.create-interface (require 'readline) input output)\n     sibilant   (require \"./sibilant\")\n     cardinal   (require 'cardinal)\n     context    undefined\n     cmd-buffer \"\"\n     util       (require 'util))\n\n(def create-context ()\n     (var context (vm.create-context))\n     (set module 'filename (concat (process.cwd) \"/exec\"))\n     (set context\n          'module  module\n          'require require)\n     (each-key key global (set context key (get global key)))\n     context)\n\n(assign context (create-context))\n\n(def display-prompt ()\n     (readline.set-prompt\n      (concat (if (> cmd-buffer.length 10)\n                  (\"...\" (cmd-buffer.slice -10))\n                  (if (> cmd-buffer.length 0) cmd-buffer \"sibilant\"))\n              \"> \"))\n     (readline.prompt))\n\n(def handle-line (cmd)\n     (var js-line \"\")\n\n     (try\n      (do\n       (assign cmd-buffer (concat cmd-buffer cmd)\n               js-line (sibilant.sibilize cmd-buffer))\n\n       (var safe-js (if (= (first js-line) \"{\")\n                        (pipe js-line\n                              ((sibilant.resolve-macro 'scoped))\n                              (sibilant.transpile)\n                              (sibilant.output-formatter))\n                        js-line))\n\n       (try\n        (console.log (cardinal.highlight js-line))\n        (console.dir js-line))\n\n       (var result (vm.run-in-context safe-js context \"sibilant-repl\"))\n       (set readline.history 0 cmd-buffer)\n       (when (defined? result)\n             (output.write (\"result: \"\n                            (util.inspect result { colors true }) \"\\n\")))\n       (set context \"_\" result)\n       (assign cmd-buffer \"\"))\n      (do\n       (if (e.message.match /unclosed node:/)\n           (do\n            (assign cmd-buffer (concat cmd-buffer \" \"))\n            (readline.history.shift))\n           (do\n            (set readline.history 0 cmd-buffer)\n            (output.write (concat e.stack \"\\n\"))\n            (assign  cmd-buffer \"\")))))\n     (display-prompt))\n\n(readline.on 'line handle-line)\n\n(readline.on 'close (#>\n                     (output.write \"\\nexiting\")\n                     (input.destroy)))\n\n(display-prompt)\n","(namespace core)\n\n(docs \"the simplest way to conditionally execute code.\"\n      example (ternary (< 50 100)\n                       \"fifty is less than 100\"\n                       \"fifty is more than 100\"))\n\n(macro ternary (cond if-true if-false)\n       [\"(\" (transpile cond) \") ? \"\n            (transpile if-true) \" : \"\n            (transpile if-false)])\n\n\n\n\n\n\n(docs \"combines elements of array `arr` into a string,\ninserting `glue` string between each element\nfixme: incorrect argument order\"\n      example (join \" \" [ 'a 'few 'words ]))\n      \n(macro join (glue arr)\n       [\"(\" (transpile arr) \").join(\" (transpile glue) \")\"])\n\n\n\n\n\n;; used only for bootstrapping\n(macro set (arr ...kv-pairs)\n       (interleave \"\\n\" (bulk-map kv-pairs\n                                  (#(k v)\n                                    (as-statement [\"(\" (transpile arr) \")\"\n                                                    \"[\" (transpile k) \"] = \" (transpile v) ])))))\n(macro var (...pairs)\n       (as-statement\n        [\"var \"\n         (interleave \",\\n    \"\n               (bulk-map pairs\n                         (#(name value)\n                           [ (transpile name) \" = \" (transpile value) ])))\n         ]))\n\n(macro get (obj ...keys)\n       [\"(\" (transpile obj) \")\" (map keys (#(key)\n                                            [\"[\" (transpile key) \"]\"]))])\n\n\n\n\n\n(docs \"stores a duplicate copy of `current-macro-name` as\n`new-macro-name` in current namespace.  No output.\")\n\n(macro alias-macro (current-macro-name new-macro-name)\n       (var current-macro-name (output-formatter (transpile current-macro-name))\n            new-macro-name (output-formatter (transpile new-macro-name)))\n       (set sibilant.macros.namespace\n            new-macro-name (get sibilant.macros.namespace current-macro-name))\n       null)\n\n\n\n\n\n(docs \"calls the `method` on `object` as a function with `args` as the arguments\"\n      example (send object method first-argument second-argument third-argument))\n\n(macro send (object method ...args)\n       [(transpile object) \".\" (transpile method)\n               \"(\" (interleave \", \" (map args transpile)) \")\"])\n\n\n\n\n\n(docs \"calls the function `fn` with arguments passed as an array in `arglist`\"\n      example (apply my-function [ first-arg second-arg third-arg ]))\n\n(macro apply (fn arglist)\n       '(.apply @fn this @arglist))\n\n\n\n\n(docs \"builds an array with `first` as the zeroth index and the\nelements provided by array `rest` as the subsequent elements, as\nsiblings with `first`.  deprecated\"\n      example (cons 1 [ 2 3 4 ]))\n\n(macro cons (first rest)\n       [\"[ \" (transpile first) \" ].concat(\" (transpile rest) \")\"])\n\n\n\n\n(docs \"adds `additional` elements onto the right-side (tail) of `list`. deprecated\"\nexample (append [ 1 2 3 ] 4 5 6))\n(macro append (list ...additional)\n       '(.concat @list (list ...@additional)))\n\n\n\n\n\n(docs \"fetches length attribute from `arr`\"\n      example (length [ 1 2 3 ]))\n(macro length (arr)\n       '(get @arr 'length))\n\n\n\n(macro first (arr) '(get @arr 0))\n(macro second (arr) '(get @arr 1))\n(macro third (arr) '(get @arr 2))\n(macro fourth (arr) '(get @arr 3))\n(macro fifth (arr) '(get @arr 4))\n(macro sixth (arr) '(get @arr 5))\n(macro seventh (arr) '(get @arr 6))\n(macro eighth (arr) '(get @arr 7))\n(macro ninth (arr) '(get @arr 8))\n\n(docs \"fetches all but the first item of `arr`\"\n      example (rest [ 1 2 3 ]))\n(macro rest (arr) '(.slice @arr 1))\n\n(docs \"fetches just the last element of `arr` by slicing.\"\n      example (last [ 1 2 3 ]))\n(macro last (arr) '(first (.slice @arr -1)))\n\n\n(macro = (a b) [ (transpile a) \" === \" (transpile b) ])\n\n(docs \"adds `args` using the javascript `+` operator. Since javascript\noverloads this for string concatenation, this macro can be used for\nthis as well.\"\n      examples [ (+ 1 2 3) (+ 'hello 'world) ])\n(macro +   (...args)\n       [\"(\" (interleave \" + \" (map args transpile)) \")\"])\n\n\n(docs \"subtracts each subsequent element of `args`\"\n      examples [ (- 2 1) (- 10 5 1) ])\n(macro -   (...args)\n       [\"(\" (interleave \" - \" (map args transpile)) \")\"])\n\n(docs \"multiplies elements of `args`\"\n      example (* 3 4 5))\n(macro *   (...args)\n       [\"(\" (interleave \" * \" (map args transpile)) \")\"])\n\n(docs \"divides each subsequent element of `args`\"\n      examples [ (/ 1 2)\n                 (/ 1 2 3) ])\n(macro /   (...args)\n           [\"(\" (interleave \" / \" (map args transpile)) \")\"])\n\n\n(docs \"short circuiting operator returns the first element of `args` that evaluates to be truthy\"\n      example (or (= 1 2) (string? []) \"one is not two and an array is not a string\"))\n(macro or  (...args)\n       [\"(\" (interleave \" || \" (map args transpile)) \")\"])\n\n\n(docs \"returns the last element if all elements of `args` are truthy, or the\nfirst non-truthy element if it exists\"\n      example (and (string? \"string\") (number? 10) (= 1 1)))\n(macro and (...args)\n       (ternary (= 1 (length args)) (transpile (first args))\n                [\"(\" (interleave \" && \" (map args transpile)) \")\"]))\n\n(docs \"modulus operator\" example (mod 10 2))\n(macro mod (...args)\n       [\"(\" (interleave \" % \" (map args transpile)) \")\"])\n\n(macro infix-comparator (comparator args)\n       [\"(\" (interleave \" && \"\n                  (map (args.slice 0 -1)\n                       (#(item index)\n                         [ item \" \" comparator \" \" (get args (+ 1 index))])))\n            \")\"])\n\n(macro >  (...args) (^infix-comparator  \">\"  (map args transpile)))\n(macro <  (...args) (^infix-comparator  \"<\"  (map args transpile)))\n(macro <= (...args) (^infix-comparator \"<=\"  (map args transpile)))\n(macro >= (...args) (^infix-comparator \">=\"  (map args transpile)))\n(macro != (...args) (^infix-comparator \"!==\" (map args transpile)))\n\n(macro pow (base exponent)\n       '(Math.pow @base @exponent))\n\n(macro incr-by (item increment)\n       [ (transpile item) \" += \" (transpile increment)])\n\n(macro incr (item)\n       [\"((\" (transpile item) \")++)\"])\n\n(macro decr (item)\n       [\"((\" (transpile item) \")--)\"])\n\n(macro new (...args)\n       [\"(new \" '(call ...@args) \")\"])\n\n(macro regex (string glim)\n       '(new RegExp @string @(or glim 'undefined)))\n\n(macro timestamp ()\n       [\"\\\"\" (.to-string (new Date)) \"\\\"\"])\n\n(macro zero? (item) '(= @item 0))\n\n\n(docs \"returns true if the array `arr` has a length of zero\"\n      example (empty? []))\n(macro empty? (arr)\n       `(= 0 (length @arr)))\n\n(docs \"returns true if `number` is not divisible by 2\"\n      example (odd? 5))\n(macro odd? (number)\n       '(= 1 (mod @number 2)))\n\n(docs \"returns true if `number` is divisible by 2 with no remainder\"\n      example (even? 10))\n(macro even? (number)\n       '(= 0 (mod @number 2)))\n\n(macro typeof (thing) [\"typeof \" (transpile thing)])\n\n(macro string? (...things)\n       '(and ...@(map things (#(thing) '(= (typeof @thing) 'string)))))\n(macro function? (...things)\n       '(and ...@(map things (#(thing) '(= (typeof @thing) 'function)))))\n(macro undefined? (...things)\n       '(and ...@(map things (#(thing) '(= (typeof @thing) 'undefined)))))\n(macro defined? (...things)\n       '(and ...@(map things (#(thing) '(!= (typeof @thing) 'undefined)))))\n(macro number? (...things)\n       '(and ...@(map things (#(thing) '(= (typeof @thing) 'number)))))\n\n(macro if (arg truebody falsebody)\n       [\"(function() {\"\n        (indent [\"if (\" (transpile arg) \") {\"\n                        (indent '(do ...@truebody))\n                        \"} else {\"\n                        (indent '(do ...@falsebody))\n                        \"}\"])\n         \"})()\"])\n\n(macro pipe (...calls)\n       (inject undefined calls\n         (#(value item)\n           (var cloned (clone item))\n           (if (undefined? value)\n               cloned\n               (merge-into cloned\n                           { contents [ (first cloned.contents)\n                                        value\n                                        ...(rest cloned.contents) ] })))))\n\n\n(docs \"inserts `contents` transpiled to javascript as a comment in the\noutput file, removing it from execution.\"\n      example (comment (def foo () 1)))\n(macro comment (...contents)\n       (map contents (#(content)\n                       [\"// \"(recurse-map (transpile content)\n                                    (#(item)\n                                      (ternary item\n                                               (pipe item\n                                                     (transpile)\n                                                     (output-formatter)\n                                                     (.replace (regex \"\\n\" 'g) \"\\n// \"))\n                                               null)))])))\n\n\n(docs \"checks if `first-thing` is equal to all of the `other-things`.\nMost of the time, there is only one other thing. Javascript threequals\nis always used.  Please note that if evaluating `first-thing` has\nside-effects, they will be called `(length other-things)` times.\"\n      examples [ (= 1 2)\n                 (= 10 (+ 5 5) (- 15 5)) ])\n\n(macro = (first-thing ...other-things)\n       (var transpiled-first-thing (transpile first-thing))\n       [\"(\" (interleave \" &&\\n \"\n                  (map other-things\n                       (#(thing)\n                         [ transpiled-first-thing\n                                 \" === \"\n                                 (transpile thing) ])))\n            \")\"])\n\n\n(macro list? (thing)\n       (var transpiled (transpile thing))\n       [\"((\" transpiled \") && typeof (\" transpiled \") === \\\"object\\\" && (\"\n               transpiled \").constructor.name === \\\"Array\\\")\"])\n\n\n(macro when (arg ...body)\n       [\"(function() {\"\n        (indent [\"if (\" (transpile arg) \") {\"\n                        (indent '(do ...@body))\n                        \"}\"])\n        \"})()\"])\n\n\n(macro not (exp)\n       [\"(!\" (transpile exp) \")\"])\n\n(macro unless (arg ...body)\n       [\"(function() {\"\n        (indent [\"if (\" '(not @arg) \") {\"\n                        (indent '(do ...@body))\n                        \"}\"])\n        \"})()\"])\n\n\n(macro slice (arr start end)\n       '(.slice @arr @start @end))\n\n(macro inspect (...args)\n       (interleave \" + \\\"\\\\n\\\" + \"\n             (map args\n                  (#(arg)\n                    [\"\\\"\" arg \":\\\" + \" (transpile arg)]))))\n\n(macro each (item array ...body)\n       '(.for-each @array\n              (lambda @{ node this args item } ...@body)))\n\n(macro assign (...args)\n       (interleave \"\\n\"\n             (bulk-map args (#(name value)\n                              (as-statement [ (transpile name) \" = \"\n                                                    (transpile value)])))))\n\n\n\n(macro macro-expand (name)\n       (var macro (get macros (output-formatter (transpile name))))\n       (if macro\n           (macro.to-string)\n           \"undefined\"))\n\n(macro throw (...string)\n       [\"throw new Error (\" (interleave \" \" (map string transpile)) \")\"])\n\n(macro as-boolean (expr)\n       [\"(!!(\" (transpile expr) \"))\"])\n\n(macro try (tryblock catchblock)\n       [\"(function() {\"\n        (indent [\"try {\"\n                 (indent '(do @tryblock))\n                 \"} catch (e) {\"\n                 (indent '(do @catchblock))\n                 \"}\"])\n         \"})()\"])\n\n(macro log-pretty (label arg)\n       (var node this)\n       (when (undefined? arg)\n             (assign arg label\n                     label [\"\\\"\" (prettify label false) \"\\\"\"]))\n       `(console.log (concat @[\"\\\"\" node.file \":\" node.line \"\\\"\"] \" \" @label \" = \" (prettify @arg))))\n(alias-macro log-pretty pretty-log)\n\n\n(macro state (...pairs)\n       (if (= 1 (length pairs))\n           (get sibilant.state (output-formatter (transpile (first pairs))))\n           (do (bulk-map pairs (#(k v) (set sibilant.state (output-formatter (transpile k)) (eval (output-formatter (transpile v))))))\n               null)))\n\n(macro symbol ()\n       (var symbol-count (or (get sibilant.state 'symbol-count) 0)\n            new-symbol-count (+ 1 symbol-count))\n       (^state 'symbol-count new-symbol-count)\n       [\"$_symbol\" new-symbol-count \"_$\"])\n\n(macro while (condition ...block)\n       (var symbol (^symbol))\n       '(scoped-without-source\n         (var @symbol)\n         @[\"while (\" (transpile condition) \") {\"\n           (indent '(assign @symbol (scoped-without-source ...@block)))\n            \"}\"]\n         @symbol))\n\n(macro until (condition ...block)\n       '(while (not @condition) ...@block))\n\n(macro match? (regexp string)\n       '(.match @string @regexp))\n\n(macro match-regex? (string regexp-string glim)\n       '(match? (regex @regexp-string @glim) @string))\n\n(macro replace (string regexp-string replacement)\n       '(.replace @string\n              (regex @regexp-string)\n              @replacement))\n\n(macro replace-all (string regexp-string replacement)\n       '(.replace @string (regex @regexp-string 'g) @replacement))\n\n(macro thunk (...body)\n       '(lambda @{ node this args [] }\n       ...@(map-node body\n                 (#(node)\n                   (if (node? node 'arg-placeholder)\n                       '(argument @(replace node.token \"^#\" \"\"))\n                       node)))))\n(alias-macro thunk #>)\n\n(macro keys (obj)\n       '(Object.keys @obj))\n\n(macro delete (...objects)\n       (interleave \"\\n\" (map objects (#(obj)\n                                 (as-statement [\"delete \" (transpile obj)])))))\n\n(macro delmacro (...macro-names)\n       (each (macro-name) macro-names\n             (delete (get sibilant.macros.namespace (output-formatter (transpile macro-name)))))\n       null)\n(alias-macro delmacro delete-macro)\n\n\n(macro rename-macro (current-macro-name desired-macro-name)\n       (^alias-macro current-macro-name desired-macro-name)\n       (^delmacro current-macro-name)\n       null)\n\n(macro arguments ()\n       [\"(Array.prototype.slice.apply(arguments))\"])\n\n(macro argument (n)\n       '(get arguments @n))\n\n(macro scoped (...body)\n       '(call (lambda @{node this args []} ...@body)))\n\n(macro scoped-without-source (...body)\n       [\"(function() {\" (indent '(do ...@body)) \"})()\"])\n       \n\n(macro each-key (as obj ...body)\n       '(scoped-without-source\n         @[\"for (var \" (transpile as) \" in \" (transpile obj) \") \"\n            (as-statement '(scoped-without-source ...@body))\n            ]\n         @obj))\n\n(macro switch (obj ...cases)\n       [\"(function() {\"\n         (indent [\"switch(\" (transpile obj) \") {\"\n                   (map cases (#(case-def)\n                                (var case-name-node (first case-def.contents)\n                                     case-labels (if (node? case-name-node 'expression 'bracket)\n                                                     case-name-node.contents\n                                                     [case-name-node])\n                                     case-string (interleave \"\\n\" (map case-labels (#(c)\n                                                                                     (if (= 'default c.token)\n                                                                                         \"default:\"\n                                                                                         [\"case \" (transpile c) \":\"])))))\n                                [\"\\n\" case-string (indent '(do ...@(rest case-def.contents)))]))\n                   \"}\"])\n         \"})()\"])\n\n(macro if (...args)\n       [\"(function() {\"\n        (indent\n         (interleave \" else \"\n               (bulk-map args\n                         (#(cond val)\n                           (if (!= (typeof val) 'undefined)\n                                 [\"if (\" (transpile cond) \") {\"\n                                   (indent '(do @val))\n                                   \"}\"]\n                                 [\"{\" (indent '(do @cond)) \"}\"])))))\n        \"})()\"])\n\n(macro chain (object ...calls)\n       (if (= 0 calls.length) (transpile object)\n           (= 1 calls.length) '(send @object ...@(get (first calls) 'contents))\n           (do\n            (var lines (map calls (#(call index)\n                                    [\".\" (transpile (first call.contents))\n                                         \"(\" (interleave \", \" (map (rest call.contents) transpile)) \")\"])))\n\n            [ (transpile object)\n              (first lines)\n              \"\\n  \"\n              (recurse-indent\n               (interleave \"\\n\" (rest lines)))])))\n\n(macro chainable (...names)\n       (each (name) names\n             '(macro @name (target ...calls)\n                     '(chain (call @name @target) ...@calls))))\n\n(macro let (args body)\n       [\"let (\"\n         (interleave \", \" (bulk-map args\n                   (#(k v)\n                     [ (transpile k) \" = \" (transpile v) ])))\n         (if (undefined? body) \");\"\n             [\") {\" (indent (transpile body)) \"}\"])])\n\n(macro instance-of? (item type)\n       [\"(\" (transpile item) \" instanceof \" (transpile type) \")\"])\n\n(macro slice (list begin end)\n       [\"Array.prototype.slice.call(\" (transpile list)\n                                      \", \" (or (transpile begin) 0)\n                                      (if (defined? end) (\", \" (transpile end) \")\") \")\")])\n\n(macro includes? (list item)\n       '(pipe @list (.index-of @item) (!= -1)))\n\n(macro excludes? (list item)\n       '(pipe @list (.index-of @item) (= -1)))\n\n(macro exists? (thing)\n       '(and (defined? @thing) (!= @thing null)))\n\n(macro with-state (k v ...body)\n       (var before (^state k))\n       (^state k v)\n       (var return-value\n            (interleave \"\\n\" (map body transpile)))\n       (^state k before)\n       return-value)\n\n(macro join (glue arr)\n       (if (and (defined? glue) (undefined? arr))\n           (assign arr glue glue undefined))\n       [\"(\" (transpile arr) \").join(\" (if glue (transpile glue) \"\\\"\\\"\") \")\"])\n\n(macro var (...pairs)\n       (var destructured [])\n       (bulk-map pairs (#(lhs rhs)\n                         (switch lhs.type\n                                 ('bracket\n                                  (var symbol (^symbol))\n                                  (destructured.push [symbol (transpile rhs)])\n                                  (each (item index) lhs.contents\n                                        (destructured.push [(transpile item) '(get @symbol @index)]))\n                                  (destructured.push [symbol 'undefined]))\n                                 ('brace\n                                  (var symbol (^symbol))\n                                  (destructured.push [symbol (transpile rhs)])\n                                  (each (item index) lhs.contents\n                                        (var tr-item (transpile item))\n                                        (destructured.push [tr-item '(get @symbol @[\"\\\"\" tr-item \"\\\"\"])]))\n                                  (destructured.push [symbol 'undefined]))\n\n                                 (default\n                                  (destructured.push [(transpile lhs)\n                                                       (if rhs (transpile rhs) 'undefined)])))))\n\n       (as-statement\n        [\"var \" (interleave \",\\n    \"\n           (map destructured\n                (#(pair)\n                  [(first pair) \" = \" (second pair)]\n                  )))]))\n\n(macro default (...pairs)\n       (interleave \"\\n\" (bulk-map pairs (#(name value)\n                                  '(assign @name (ternary (defined? @name) @name @value))))))\n\n\n(macro import-namespace (namespace)\n       (var namespace-as-string (output-formatter (transpile namespace)))\n       (unless (sibilant.macros.namespaces.has-own-property namespace-as-string)\n               (set sibilant.macros.namespaces namespace-as-string {}))\n       (sibilant.macros.search-path.unshift namespace-as-string)\n       undefined)\n\n\n(macro namespace (namespace)\n       `(import-namespace @namespace)\n       (set sibilant.macros 'namespace (get sibilant.macros.namespaces (output-formatter (transpile namespace))))\n       undefined)\n\n\n\n\n\n\n(docs \"checks if `object` has property `key`.  returns true or false.\"\n      example (has-key? object 'a))\n\n(macro has-key? (object key)\n       `(.has-own-property @object @key))\n\n\n\n\n\n\n\n(docs \"retreives object properties, potentially deeply. If more than one `keys` are provided,\n`get` fetches deeply into nested objects or arrays.\nWhen javascript dot notation can be used (`a.b = 3`), it is.\nOtherwise, bracket notation is used.\"\n      examples [ (get an-object 'static-attribute-name)\n                 (get object dynamic-attribute-name)\n                 (get object \"these attributes\" \"can't be dotted\")\n                 (get array 0)\n                 (get object 'a 'b c)\n                 (get array 0 1 2) ])\n\n\n(macro get (obj ...keys)\n       [(transpile obj)\n         (map keys (#(key)\n                     (var transpiled (transpile key)\n                          output (output-formatter transpiled))\n\n                     (if (match-regex? output \"^\\\"[a-zA-Z0-9]+\\\"$\")\n                         [\".\" (replace-all output \"\\\"\" \"\") ]\n                         [\"[\" transpiled \"]\"])))])\n\n\n\n\n\n\n\n\n\n\n(docs \"assigns object properties to `arr` in pairs, alternating between keys and values.\nWhen javascript dot notation can be used (`a.b = 3`), it is.  Otherwise, bracket notation is used\"\n      examples [ (set an-object 'static-attribute-name 'value)\n                 (set object dynamic-attribute-name \"key name determined at runtime\")\n                 (set array 0 \"first element of array\")\n                 (set object \"can't be dotted\" 'value)\n                 (set object 'first-attribute 'first-value\n                      'second-attribute 'second-value) ])\n\n(macro set (arr ...kv-pairs)\n       (interleave \"\\n\" (bulk-map kv-pairs (#(k v) `(assign (get @arr @k) @v)))))\n\n\n"]}