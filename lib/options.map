{"version":3,"sources":["/Users/jbr/code/sibilant/include/functional.sibilant","/Users/jbr/code/sibilant/include/macros.sibilant","/Users/jbr/code/sibilant/src/options.sibilant"],"names":[],"mappings":"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","sourcesContent":["(def bulk-map (arr fn)\n  (var index 0\n          group-size fn.length\n          ret-arr [])\n\n  (while (< index arr.length)\n    (send ret-arr push\n          (apply fn (send arr slice\n                          index (+ index group-size))))\n    (incr-by index group-size))\n  ret-arr)\n\n(def inject (start items fn)\n  (var value start)\n  (when (list? items)\n    (each (item index) items\n      (assign value (fn value item index))))\n  value)\n\n(def map (items fn)\n  (inject [] items\n          (#(collector item index)\n            (send collector push (fn item index))\n            collector)))\n\n(def select (items fn)\n  (inject [] items\n          (#(collector item index)\n            (when (fn item index)\n              (send collector push item))\n            collector)))\n\n(def detect (items fn)\n  (var return-item undefined\n          index 0\n          items (or items []))\n\n  (until (or (= items.length index) return-item)\n         (when (fn (get items index) index)\n           (assign return-item (get items index)))\n         (incr index))\n\n  return-item)\n\n(def all? (items fn)\n     (undefined? (detect items (#(item index) (not (fn item index))))))\n\n(def none? (items fn)\n     (undefined? (detect items fn)))\n\n(def any? (items fn)\n     (defined? (detect items fn)))\n\n(def reject (items fn)\n  (var args [ items fn ])\n  (select items (thunk (not (apply fn arguments)))))\n\n(def compact (arr)\n     (select arr (#(item)\n                   (and\n                    (!= null item)\n                    (!= false item)\n                    (defined? item)))))\n\n(def interleave (glue arr)\n     (if (list? glue) (inject [] arr\n             (#(collector item index)\n               (collector.concat [item (get glue index)])))\n\n         \n     (inject [(first arr)] (rest arr)\n             (#(collector item index) (collector.concat [glue item])))))\n\n\n(def flatten (...items)\n  (inject [] items\n          (#(collector item)\n            (collector.concat\n             (if (list? item)\n               (apply flatten item)\n               item)))))\n\n\n(def recurse-map (item fn)\n     (if (list? item) (map item (#(subitem) (recurse-map subitem fn)))\n         (fn item)))\n\n(def pluck (items attribute)\n     (map items (#(item) (get item attribute))))\n\n(def merge-into (into from)\n     (each (key) (keys from) (set into key (get from key)))\n     into)\n\n(def clone (object)\n     (inject {} (keys object)\n             (#(collector key)\n               (set collector key (get object key))\n               collector)))\n\n(def map-values (object fn)\n     (inject {} (keys object)\n             (#(collector key index)\n               (set collector key (fn (get object key) key))\n               collector)))\n\n(def merge-with (into from)\n     (merge-into (clone into) from))\n","(namespace core)\n\n(macro ternary (cond if-true if-false)\n       [\"(\" (transpile cond) \") ? \"\n            (transpile if-true) \" : \"\n            (transpile if-false)])\n\n(macro join (glue arr)\n       [\"(\" (transpile arr) \").join(\" (transpile glue) \")\"])\n\n(macro set (arr ...kv-pairs)\n       (interleave \"\\n\" (bulk-map kv-pairs\n                                  (#(k v)\n                                    (as-statement [\"(\" (transpile arr) \")\"\n                                                    \"[\" (transpile k) \"] = \" (transpile v) ])))))\n\n(macro var (...pairs)\n       (as-statement\n        [\"var \"\n         (interleave \",\\n    \"\n               (bulk-map pairs\n                         (#(name value)\n                           [ (transpile name) \" = \" (transpile value) ])))\n         ]))\n\n(macro get (obj ...keys)\n       [\"(\" (transpile obj) \")\" (map keys (#(key)\n                                            [\"[\" (transpile key) \"]\"]))])\n\n(macro alias-macro (current-macro-name desired-macro-name)\n       (var current-macro-name (output-formatter (transpile current-macro-name))\n            desired-macro-name (output-formatter (transpile desired-macro-name)))\n       (set sibilant.macros.namespace\n            desired-macro-name (get sibilant.macros.namespace current-macro-name))\n       null)\n\n(macro send (object method ...args)\n       [(transpile object) \".\" (transpile method)\n               \"(\" (interleave \", \" (map args transpile)) \")\"])\n\n(macro apply (fn arglist)\n       '(send @fn apply this @arglist))\n\n(macro cons (first rest)\n       [\"[ \" (transpile first) \" ].concat(\" (transpile rest) \")\"])\n\n(macro append (list ...additional)\n       '(send @list concat (list ...@additional)))\n\n(macro length (arr)\n       '(get @arr 'length))\n\n(macro first (arr) '(get @arr 0))\n(macro second (arr) '(get @arr 1))\n(macro third (arr) '(get @arr 2))\n(macro fourth (arr) '(get @arr 3))\n(macro fifth (arr) '(get @arr 4))\n(macro sixth (arr) '(get @arr 5))\n(macro seventh (arr) '(get @arr 6))\n(macro eighth (arr) '(get @arr 7))\n(macro ninth (arr) '(get @arr 8))\n(macro rest (arr)\n       '(send @arr slice 1))\n\n(macro last (arr)\n       '(first (send @arr slice -1)))\n\n\n(macro = (a b) [ (transpile a) \" === \" (transpile b) ])\n(macro +   (...args)\n       [\"(\" (interleave \" + \" (map args transpile)) \")\"])\n(macro -   (...args)\n       [\"(\" (interleave \" - \" (map args transpile)) \")\"])\n(macro *   (...args)\n       [\"(\" (interleave \" * \" (map args transpile)) \")\"])\n(macro /   (...args)\n           [\"(\" (interleave \" / \" (map args transpile)) \")\"])\n(macro or  (...args)\n       [\"(\" (interleave \" || \" (map args transpile)) \")\"])\n\n(macro and (...args)\n       (ternary (= 1 (length args)) (transpile (first args))\n                [\"(\" (interleave \" && \" (map args transpile)) \")\"]))\n\n(macro mod (...args)\n       [\"(\" (interleave \" % \" (map args transpile)) \")\"])\n\n(macro infix-comparator (comparator args)\n       [\"(\" (interleave \" && \"\n                  (map (args.slice 0 -1)\n                       (#(item index)\n                         [ item \" \" comparator \" \" (get args (+ 1 index))])))\n            \")\"])\n\n(macro >  (...args) (^infix-comparator  \">\"  (map args transpile)))\n(macro <  (...args) (^infix-comparator  \"<\"  (map args transpile)))\n(macro <= (...args) (^infix-comparator \"<=\"  (map args transpile)))\n(macro >= (...args) (^infix-comparator \">=\"  (map args transpile)))\n(macro != (...args) (^infix-comparator \"!==\" (map args transpile)))\n\n(macro pow (base exponent)\n       '(Math.pow @base @exponent))\n\n(macro incr-by (item increment)\n       [ (transpile item) \" += \" (transpile increment)])\n\n(macro incr (item)\n       [\"((\" (transpile item) \")++)\"])\n\n(macro decr (item)\n       [\"((\" (transpile item) \")--)\"])\n\n(macro new (...args)\n       [\"(new \" '(call ...@args) \")\"])\n\n(macro regex (string glim)\n       '(new RegExp @string @(or glim 'undefined)))\n\n(macro timestamp ()\n       [\"\\\"\" (send (new Date) to-string) \"\\\"\"])\n\n(macro comment (...contents)\n       (map contents (#(content)\n                       [\"// \"(recurse-map (transpile content)\n                                    (#(item)\n                                      (ternary item\n                                               (send (output-formatter (transpile item)) replace\n                                                     (regex \"\\n\" 'g) \"\\n// \")\n                                               null)))])))\n\n(macro zero? (item) '(= @item 0))\n\n(macro empty? (arr)\n       [\"((\" (transpile arr) \").length === 0)\"])\n\n(macro odd? (number)\n       '(= 1 (mod @number 2)))\n\n(macro even? (number)\n       '(= 0 (mod @number 2)))\n\n(macro typeof (thing) [\"typeof \" (transpile thing)])\n\n\n(macro function? (...things)\n       '(and ...@(map things (#(thing) '(= (typeof @thing) 'function)))))\n(macro undefined? (...things)\n       '(and ...@(map things (#(thing) '(= (typeof @thing) 'undefined)))))\n(macro defined? (...things)\n       '(and ...@(map things (#(thing) '(!= (typeof @thing) 'undefined)))))\n(macro number? (...things)\n       '(and ...@(map things (#(thing) '(= (typeof @thing) 'number)))))\n\n(macro if (arg truebody falsebody)\n       [\"(function() {\"\n        (indent [\"if (\" (transpile arg) \") {\"\n                        (indent '(do ...@truebody))\n                        \"} else {\"\n                        (indent '(do ...@falsebody))\n                        \"}\"])\n         \"})()\"])\n\n(macro = (first-thing ...other-things)\n       (var transpiled-first-thing (transpile first-thing))\n       [\"(\" (interleave \" &&\\n \"\n                  (map other-things\n                       (#(thing)\n                         [ transpiled-first-thing\n                                 \" === \"\n                                 (transpile thing) ])))\n            \")\"])\n\n\n(macro string? (thing)\n       [\"typeof(\" (transpile thing) \") === \\\"string\\\"\"])\n\n(macro list? (thing)\n       (var transpiled (transpile thing))\n       [\"((\" transpiled \") && typeof (\" transpiled \") === \\\"object\\\" && (\"\n               transpiled \").constructor.name === \\\"Array\\\")\"])\n\n\n(macro when (arg ...body)\n       [\"(function() {\"\n        (indent [\"if (\" (transpile arg) \") {\"\n                        (indent '(do ...@body))\n                        \"}\"])\n        \"})()\"])\n\n\n(macro not (exp)\n       [\"(!\" (transpile exp) \")\"])\n\n(macro unless (arg ...body)\n       [\"(function() {\"\n        (indent [\"if (\" '(not @arg) \") {\"\n                        (indent '(do ...@body))\n                        \"}\"])\n        \"})()\"])\n\n\n(macro slice (arr start end)\n       '(send @arr slice @start @end))\n\n(macro inspect (...args)\n       (interleave \" + \\\"\\\\n\\\" + \"\n             (map args\n                  (#(arg)\n                    [\"\\\"\" arg \":\\\" + \" (transpile arg)]))))\n\n(macro each (item array ...body)\n       '(send @array for-each\n              (lambda @{ node this args item } ...@body)))\n\n(macro assign (...args)\n       (interleave \"\\n\"\n             (bulk-map args (#(name value)\n                              (as-statement [ (transpile name) \" = \"\n                                                    (transpile value)])))))\n\n\n\n(macro macro-expand (name)\n       (var macro (get macros (output-formatter (transpile name))))\n       (if macro\n           (macro.to-string)\n           \"undefined\"))\n\n(macro throw (...string)\n       [\"throw new Error (\" (interleave \" \" (map string transpile)) \")\"])\n\n(macro as-boolean (expr)\n       [\"(!!(\" (transpile expr) \"))\"])\n\n(macro try (tryblock catchblock)\n       [\"(function() {\"\n        (indent [\"try {\"\n                 (indent '(do @tryblock))\n                 \"} catch (e) {\"\n                 (indent '(do @catchblock))\n                 \"}\"])\n         \"})()\"])\n\n(macro log-pretty (label arg)\n       (var node this)\n       (when (undefined? arg)\n             (assign arg label\n                     label [\"\\\"\" (prettify label false) \"\\\"\"]))\n       `(console.log (concat @[\"\\\"\" node.file \":\" node.line \"\\\"\"] \" \" @label \" = \" (prettify @arg))))\n(alias-macro log-pretty pretty-log)\n\n\n(macro state (...pairs)\n       (if (= 1 (length pairs))\n           (get sibilant.state (output-formatter (transpile (first pairs))))\n           (do (bulk-map pairs (#(k v) (set sibilant.state (output-formatter (transpile k)) (eval (output-formatter (transpile v))))))\n               null)))\n\n(macro symbol ()\n       (var symbol-count (or (get sibilant.state 'symbol-count) 0)\n            new-symbol-count (+ 1 symbol-count))\n       (^state 'symbol-count new-symbol-count)\n       [\"$_symbol\" new-symbol-count \"_$\"])\n\n(macro while (condition ...block)\n       (var symbol (^symbol))\n       '(scoped-without-source\n         (var @symbol)\n         @[\"while (\" (transpile condition) \") {\"\n           (indent '(assign @symbol (scoped-without-source ...@block)))\n            \"}\"]\n         @symbol))\n\n(macro until (condition ...block)\n       '(while (not @condition) ...@block))\n\n(macro match? (regexp string)\n       '(send @string match @regexp))\n\n(macro match-regex? (string regexp-string glim)\n       '(match? (regex @regexp-string @glim) @string))\n\n(macro replace (string regexp-string replacement)\n       '(send @string replace\n              (regex @regexp-string)\n              @replacement))\n\n(macro replace-all (string regexp-string replacement)\n       '(send @string replace (regex @regexp-string 'g) @replacement))\n\n(macro thunk (...body)\n       '(lambda @{ node this args [] }\n       ...@(map-node body\n                 (#(node)\n                   (if (node? node 'arg-placeholder)\n                       '(argument @(replace node.token \"^#\" \"\"))\n                       node)))))\n(alias-macro thunk #>)\n\n(macro keys (obj)\n       '(Object.keys @obj))\n\n(macro delete (...objects)\n       (interleave \"\\n\" (map objects (#(obj)\n                                 (as-statement [\"delete \" (transpile obj)])))))\n\n(macro delmacro (...macro-names)\n       (each (macro-name) macro-names\n             (delete (get sibilant.macros.namespace (output-formatter (transpile macro-name)))))\n       null)\n(alias-macro delmacro delete-macro)\n\n\n(macro rename-macro (current-macro-name desired-macro-name)\n       (^alias-macro current-macro-name desired-macro-name)\n       (^delmacro current-macro-name)\n       null)\n\n(macro arguments ()\n       [\"(Array.prototype.slice.apply(arguments))\"])\n\n(macro argument (n)\n       '(get arguments @n))\n\n(macro scoped (...body)\n       '(call (lambda @{node this args []} ...@body)))\n\n(macro scoped-without-source (...body)\n       [\"(function() {\" (indent '(do ...@body)) \"})()\"])\n       \n\n(macro each-key (as obj ...body)\n       '(scoped-without-source\n         @[\"for (var \" (transpile as) \" in \" (transpile obj) \") \"\n            (as-statement '(scoped-without-source ...@body))\n            ]\n         @obj))\n\n(macro switch (obj ...cases)\n       [\"(function() {\"\n         (indent [\"switch(\" (transpile obj) \") {\"\n                   (map cases (#(case-def)\n                                (var case-name-node (first case-def.contents)\n                                     case-labels (if (or (node? case-name-node 'expression)\n                                                         (node? case-name-node 'bracket))\n                                                     case-name-node.contents\n                                                     [case-name-node])\n                                     case-string (interleave \"\\n\" (map case-labels (#(c)\n                                                                                     (if (= 'default c.token)\n                                                                                         \"default:\"\n                                                                                         [\"case \" (transpile c) \":\"])))))\n                                [\"\\n\" case-string (indent '(do ...@(rest case-def.contents)))]))\n                   \"}\"])\n         \"})()\"])\n\n(macro if (...args)\n       [\"(function() {\"\n        (indent\n         (interleave \" else \"\n               (bulk-map args\n                         (#(cond val)\n                           (if (!= (typeof val) 'undefined)\n                                 [\"if (\" (transpile cond) \") {\"\n                                   (indent '(do @val))\n                                   \"}\"]\n                                 [\"{\" (indent '(do @cond)) \"}\"])))))\n        \"})()\"])\n\n(macro chain (object ...calls)\n       (if (= 0 calls.length) (transpile object)\n           (= 1 calls.length) '(send @object ...@(get (first calls) 'contents))\n           (do\n            (var lines (map calls (#(call index)\n                                    [\".\" (transpile (first call.contents))\n                                         \"(\" (interleave \", \" (map (rest call.contents) transpile)) \")\"])))\n\n            [ (transpile object)\n              (first lines)\n              \"\\n  \"\n              (recurse-indent\n               (interleave \"\\n\" (rest lines)))])))\n\n(macro chainable (...names)\n       (each (name) names\n             '(macro @name (target ...calls)\n                     '(chain (call @name @target) ...@calls))))\n\n(macro let (args body)\n       [\"let (\"\n         (interleave \", \" (bulk-map args\n                   (#(k v)\n                     [ (transpile k) \" = \" (transpile v) ])))\n         (if (undefined? body) \");\"\n             [\") {\" (indent (transpile body)) \"}\"])])\n\n(macro instance-of? (item type)\n       [\"(\" (transpile item) \" instanceof \" (transpile type) \")\"])\n\n(macro slice (list begin end)\n       [\"Array.prototype.slice.call(\" (transpile list)\n                                      \", \" (or (transpile begin) 0)\n                                      (if (defined? end) (\", \" (transpile end) \")\") \")\")])\n\n(macro includes? (list item)\n       '(!= -1 (send @list index-of @item)))\n\n\n(macro excludes? (list item)\n       '(= -1 (send @list index-of @item)))\n\n(macro exists? (thing)\n       '(and (defined? @thing) (!= @thing null)))\n\n(macro with-state (k v ...body)\n       (var before (^state k))\n       (^state k v)\n       (var return-value\n            (interleave \"\\n\" (map body transpile)))\n       (^state k before)\n       return-value)\n\n(macro join (glue arr)\n       (if (and (defined? glue) (undefined? arr))\n           (assign arr glue glue undefined))\n       [\"(\" (transpile arr) \").join(\" (if glue (transpile glue) \"\\\"\\\"\") \")\"])\n\n(macro var (...pairs)\n       (var destructured [])\n       (bulk-map pairs (#(lhs rhs)\n                         (switch lhs.type\n                                 ('bracket\n                                  (var symbol (^symbol))\n                                  (destructured.push [symbol (transpile rhs)])\n                                  (each (item index) lhs.contents\n                                        (destructured.push [(transpile item) '(get @symbol @index)]))\n                                  (destructured.push [symbol 'undefined]))\n                                 ('brace\n                                  (var symbol (^symbol))\n                                  (destructured.push [symbol (transpile rhs)])\n                                  (each (item index) lhs.contents\n                                        (var tr-item (transpile item))\n                                        (destructured.push [tr-item '(get @symbol @[\"\\\"\" tr-item \"\\\"\"])]))\n                                  (destructured.push [symbol 'undefined]))\n\n                                 (default\n                                  (destructured.push [(transpile lhs)\n                                                       (if rhs (transpile rhs) 'undefined)])))))\n\n       (as-statement\n        [\"var \" (interleave \",\\n    \"\n           (map destructured\n                (#(pair)\n                  [(first pair) \" = \" (second pair)]\n                  )))]))\n\n(macro default (...pairs)\n       (interleave \"\\n\" (bulk-map pairs (#(name value)\n                                  '(assign @name (ternary (defined? @name) @name @value))))))\n\n\n(macro import-namespace (namespace)\n       (var namespace-as-string (output-formatter (transpile namespace)))\n       (unless (sibilant.macros.namespaces.has-own-property namespace-as-string)\n               (set sibilant.macros.namespaces namespace-as-string {}))\n       (sibilant.macros.search-path.unshift namespace-as-string)\n       undefined)\n\n(macro namespace (namespace)\n       `(import-namespace @namespace)\n       (set sibilant.macros 'namespace (get sibilant.macros.namespaces (output-formatter (transpile namespace))))\n       undefined)\n\n(macro has-key? (object key)\n       `(send @object has-own-property @key))\n\n(macro get (obj ...keys)\n       [(transpile obj)\n         (map keys (#(key)\n                     (var transpiled (transpile key)\n                          output (output-formatter transpiled))\n\n                     (if (match-regex? output \"^\\\"[a-zA-Z0-9]+\\\"$\")\n                         [\".\" (replace-all output \"\\\"\" \"\") ]\n                         [\"[\" transpiled \"]\"])))])\n\n(macro set (arr ...kv-pairs)\n       (interleave \"\\n\" (bulk-map kv-pairs (#(k v) `(assign (get @arr @k) @v)))))\n","(include \"../include/functional\")\n\n(def extract-options (config args)\n     (default args (process.argv.slice 2))\n     (var default-label 'unlabeled\n          current-label default-label\n          after-break false\n          config (or config {})\n          unlabeled [])\n\n     (def label? (item) (and (string? item) (send /^-/ test item)))\n\n     (def synonym-lookup (item)\n          (var config-entry (get config item))\n          (if (string? config-entry)\n              (synonym-lookup config-entry)\n              item))\n\n     (def takes-args? (item)\n          (!= false (get config (label-for item))))\n\n     (assign default-label (synonym-lookup default-label)\n             current-label default-label)\n\n     (def label-for (item)\n          (synonym-lookup (item.replace /^-+/ \"\")))\n\n     (def add-value (hash key value)\n          (var current-value (get hash key))\n          (when (undefined? current-value)\n                (assign current-value [])\n                (set hash key current-value))\n          (when (!= true value)\n                (current-value.push value)))\n\n     (def reset-label ()\n          (assign current-label default-label))\n\n     (inject {} args\n             (lambda (return-hash item index)\n                     (if (= \"--\" item) (assign after-break true)\n                         (if after-break\n                             (add-value return-hash 'after-break item)\n                             (if (label? item)\n                                 (do\n                                  (assign current-label (label-for item))\n                                  (add-value return-hash current-label true)\n                                  (when (not (takes-args? item)) (reset-label)))\n                                 (do\n                                  (add-value return-hash current-label item)\n                                  (reset-label)))))\n                     return-hash)))\n\n(def process-options (config)\n     (var options (extract-options config))\n     (when config\n           (def handle-pair (key value)\n                (var handle (get config key))\n                (when (string? handle) (handle-pair handle value))\n                (when (function? handle) (handle value options)))\n           (each (key) (keys options) (handle-pair key (get options key))))\n\n     options)\n\n(set module 'exports process-options)\n"]}