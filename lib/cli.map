{"version":3,"sources":["/Users/jbr/code/sibilant/src/cli.sibilant","/Users/jbr/code/sibilant-clean/include/macros.sibilant"],"names":[],"mappings":"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","sourcesContent":["(send (require \"source-map-support\") install)\n(meta \"//# sourceMappingURL=./cli.map\\n\")\n\n(var sibilant (require \"../lib/sibilant.js\")\n     path     (require 'path)\n     options  (require \"../lib/options.js\")\n     fs       (require 'fs)\n     mod      (require 'module))\n\n(def run-in-sandbox (js input-path)\n     (when (undefined? input-path)\n           (assign input-path \".\"))\n     (set require.main\n          'module-cache {}\n          'filename (fs.realpath-sync input-path)\n          'paths (mod.*node-module-paths\n                  (path.dirname\n                   (fs.realpath-sync input-path))))\n     (require.main.*compile js require.main.filename))\n\n\n(var cli {\n          v         'version\n           h         'help\n           unhandled 'help\n           f         'file\n           o         'output\n           x         'execute\n           e         'eval\n           i         'input\n           m         'sourcemap\n           after-break false\n           execute   false\n           unlabeled 'file})\n\n(def cli.version ()\n     (console.log (sibilant.version-string)))\n\n(def cli.repl (args) (require \"../lib/repl\"))\n\n(def read-stdin (fn)\n     (var stdin process.stdin\n          data \"\")\n     (stdin.resume)\n     (stdin.set-encoding \"utf8\")\n     (stdin.on 'data (#(chunk) (assign data (concat data chunk))))\n     (stdin.on 'end (#> (fn data))))\n\n(def cli.eval (args options)\n     (set options 'execute true)\n     (cli.input args options))\n\n(def cli.input (args options)\n     (def process (sibilant-code)\n          (var js-code (sibilant.sibilize sibilant-code))\n          (if options.execute\n              (run-in-sandbox js-code)\n              (console.log js-code)))\n     (if (empty? args)\n         (read-stdin process)\n         (process (first args))))\n\n(def cli.help (args options)\n     (fs.read-file (concat **dirname \"/../cli-help\") { encoding 'utf8 }\n                   (#(err data)\n                     (when err (throw err))\n                     (console.log data))))\n\n(var cli-options (options cli)\n     args (or cli-options.after-break []))\n\n(args.unshift (second process.argv) \"FILENAME\")\n\n(set process 'argv args 'ARGV args)\n\n(when (empty? (keys cli-options)) (cli.repl))\n\n(each (input-file) (or cli-options.file [])\n      (var input-path (path.join (process.cwd) input-file)\n           input-extname (path.extname input-path)\n           input-basename (path.basename input-path input-extname)\n           translated (if (= \".son\" input-extname)\n                          (sibilant.sibilize-json input-path)\n                          (sibilant.sibilize-file input-path))\n           output-dir (when cli-options.output\n                            (or (first cli-options.output)\n                                (path.dirname input-path)))\n           map-dir (when cli-options.sourcemap \n                         (or (first cli-options.sourcemap)\n                             output-dir))\n           output-extname (if (= \".son\" input-extname) \".json\" \".js\"))\n\n      (if output-dir (do\n                      (var output-path (concat (path.join output-dir input-basename)\n                                               output-extname))\n\n                      (fs.write-file output-path translated)\n                      (when map-dir\n                            (var map-path (concat (path.join map-dir input-basename) \".map\"))\n                            ;; yes, it's dumb that this reads the file twice\n                            (fs.write-file map-path (sibilant.sourcemap-file input-path))))\n          \n          cli-options.execute (run-in-sandbox translated input-path)\n\n          (console.log translated)))","(macro join (glue arr)\n       [\"(\" (transpile arr) \").join(\" (transpile glue) \")\"])\n\n(macro set (arr ...kv-pairs)\n       (interleave \"\\n\" (bulk-map kv-pairs\n                                  (#(k v)\n                                    (as-statement [\"(\" (transpile arr) \")\"\n                                                    \"[\" (transpile k) \"] = \" (transpile v) ])))))\n\n(macro get (obj ...keys)\n       [\"(\" (transpile obj) \")\" (map keys (#(key) [\"[\" (transpile key) \"]\"]))])\n\n(macro var (...pairs)\n       (as-statement\n        [\"var \"\n         (interleave \",\\n    \"\n               (bulk-map pairs\n                         (#(name value)\n                           [ (transpile name) \" = \" (transpile value) ])))\n         ]))\n\n(macro alias-macro (current-macro-name desired-macro-name)\n       (var current-macro-name (output-formatter (transpile current-macro-name))\n            desired-macro-name (output-formatter (transpile desired-macro-name)))\n       (set macros desired-macro-name (get macros current-macro-name))\n       null)\n\n(macro send (object method ...args)\n       [(transpile object) \".\" (transpile method)\n               \"(\" (interleave \", \" (map args transpile)) \")\"])\n\n(macro apply (fn arglist)\n       '(send @fn apply this @arglist))\n\n(macro cons (first rest)\n       [\"[ \" (transpile first) \" ].concat(\" (transpile rest) \")\"])\n\n(macro append (list ...additional)\n       '(send @list concat (list ...@additional)))\n\n(macro length (arr)\n       '(get @arr 'length))\n\n(macro ternary (cond if-true if-false)\n       [\"(\" (transpile cond) \") ? \"\n            (transpile if-true) \" : \"\n            (transpile if-false)])\n\n(macro first (arr) '(get @arr 0))\n(macro second (arr) '(get @arr 1))\n(macro third (arr) '(get @arr 2))\n(macro fourth (arr) '(get @arr 3))\n(macro fifth (arr) '(get @arr 4))\n(macro sixth (arr) '(get @arr 5))\n(macro seventh (arr) '(get @arr 6))\n(macro eighth (arr) '(get @arr 7))\n(macro ninth (arr) '(get @arr 8))\n(macro rest (arr)\n       '(send @arr slice 1))\n\n(macro last (arr)\n       '(first (send @arr slice -1)))\n\n\n(macro = (a b) [ (transpile a) \" === \" (transpile b) ])\n(macro +   (...args)\n       [\"(\" (interleave \" + \" (map args transpile)) \")\"])\n(macro -   (...args)\n       [\"(\" (interleave \" - \" (map args transpile)) \")\"])\n(macro *   (...args)\n       [\"(\" (interleave \" * \" (map args transpile)) \")\"])\n(macro /   (...args)\n           [\"(\" (interleave \" / \" (map args transpile)) \")\"])\n(macro or  (...args)\n       [\"(\" (interleave \" || \" (map args transpile)) \")\"])\n\n(macro and (...args)\n       (ternary (= 1 (length args)) (transpile (first args))\n                [\"(\" (interleave \" && \" (map args transpile)) \")\"]))\n\n(macro mod (...args)\n       [\"(\" (interleave \" % \" (map args transpile)) \")\"])\n\n(macro infix-comparator (comparator args)\n       [\"(\" (interleave \" && \"\n                  (map (args.slice 0 -1)\n                       (#(item index)\n                         [ item \" \" comparator \" \" (get args (+ 1 index))])))\n            \")\"])\n\n(macro >  (...args) (macros.infix-comparator  \">\"  (map args transpile)))\n(macro <  (...args) (macros.infix-comparator  \"<\"  (map args transpile)))\n(macro <= (...args) (macros.infix-comparator \"<=\"  (map args transpile)))\n(macro >= (...args) (macros.infix-comparator \">=\"  (map args transpile)))\n(macro != (...args) (macros.infix-comparator \"!==\" (map args transpile)))\n\n(macro pow (base exponent)\n       '(Math.pow @base @exponent))\n\n(macro incr-by (item increment)\n       [ (transpile item) \" += \" (transpile increment)])\n\n(macro incr (item)\n       [\"((\" (transpile item) \")++)\"])\n\n(macro decr (item)\n       [\"((\" (transpile item) \")--)\"])\n\n(macro new (...args)\n       [\"(new \" '(call ...@args) \")\"])\n\n(macro regex (string glim)\n       '(new RegExp @string @(or glim 'undefined)))\n\n(macro timestamp ()\n       [\"\\\"\" (send (new Date) to-string) \"\\\"\"])\n\n(macro comment (...contents)\n       (map contents (#(content)\n                       [\"// \"(recurse-map (transpile content)\n                                    (#(item)\n                                      (ternary item\n                                               (send (output-formatter (transpile item)) replace\n                                                     (regex \"\\n\" 'g) \"\\n// \")\n                                               null)))])))\n\n(macro zero? (item) '(= @item 0))\n\n(macro empty? (arr)\n       [\"((\" (transpile arr) \").length === 0)\"])\n\n(macro odd? (number)\n       '(= 1 (mod @number 2)))\n\n(macro even? (number)\n       '(= 0 (mod @number 2)))\n\n(macro typeof (thing) [\"typeof \" (transpile thing)])\n\n\n(macro function? (...things)\n       '(and ...@(map things (#(thing) '(= (typeof @thing) 'function)))))\n(macro undefined? (...things)\n       '(and ...@(map things (#(thing) '(= (typeof @thing) 'undefined)))))\n(macro defined? (...things)\n       '(and ...@(map things (#(thing) '(!= (typeof @thing) 'undefined)))))\n(macro number? (...things)\n       '(and ...@(map things (#(thing) '(= (typeof @thing) 'number)))))\n\n(macro if (arg truebody falsebody)\n       [\"(function() {\"\n        (indent [\"if (\" (transpile arg) \") {\"\n                        (indent '(do ...@truebody))\n                        \"} else {\"\n                        (indent '(do ...@falsebody))\n                        \"}\"])\n         \"})()\"])\n\n(macro = (first-thing ...other-things)\n       (var transpiled-first-thing (transpile first-thing))\n       [\"(\" (interleave \" &&\\n \"\n                  (map other-things\n                       (#(thing)\n                         [ transpiled-first-thing\n                                 \" === \"\n                                 (transpile thing) ])))\n            \")\"])\n\n\n(macro string? (thing)\n       [\"typeof(\" (transpile thing) \") === \\\"string\\\"\"])\n\n(macro list? (thing)\n       (var transpiled (transpile thing))\n       [\"((\" transpiled \") && typeof (\" transpiled \") === \\\"object\\\" && (\"\n               transpiled \").constructor.name === \\\"Array\\\")\"])\n\n\n(macro when (arg ...body)\n       [\"(function() {\"\n        (indent [\"if (\" (transpile arg) \") {\"\n                        (indent '(do ...@body))\n                        \"}\"])\n        \"})()\"])\n\n\n(macro not (exp)\n       [\"(!\" (transpile exp) \")\"])\n\n(macro unless (arg ...body)\n       [\"(function() {\"\n        (indent [\"if (\" '(not @arg) \") {\"\n                        (indent '(do ...@body))\n                        \"}\"])\n        \"})()\"])\n\n\n(macro slice (arr start end)\n       '(send @arr slice @start @end))\n\n(macro inspect (...args)\n       (interleave \" + \\\"\\\\n\\\" + \"\n             (map args\n                  (#(arg)\n                    [\"\\\"\" arg \":\\\" + \" (transpile arg)]))))\n\n(macro each (item array ...body)\n       '(send @array for-each\n              (lambda @{ node this args item } ...@body)))\n\n(macro assign (...args)\n       (interleave \"\\n\"\n             (bulk-map args (#(name value)\n                              (as-statement [ (transpile name) \" = \"\n                                                    (transpile value)])))))\n\n\n\n(macro macro-expand (name)\n       (var macro (get macros (output-formatter (transpile name))))\n       (if macro\n           (macro.to-string)\n           \"undefined\"))\n\n(macro throw (...string)\n       [\"throw new Error (\" (interleave \" \" (map string transpile)) \")\"])\n\n(macro as-boolean (expr)\n       [\"(!!(\" (transpile expr) \"))\"])\n\n(macro try (tryblock catchblock)\n       [\"(function() {\"\n        (indent [\"try {\"\n                 (indent '(do @tryblock))\n                 \"} catch (e) {\"\n                 (indent '(do @catchblock))\n                 \"}\"])\n        \"})()\"])\n\n(macro state (...pairs)\n       (set macros.state 'data (or macros.state.data {}))\n\n       (if (= 1 (length pairs))\n           (get macros.state.data (output-formatter (transpile (first pairs))))\n           (do (bulk-map pairs (#(k v) (set macros.state.data (output-formatter (transpile k)) (eval (output-formatter (transpile v))))))\n               null)))\n\n(macro symbol ()\n       (var symbol-count (or (macros.state 'symbol-count) 0)\n            new-symbol-count (+ 1 symbol-count))\n       (macros.state 'symbol-count new-symbol-count)\n       [\"$_symbol\" new-symbol-count \"_$\"])\n\n(macro while (condition ...block)\n       (var symbol (macros.symbol))\n       '(scoped-without-source\n         (var @symbol)\n         @[\"while (\" (transpile condition) \") {\"\n           (indent '(assign @symbol (scoped-without-source ...@block)))\n            \"}\"]\n         @symbol))\n\n(macro until (condition ...block)\n       '(while (not @condition) ...@block))\n\n(macro match? (regexp string)\n       '(send @string match @regexp))\n\n(macro match-regex? (string regexp-string glim)\n       '(match? (regex @regexp-string @glim) @string))\n\n(macro replace (string regexp-string replacement)\n       '(send @string replace\n              (regex @regexp-string)\n              @replacement))\n\n(macro replace-all (string regexp-string replacement)\n       '(replace @string @regexp-string 'g))\n\n(macro thunk (...body)\n       '(lambda @{ node this args [] }\n       ...@(map-node body\n                 (#(node)\n                   (if (node? node 'arg-placeholder)\n                       '(argument @(replace node.token \"^#\" \"\"))\n                       node)))))\n(alias-macro thunk #>)\n\n(macro keys (obj)\n       '(Object.keys @obj))\n\n(macro delete (...objects)\n       (interleave \"\\n\" (map objects (#(obj)\n                                 (as-statement [\"delete \" (transpile obj)])))))\n\n(macro delmacro (...macro-names)\n       (each (macro-name) macro-names\n             (delete (get macros (output-formatter (transpile macro-name)))))\n       null)\n(alias-macro delmacro delete-macro)\n\n\n(macro rename-macro (current-macro-name desired-macro-name)\n       (macros.alias-macro current-macro-name desired-macro-name)\n       (macros.delmacro current-macro-name)\n       null)\n\n(macro arguments ()\n       [\"(Array.prototype.slice.apply(arguments))\"])\n\n(macro argument (n)\n       '(get arguments @n))\n\n(macro scoped (...body)\n       '(call (lambda @{node this args []} ...@body)))\n\n(macro scoped-without-source (...body)\n       [\"(function() {\" (indent '(do ...@body)) \"})()\"])\n       \n\n(macro each-key (as obj ...body)\n       '(scoped-without-source\n         @[\"for (var \" (transpile as) \" in \" (transpile obj) \") \"\n            (as-statement '(scoped-without-source ...@body))\n            ]\n         @obj))\n\n(macro switch (obj ...cases)\n       [\"(function() {\"\n         (indent [\"switch(\" (transpile obj) \") {\"\n                   (map cases (#(case-def)\n                                (var case-name-node (first case-def.contents)\n                                     case-labels (if (or (node? case-name-node 'expression)\n                                                         (node? case-name-node 'bracket))\n                                                     case-name-node.contents\n                                                     [case-name-node])\n                                     case-string (interleave \"\\n\" (map case-labels (#(c)\n                                                                                     (if (= 'default c.token)\n                                                                                         \"default:\"\n                                                                                         [\"case \" (transpile c) \":\"])))))\n                                [\"\\n\" case-string (indent '(do ...@(rest case-def.contents)))]))\n                   \"}\"])\n         \"})()\"])\n\n(macro if (...args)\n       [\"(function() {\"\n        (indent\n         (interleave \" else \"\n               (bulk-map args\n                         (#(cond val)\n                           (if (!= (typeof val) 'undefined)\n                                 [\"if (\" (transpile cond) \") {\"\n                                   (indent '(do @val))\n                                   \"}\"]\n                                 [\"{\" (indent '(do @cond)) \"}\"])))))\n        \"})()\"])\n\n(macro chain (object ...calls)\n       (if (= 0 calls.length) (transpile object)\n           (= 1 calls.length) '(send @object ...@(get (first calls) 'contents))\n           (do\n            (var lines (map calls (#(call index)\n                                    [\".\" (transpile (first call.contents))\n                                         \"(\" (interleave \", \" (map (rest call.contents) transpile)) \")\"])))\n\n            [ (transpile object)\n              (first lines)\n              \"\\n  \"\n              (recurse-indent\n               (interleave \"\\n\" (rest lines)))])))\n\n(macro chainable (...names)\n       (each (name) names\n             '(macro @name (target ...calls)\n                     '(chain (call @name @target) ...@calls))))\n\n(macro let (args body)\n       [\"let (\"\n         (interleave \", \" (bulk-map args\n                   (#(k v)\n                     [ (transpile k) \" = \" (transpile v) ])))\n         (if (undefined? body) \");\"\n             [\") {\" (indent (transpile body)) \"}\"])])\n\n(macro instance-of? (item type)\n       [\"(\" (transpile item) \" instanceof \" (transpile type) \")\"])\n\n(macro slice (list begin end)\n       [\"Array.prototype.slice.call(\" (transpile list)\n                                      \", \" (or (transpile begin) 0)\n                                      (if (defined? end) (\", \" (transpile end) \")\") \")\")])\n\n(macro includes? (list item)\n       '(!= -1 (send @list index-of @item)))\n\n\n(macro excludes? (list item)\n       '(= -1 (send @list index-of @item)))\n\n(macro exists? (thing)\n       '(and (defined? @thing) (!= @thing null)))\n\n(macro with-state (k v ...body)\n       (var before (macros.state k))\n       (macros.state k v)\n       (var return-value\n            (interleave \"\\n\" (map body transpile)))\n       (macros.state k before)\n       return-value)\n\n(macro join (glue arr)\n       (if (and (defined? glue) (undefined? arr))\n           (assign arr glue glue undefined))\n       [\"(\" (transpile arr) \").join(\" (if glue (transpile glue) \"\\\"\\\"\") \")\"])\n\n(macro var (...pairs)\n       (var destructured [])\n       (bulk-map pairs (#(lhs rhs)\n                         (switch lhs.type\n                                 ('bracket\n                                  (var symbol (macros.symbol))\n                                  (destructured.push [symbol (transpile rhs)])\n                                  (each (item index) lhs.contents\n                                        (destructured.push [(transpile item) '(get @symbol @index)]))\n                                  (destructured.push [symbol 'undefined]))\n                                 ('brace\n                                  (var symbol (macros.symbol))\n                                  (destructured.push [symbol (transpile rhs)])\n                                  (each (item index) lhs.contents\n                                        (var tr-item (transpile item))\n                                        (destructured.push [tr-item '(get @symbol @[\"\\\"\" tr-item \"\\\"\"])]))\n                                  (destructured.push [symbol 'undefined]))\n\n                                 (default\n                                  (destructured.push [(transpile lhs)\n                                                       (if rhs (transpile rhs) 'undefined)])))))\n\n       (as-statement\n        [\"var \" (interleave \",\\n    \"\n           (map destructured\n                (#(pair)\n                  [(first pair) \" = \" (second pair)]\n                  )))]))\n\n\n(debug false)\n\n(macro default (...pairs)\n       (interleave \"\\n\" (bulk-map pairs (#(name value)\n                                  '(assign @name (ternary (defined? @name) @name @value))))))\n\n(macro namespace () undefined)\n"]}