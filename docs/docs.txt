name: macro core/ternary
description: the simplest way to conditionally execute code.
arguments: (cond if-true if-false)
examples: 
(ternary (< 50 100)
                       "fifty is less than 100"
                       "fifty is more than 100")
(50 < 100) ? "fifty is less than 100" : "fifty is more than 100"

name: macro core/alias-macro
description: stores a duplicate copy of `current-macro-name` as
`new-macro-name` in current namespace.  No output.
arguments: (current-macro-name new-macro-name)
examples: 


name: macro core/send
description: calls the `method` on `object` as a function with `args` as the arguments
arguments: (object method ...args)
examples: 
(send object method first-argument second-argument third-argument)
object.method(firstArgument, secondArgument, thirdArgument)

name: macro core/apply
description: calls the function `fn` with arguments passed as an array in `arglist`
arguments: (fn arglist)
examples: 
(apply my-function [ first-arg second-arg third-arg ])
myFunction.apply(this, [ firstArg, secondArg, thirdArg ])

name: macro core/cons
description: builds an array with `first` as the zeroth index and the
elements provided by array `rest` as the subsequent elements, as
siblings with `first`.  deprecated
arguments: (first rest)
examples: 
(cons 1 [ 2 3 4 ])
[ 1 ].concat([ 2, 3, 4 ])

name: macro core/append
description: adds `additional` elements onto the right-side (tail) of `list`. deprecated
arguments: (list ...additional)
examples: 
(append [ 1 2 3 ] 4 5 6)
[ 1, 2, 3 ].concat([ 4, 5, 6 ])

name: macro core/length
description: fetches length attribute from `arr`
arguments: (arr)
examples: 
(length [ 1 2 3 ])
[ 1, 2, 3 ].length

name: macro core/scoped
description: executes the `body` inside of a self-executing function. The
last statement/expression of the body is returned.
arguments: (...body)
examples: 
(scoped true)
(function() {
  /* /Users/jbr/code/sibilant/include/macros.sibilant:100:16 */

  return true;
}).call(this)

(scoped (var a 1) (+ a 2))
(function() {
  /* /Users/jbr/code/sibilant/include/macros.sibilant:100:30 */

  var a = 1;
  return (a + 2);
}).call(this)

name: macro core/first
description: fetches the first element from `arr`
arguments: (arr)
examples: 
( first my-array)
myArray[0]

name: macro core/second
description: fetches the second element from `arr`
arguments: (arr)
examples: 
( second my-array)
myArray[1]

name: macro core/third
description: fetches the third element from `arr`
arguments: (arr)
examples: 
( third my-array)
myArray[2]

name: macro core/fourth
description: fetches the fourth element from `arr`
arguments: (arr)
examples: 
( fourth my-array)
myArray[3]

name: macro core/fifth
description: fetches the fifth element from `arr`
arguments: (arr)
examples: 
( fifth my-array)
myArray[4]

name: macro core/sixth
description: fetches the sixth element from `arr`
arguments: (arr)
examples: 
( sixth my-array)
myArray[5]

name: macro core/seventh
description: fetches the seventh element from `arr`
arguments: (arr)
examples: 
( seventh my-array)
myArray[6]

name: macro core/eighth
description: fetches the eighth element from `arr`
arguments: (arr)
examples: 
( eighth my-array)
myArray[7]

name: macro core/ninth
description: fetches the ninth element from `arr`
arguments: (arr)
examples: 
( ninth my-array)
myArray[8]

name: macro core/rest
description: fetches all but the first item of `arr`
arguments: (arr)
examples: 
(rest [ 1 2 3 ])
[ 1, 2, 3 ].slice(1)

name: macro core/last
description: fetches just the last element of `arr` by slicing.
arguments: (arr)
examples: 
(last [ 1 2 3 ])
[ 1, 2, 3 ].slice(-1)[0]

name: macro core/+
description: adds `args` using the javascript `+` operator. Since javascript
overloads this for string concatenation, this macro can be used for
this as well.
arguments: (...args)
examples: 
(+ 1 2 3)
(1 + 2 + 3)

(+ 'hello 'world)
("hello" + "world")

name: macro core/-
description: subtracts each subsequent element of `args`
arguments: (...args)
examples: 
(- 2 1)
(2 - 1)

(- 10 5 1)
(10 - 5 - 1)

name: macro core/*
description: multiplies elements of `args`
arguments: (...args)
examples: 
(* 3 4 5)
(3 * 4 * 5)

name: macro core//
description: divides each subsequent element of `args`
arguments: (...args)
examples: 
(/ 1 2)
(1 / 2)

(/ 1 2 3)
(1 / 2 / 3)

name: macro core/or
description: short circuiting operator returns the first element of `args` that evaluates to be truthy
arguments: (...args)
examples: 
(or (= 1 2) (string? []) "one is not two and an array is not a string")
(1 === 2 || typeof [] === "string" || "one is not two and an array is not a string")

name: macro core/and
description: returns the last element if all elements of `args` are truthy, or the
first non-truthy element if it exists
arguments: (...args)
examples: 
(and (string? "string") (number? 10) (= 1 1))
(typeof "string" === "string" && typeof 10 === "number" && 1 === 1)

name: macro core/mod
description: modulus operator
arguments: (...args)
examples: 
(mod 10 2)
(10 % 2)

name: macro core/>
description: compares `args` from left to right, returning true if each element is greater than than the next
arguments: (...args)
examples: 
( > a b c)
(a > b && b > c)

( > a b)
a > b

name: macro core/<
description: compares `args` from left to right, returning true if each element is less than than the next
arguments: (...args)
examples: 
( < a b c)
(a < b && b < c)

( < a b)
a < b

name: macro core/<=
description: compares `args` from left to right, returning true if each element is less than or equal than the next
arguments: (...args)
examples: 
( <= a b c)
(a <= b && b <= c)

( <= a b)
a <= b

name: macro core/>=
description: compares `args` from left to right, returning true if each element is greater than or equal than the next
arguments: (...args)
examples: 
( >= a b c)
(a >= b && b >= c)

( >= a b)
a >= b

name: macro core/!=
description: compares `args` from left to right, returning true if each element is not equal (using threequals) than the next
arguments: (...args)
examples: 
( != a b c)
(a !== b && b !== c)

( != a b)
a !== b

name: macro core/=
description: compares `args` from left to right, returning true if each element is equal (using threequals) than the next
arguments: (...args)
examples: 
( = a b c)
(a === b && b === c)

( = a b)
a === b

name: macro core/incr-by
description: increments `item` by `increment`
arguments: (item increment)
examples: 
(incr-by n 5)
n += 5

name: macro core/incr
description: increments item by 1
arguments: (item)
examples: 
(incr i)
((i)++)

name: macro core/decr
description: decrements item by 1
arguments: (item)
examples: 
(decr i)
((i)--)

name: macro core/new
description: uses the javascript new keyword to construct an object using
      `constructor`, with `args` passed as arguments to the constructor.
arguments: (constructor ...args)
examples: 
(new RegExp "hello" 'g)
(new RegExp("hello", "g"))

name: macro core/regex
description: builds a regex using `pattern` and `flags` as arguments to the RegExp constructor
arguments: (pattern flags)
examples: 
(regex "[0-9]+")
(new RegExp("[0-9]+", undefined))

(regex "0x[0-9a-f]+" 'i)
(new RegExp("0x[0-9a-f]+", "i"))

name: macro core/zero?
description: predicate to test for equality with zero
arguments: (item)
examples: 
(zero? n)
n === 0

name: macro core/empty?
description: returns true if the array `arr` has a length of zero
arguments: (arr)
examples: 
(empty? [])
0 === [].length

name: macro core/odd?
description: returns true if `number` is not divisible by 2
arguments: (number)
examples: 
(odd? 5)
1 === (5 % 2)

name: macro core/even?
description: returns true if `number` is divisible by 2 with no remainder
arguments: (number)
examples: 
(even? 10)
0 === (10 % 2)

name: macro core/typeof
description: exposes the javascript typeof operator. most often, predicates
such as `string?`, `function?`, `number?`, etc are preferred.
arguments: (thing)
examples: 
(typeof 5)
typeof 5

name: macro core/string?
description: returns true if all of the `things` are javascript strings
arguments: (...things)
examples: 
(string? test-object)
typeof testObject === "string"

(string? 'yes 'yes 'yes)
(typeof "yes" === "string" && typeof "yes" === "string" && typeof "yes" === "string")

name: macro core/function?
description: returns true if all of the `things` are functions
arguments: (...things)
examples: 
(function? fn)
typeof fn === "function"

(function? err cb)
(typeof err === "function" && typeof cb === "function")

name: macro core/undefined?
description: returns true if all of the `things` are undefined, as tested
with `typeof`, not equality with literal undefined. This is the
inverse of `defined?`
arguments: (...things)
examples: 
(undefined? argument)
typeof argument === "undefined"

(undefined? 1 2 undefined)
(typeof 1 === "undefined" && typeof 2 === "undefined" && typeof undefined === "undefined")

name: macro core/defined?
description: returns true if none of the `things` are undefined, as tested
with `typeof`. This is the inverse of `defined?`
arguments: (...things)
examples: 
(defined? variable)
typeof variable !== "undefined"

(defined? var1 var2 var3)
(typeof var1 !== "undefined" && typeof var2 !== "undefined" && typeof var3 !== "undefined")

name: macro core/number?
description: returns true if all of the `things` are numbers, as tested
with `typeof`
arguments: (...things)
examples: 
(number? 1)
typeof 1 === "number"

(number? 1 2 3)
(typeof 1 === "number" && typeof 2 === "number" && typeof 3 === "number")

name: macro core/pipe
description: inserts the result of each subsequent call in `calls` as the
second argument to the next macro. This is very much akin to clojure's thread-first arrow or elixir's pipe operator
references:
https://clojuredocs.org/clojure.core/-%3E
http://elixir-lang.org/docs/v1.0/elixir/Kernel.html#|>/2
arguments: (...calls)
examples: 
(pipe "a b c d"
                     .to-upper-case
                     (.replace "A" "X")
                     (.split " ")
                     first
                     (concat " marks the spot"))
("a b c d".toUpperCase().replace("A", "X").split(" ")[0] + " marks the spot")

(pipe "{\"a\": {\"b\": [ 1, 2, 3 ]}}"
                        JSON.parse
                        (get 'a)
                        JSON.stringify)
JSON.stringify(JSON.parse("{\"a\": {\"b\": [ 1, 2, 3 ]}}").a)

name: macro core/comment
description: inserts `contents` transpiled to javascript as a comment in the
output file, removing it from execution.
arguments: (...contents)
examples: 
(comment (scoped 1))
// (function() {
//   /* /Users/jbr/code/sibilant/include/macros.sibilant:356:23 */
// 
//   return 1;
// }).call(this)

name: macro core/array?
description: returns true if `thing` is an array in javascript. aliased as
`list?`.
arguments: (thing)
examples: 
(array? arr)
((arr) && typeof (arr) === "object" && (arr).constructor.name === "Array")

name: macro core/when
description: evaluates statements in `body` if `condition` is true. `body`
      is `scoped` in a self-evaluating function to support having a
      return value from the if statement.
arguments: (condition ...body)
examples: 
(when (< 3 i) (console.log i) (get arr i))
(function() {
  if (3 < i) {
    console.log(i);
    return arr[i];
  }
}).call(this)

name: macro core/not
description: boolean negation, as determined by javascript truthiness
references:
https://developer.mozilla.org/en-US/docs/Glossary/Truthy
https://developer.mozilla.org/en-US/docs/Glossary/Falsy
arguments: (exp)
examples: 
(not (string? 1))
!(typeof 1 === "string")

name: macro core/unless
description: evaluates statements in `body` if `condition` is falsy. `body`
      is `scoped` in a self-evaluating function to support having a
      return value from the if statement.
arguments: (condition ...body)
examples: 
(unless (< 3 i) (console.log i) (get arr i))
(function() {
  if (!(3 < i)) {
    console.log(i);
    return arr[i];
  }
}).call(this)

name: macro core/assign
description: assigns alternating keys and values in `args`.  This works much
like `var`, but without the var keyword.  It is important to
understand variable scope in javascript in order to use this macro safely.
note that this macro does not currently support destructuring like `var` does
arguments: (...args)
examples: 
(assign a 1)
a = 1;

(assign a 1 b 2)
a = 1;
b = 2;

name: macro core/log-pretty
description: outputs debug information about `arg`.  If `label` is
omitted (only one argument is provided), the name of the variable or
expression of that first expression will be logged. Aliased as `pretty-log`
arguments: (label arg)
examples: 
(log-pretty 'my-label value)
console.log(("/Users/jbr/code/sibilant/include/macros.sibilant:440" + " " + "myLabel" + " = " + prettify(value)))

(log-pretty (+ 1 2))
console.log(("/Users/jbr/code/sibilant/include/macros.sibilant:441" + " " + "(+ 1 2)" + " = " + prettify((1 + 2))))

name: macro core/each
description: iterates over `array`, evaluating `body` once for each value in
`array`.  If `item` is a literal name, that will be the variable into
which the `array` element is yielded (current value).  If `item` is an expression, it
can contain the current value, the index, and the `array`.
references:
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach
arguments: (item array ...body)
examples: 
(each number [ 1 2 3 ] (console.log number))
[ 1, 2, 3 ].forEach((function(number) {
  /* /Users/jbr/code/sibilant/include/macros.sibilant:455:17 */

  return console.log(number);
}))

(each (letter index) `[ a b c d ]
                       (set letters letter index)
                       (pipe letter (.to-upper-case) (console.log)))
[ "a", "b", "c", "d" ].forEach((function(letter, index) {
  /* /Users/jbr/code/sibilant/include/macros.sibilant:456:17 */

  letters[letter] = index;
  return console.log(letter.toUpperCase());
}))

name: macro core/throw
description: throws a new javascript error with arguments as the string
arguments: (error)
examples: 
(throw (new Error "could not find matching socks"))
throw (new Error("could not find matching socks"))

name: macro core/as-boolean
description: double-negates `expr`, converting it to a boolean
arguments: (expr)
examples: 
(as-boolean 0)
(!!(0))

(as-boolean true)
(!!(true))

name: macro core/while
description: evaluates the `body` as long as `condition` is truthy,
returning the value of the last expression in `block` when `condition`
ceases to be truthy. See also `until`
arguments: (condition ...body)
examples: 
(while (> 5 i) (console.log i) (decr i))
(function() {
  var $_symbol1_$ = undefined;
  while (5 > i) {
    $_symbol1_$ = (function() {
      console.log(i);
      return ((i)--);
    }).call(this);
  };
  return $_symbol1_$;
}).call(this)

name: macro core/until
description: evaluates the `body` as long as `condition` is falsy,
returning the value of the last expression in `block` when `condition`
ceases to be falsy. See also `while`
arguments: (condition ...body)
examples: 
(until (< 5 i) (console.log i) (incr i))
(function() {
  var $_symbol2_$ = undefined;
  while (!(5 < i)) {
    $_symbol2_$ = (function() {
      console.log(i);
      return ((i)++);
    }).call(this);
  };
  return $_symbol2_$;
}).call(this)

name: macro core/match?
description: returns true if the `string` matches `regexp`.  Deprecated in
      preference to `.match` (`send` dot-invocation).
arguments: (regexp string)
examples: 
(match? (regex "^[a-z]+$" 'i) 'word)
"word".match((new RegExp("^[a-z]+$", "i")))

name: macro core/match-regex?
description: similar to `match?` but builds a regex out of the `pattern` and `flags`.
arguments: (string pattern flags)
examples: 
(match-regex? 'word "^[a-z]+$" 'i)
"word".match((new RegExp("^[a-z]+$", "i")))

name: macro core/replace
description: replaces the first occurance of `pattern` (as a regex) with `replacement`
arguments: (string pattern replacement)
examples: 
(replace "hello world" "l+o" "y there,")
"hello world".replace((new RegExp("l+o", undefined)), "y there,")

name: macro core/replace-all
description: replaces all occurrances of `pattern` (as a regex) with `replacement`
arguments: (string pattern replacement)
examples: 
(replace-all "503-555-1212" "[0-9]" "#")
"503-555-1212".replace((new RegExp("[0-9]", "g")), "#")

name: macro core/thunk
description: most often called as its alias, `#>`, thunk creates a function
with no named arguments. To refer to arguments anonymously, use #n,
such as #0 for the first argument.
arguments: (...body)
examples: 
(.map [ 1 2 3 ] (#> (+ 1 #0)))
[ 1, 2, 3 ].map((function() {
  /* /Users/jbr/code/sibilant/include/macros.sibilant:597:34 */

  return (1 + arguments[0]);
}))

(window.set-timeout (#> (console.log 'here)) 10)
window.setTimeout((function() {
  /* /Users/jbr/code/sibilant/include/macros.sibilant:598:38 */

  return console.log("here");
}), 10)

name: macro core/pipe-thunk
description: most often called as its alias, `#->`, pipe-thunk applies a pipe chain to the argument of a function and returns the result
arguments: (...calls)
examples: 
(.map `[ a b c ] (#-> (.to-upper-case) (concat " is a letter")))
[ "a", "b", "c" ].map((function() {
  /* /Users/jbr/code/sibilant/include/macros.sibilant:614:30 */

  return (arguments[0].toUpperCase() + " is a letter");
}))

name: macro core/keys
description: returns the property names of `obj`.
references:
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys
arguments: (obj)
examples: 
(keys { a 1 b 2 })
Object.keys({
  a: 1,
  b: 2
})

name: macro core/delete
description: uses the javascript delete keyword on any number of `objects`.
      Use in conjunction with `get` or dotted literal notation (a.b).
arguments: (...objects)
examples: 
(delete object.a object.b)
delete object.a;
delete object.b;

(delete (get object attribute) (get object "other attribute"))
delete object[attribute];
delete object["other attribute"];

name: macro core/delete-macro
description: deletes each macro name in `macro-names` from the current namespace. Use carefully
arguments: (...macro-names)
examples: 


name: macro core/rename-macro
description: moves macro from `current-macro-name` to `new-macro-name`. Use carefully
arguments: (current-macro-name new-macro-name)
examples: 


name: macro core/arguments
description: transforms function arguments into an array, using the Array prototype's slice
arguments: ()
examples: 
(arguments)
(Array.prototype.slice.apply(arguments))

name: macro core/argument
description: `get`s the argument at `index` in the current function context
arguments: (index)
examples: 
(argument 3)
arguments[3]

name: macro core/each-key
description: iterates over each attribute in `obj`
arguments: (as obj ...body)
examples: 
(each-key key { a 1 b 2 } (console.log key))
Object.keys({
  a: 1,
  b: 2
}).forEach((function(key) {
  /* /Users/jbr/code/sibilant/include/macros.sibilant:692:14 */

  return console.log(key);
}))

name: macro core/switch
description: uses the javascript switch construction to test equality.  documentation todo: needs better description
arguments: (obj ...cases)
examples: 
(switch char
                         ('a "it was an a")
                         ('b (console.log "found a b!")
                             "it was a b")
                         ([1 2 3 4 5] "it was an integer from one to five")
                         (default "not sure"))
(function() {
  switch(char) {
  case "a":
    return "it was an a";
  
  case "b":
    console.log("found a b!");
    return "it was a b";
  
  case 1:
  case 2:
  case 3:
  case 4:
  case 5:
    return "it was an integer from one to five";
  
  default:
    return "not sure";
  }
}).call(this)

name: macro core/if
description: tests any number of `alternating-conditions-and-branches`.  If
      an odd number of branches are supplied, the final branch is a
      default else clause.  To evaluate more than one expression as a
      branch, use the `do` macro, as shown in the examples:
arguments: (...alternating-conditions-and-branches)
examples: 
(if true (console.log 'here))
(function() {
  if (true) {
    return console.log("here");
  }
}).call(this)

(if (= 1 arguments.length) (console.log "one argument")
                     (= 'blue favorite-color) (console.log "blue")
                     (assign examples 'difficult))
(function() {
  if (1 === arguments.length) {
    return console.log("one argument");
  } else if ("blue" === favoriteColor) {
    return console.log("blue");
  } else {
    return examples = "difficult";
  }
}).call(this)

(if (foo?) (do (a b)
                                (c))
                     (bar?) (do (baz)
                                (wibble))
                     (do (d e)
                         (console.log 'default)))
(function() {
  if (foo__QUERY()) {
    a(b);
    return c();
  } else if (bar__QUERY()) {
    baz();
    return wibble();
  } else {
    d(e);
    return console.log("default");
  }
}).call(this)

name: macro core/chain
description: similar to `pipe`, this macro allows function calls to be applied
in sequence, as is common in fluent interfaces. deprecated in preference to `pipe`
arguments: (object ...calls)
examples: 
(chain a (b c d) (e) (f g))
a.b(c, d)
  .e()
  .f(g)

name: macro core/instance-of?
description: uses the javascript `instanceof` operator to check if `item` is of `type`.
arguments: (item type)
examples: 
(instance-of? (new Date) Date)
((new Date()) instanceof Date)

name: macro core/includes?
description: returns true if `haystack` includes `needle`.  `haystack` can be a string or array/list.
arguments: (haystack needle)
examples: 
(includes? 'hello 'h)
"hello".indexOf("h") !== -1

(includes? `[ Veni vidi vici] 'vidi)
[ "Veni", "vidi", "vici" ].indexOf("vidi") !== -1

name: macro core/excludes?
description: returns true if `haystack` does NOT include `needle`.
`haystack` can be a string or array/list
arguments: (haystack needle)
examples: 
(excludes? 'hello 10)
"hello".indexOf(10) === -1

(excludes? `[ Veni vidi vici] 'attenti)
[ "Veni", "vidi", "vici" ].indexOf("attenti") === -1

name: macro core/exists?
description: similar to the javascript truthiness predicate `as-boolean`, returns true unless the `thing` is undefined or null
arguments: (thing)
examples: 
(exists? window)
(typeof window !== "undefined" && window !== null)

name: macro core/join
description: combines elements of array `arr` into a string, inserting
`glue` string between each element.  if `glue` is omitted (only one
argument provided), the elements of `arr` are joined with an empty
string
arguments: (arr glue)
examples: 
(join `[ a few words ]  ", " )
[ "a", "few", "words" ].join(", ")

(join `[ several more words ])
[ "several", "more", "words" ].join("")

name: macro core/var
description: registers variables in `pairs` inside of the current scope using the javascript var keyword.
destructuring from arrays and objects is also supported, as shown in the examples
arguments: (...pairs)
examples: 
(var a 1 b 2)
var a = 1,
    b = 2;

(var a 1)
var a = 1;

(var a)
var a = undefined;

(var {a} {a 1 b 2} c 3)
var $_symbol3_$ = {
  a: 1,
  b: 2
},
    a = $_symbol3_$.a,
    $_symbol3_$ = undefined,
    c = 3;

(var a 1 [b c] [2 3])
var a = 1,
    $_symbol4_$ = [ 2, 3 ],
    b = $_symbol4_$[0],
    c = $_symbol4_$[1],
    $_symbol4_$ = undefined;

name: macro core/default
description: sets default values for variables in current scope. `pairs` are
alternating variable names and default values
arguments: (...pairs)
examples: 
(default a 10 b 20)
a = (typeof a !== "undefined") ? a : 10;
b = (typeof b !== "undefined") ? b : 20;

name: macro core/has-key?
description: checks if `object` has property `key`.  returns true or false.
arguments: (object key)
examples: 
(has-key? object 'a)
object.hasOwnProperty("a")

name: macro core/get
description: retreives object properties, potentially deeply. If more than one `keys` are provided,
`get` fetches deeply into nested objects or arrays.
When javascript dot notation can be used (`a.b = 3`), it is.
Otherwise, bracket notation is used.
arguments: (obj ...keys)
examples: 
(get an-object 'static-attribute-name)
anObject.staticAttributeName

(get object dynamic-attribute-name)
object[dynamicAttributeName]

(get object "these attributes" "can't be dotted")
object["these attributes"]["can't be dotted"]

(get array 0)
array[0]

(get object 'a 'b c)
object.a.b[c]

(get array 0 1 2)
array[0][1][2]

name: macro core/set
description: assigns object properties to `arr` in pairs, alternating between keys and values.
When javascript dot notation can be used (`a.b = 3`), it is.  Otherwise, bracket notation is used
arguments: (arr ...kv-pairs)
examples: 
(set an-object 'static-attribute-name 'value)
anObject.staticAttributeName = "value";

(set object dynamic-attribute-name "key name determined at runtime")
object[dynamicAttributeName] = "key name determined at runtime";

(set array 0 "first element of array")
array[0] = "first element of array";

(set object "can't be dotted" 'value)
object["can't be dotted"] = "value";

(set object 'first-attribute 'first-value
                      'second-attribute 'second-value)
object.firstAttribute = "firstValue";
object.secondAttribute = "secondValue";

name: macro core/lower-case?
description: checks if a string is identical to the lower-cased version of itself
arguments: (str)
examples: 
(lower-case? "abc")
"abc".toLowerCase() === "abc"

name: macro core/upper-case?
description: checks if a string is identical to the upper-cased version of itself
arguments: (str)
examples: 
(lower-case? "abc")
"abc".toLowerCase() === "abc"

name: macro core/source-mapping-url
description: inserts a pragma for source-mapping-url
arguments: (url)
examples: 
(source-mapping-url "/example.map")
//# sourceMappingURL=/example.map



